
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/utils/misc.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

/****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
 Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

 https://www.cocos.com/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
  worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
  not use Cocos Creator software for developing other software or tools that's
  used for developing games. You are not granted to publish, distribute,
  sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var js = require('../platform/js');
/**
 * misc utilities
 * @class misc
 * @static
 */


var misc = {};

misc.propertyDefine = function (ctor, sameNameGetSets, diffNameGetSets) {
  function define(np, propName, getter, setter) {
    var pd = Object.getOwnPropertyDescriptor(np, propName);

    if (pd) {
      if (pd.get) np[getter] = pd.get;
      if (pd.set && setter) np[setter] = pd.set;
    } else {
      var getterFunc = np[getter];

      if (CC_DEV && !getterFunc) {
        var clsName = cc.Class._isCCClass(ctor) && js.getClassName(ctor) || ctor.name || '(anonymous class)';
        cc.warnID(5700, propName, getter, clsName);
      } else {
        js.getset(np, propName, getterFunc, np[setter]);
      }
    }
  }

  var propName,
      np = ctor.prototype;

  for (var i = 0; i < sameNameGetSets.length; i++) {
    propName = sameNameGetSets[i];
    var suffix = propName[0].toUpperCase() + propName.slice(1);
    define(np, propName, 'get' + suffix, 'set' + suffix);
  }

  for (propName in diffNameGetSets) {
    var getset = diffNameGetSets[propName];
    define(np, propName, getset[0], getset[1]);
  }
};
/**
 * @param {Number} x
 * @return {Number}
 * Constructor
 */


misc.NextPOT = function (x) {
  x = x - 1;
  x = x | x >> 1;
  x = x | x >> 2;
  x = x | x >> 4;
  x = x | x >> 8;
  x = x | x >> 16;
  return x + 1;
}; //var DirtyFlags = m.DirtyFlags = {
//    TRANSFORM: 1 << 0,
//    SIZE: 1 << 1,
//    //Visible:
//    //Color:
//    //Opacity
//    //Cache
//    //Order
//    //Text
//    //Gradient
//    ALL: (1 << 2) - 1
//};
//
//DirtyFlags.WIDGET = DirtyFlags.TRANSFORM | DirtyFlags.SIZE;


if (CC_EDITOR) {
  // use anonymous function here to ensure it will not being hoisted without CC_EDITOR
  misc.tryCatchFunctor_EDITOR = function (funcName) {
    return Function('target', 'try {\n' + '  target.' + funcName + '();\n' + '}\n' + 'catch (e) {\n' + '  cc._throw(e);\n' + '}');
  };
}

misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var BASE64_VALUES = new Array(123); // max char code in base64Keys

for (var i = 0; i < 123; ++i) {
  BASE64_VALUES[i] = 64;
} // fill with placeholder('=') index


for (var _i = 0; _i < 64; ++_i) {
  BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
} // decoded value indexed by base64 char code


misc.BASE64_VALUES = BASE64_VALUES; // set value to map, if key exists, push to array

misc.pushToMap = function (map, key, value, pushFront) {
  var exists = map[key];

  if (exists) {
    if (Array.isArray(exists)) {
      if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else {
        exists.push(value);
      }
    } else {
      map[key] = pushFront ? [value, exists] : [exists, value];
    }
  } else {
    map[key] = value;
  }
};
/**
 * !#en Clamp a value between from and to.
 * !#zh
 * 限定浮点数的最大最小值。<br/>
 * 数值大于 max_inclusive 则返回 max_inclusive。<br/>
 * 数值小于 min_inclusive 则返回 min_inclusive。<br/>
 * 否则返回自身。
 * @method clampf
 * @param {Number} value
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {Number}
 * @example
 * var v1 = cc.misc.clampf(20, 0, 20); // 20;
 * var v2 = cc.misc.clampf(-1, 0, 20); //  0;
 * var v3 = cc.misc.clampf(10, 0, 20); // 10;
 */


misc.clampf = function (value, min_inclusive, max_inclusive) {
  if (min_inclusive > max_inclusive) {
    var temp = min_inclusive;
    min_inclusive = max_inclusive;
    max_inclusive = temp;
  }

  return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};
/**
 * !#en Clamp a value between 0 and 1.
 * !#zh 限定浮点数的取值范围为 0 ~ 1 之间。
 * @method clamp01
 * @param {Number} value
 * @return {Number}
 * @example
 * var v1 = cc.misc.clamp01(20);  // 1;
 * var v2 = cc.misc.clamp01(-1);  // 0;
 * var v3 = cc.misc.clamp01(0.5); // 0.5;
 */


misc.clamp01 = function (value) {
  return value < 0 ? 0 : value < 1 ? value : 1;
};
/**
 * Linear interpolation between 2 numbers, the ratio sets how much it is biased to each end
 * @method lerp
 * @param {Number} a number A
 * @param {Number} b number B
 * @param {Number} r ratio between 0 and 1
 * @return {Number}
 * @example {@link cocos2d/core/platform/CCMacro/lerp.js}
 */


misc.lerp = function (a, b, r) {
  return a + (b - a) * r;
};
/**
 * converts degrees to radians
 * @param {Number} angle
 * @return {Number}
 * @method degreesToRadians
 */


misc.degreesToRadians = function (angle) {
  return angle * cc.macro.RAD;
};
/**
 * converts radians to degrees
 * @param {Number} angle
 * @return {Number}
 * @method radiansToDegrees
 */


misc.radiansToDegrees = function (angle) {
  return angle * cc.macro.DEG;
};

cc.misc = module.exports = misc;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXHV0aWxzXFxtaXNjLmpzIl0sIm5hbWVzIjpbImpzIiwicmVxdWlyZSIsIm1pc2MiLCJwcm9wZXJ0eURlZmluZSIsImN0b3IiLCJzYW1lTmFtZUdldFNldHMiLCJkaWZmTmFtZUdldFNldHMiLCJkZWZpbmUiLCJucCIsInByb3BOYW1lIiwiZ2V0dGVyIiwic2V0dGVyIiwicGQiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJnZXR0ZXJGdW5jIiwiQ0NfREVWIiwiY2xzTmFtZSIsImNjIiwiQ2xhc3MiLCJfaXNDQ0NsYXNzIiwiZ2V0Q2xhc3NOYW1lIiwibmFtZSIsIndhcm5JRCIsImdldHNldCIsInByb3RvdHlwZSIsImkiLCJsZW5ndGgiLCJzdWZmaXgiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiTmV4dFBPVCIsIngiLCJDQ19FRElUT1IiLCJ0cnlDYXRjaEZ1bmN0b3JfRURJVE9SIiwiZnVuY05hbWUiLCJGdW5jdGlvbiIsIkJVSUxUSU5fQ0xBU1NJRF9SRSIsIkJBU0U2NF9LRVlTIiwiQkFTRTY0X1ZBTFVFUyIsIkFycmF5IiwiY2hhckNvZGVBdCIsInB1c2hUb01hcCIsIm1hcCIsImtleSIsInZhbHVlIiwicHVzaEZyb250IiwiZXhpc3RzIiwiaXNBcnJheSIsInB1c2giLCJjbGFtcGYiLCJtaW5faW5jbHVzaXZlIiwibWF4X2luY2x1c2l2ZSIsInRlbXAiLCJjbGFtcDAxIiwibGVycCIsImEiLCJiIiwiciIsImRlZ3JlZXNUb1JhZGlhbnMiLCJhbmdsZSIsIm1hY3JvIiwiUkFEIiwicmFkaWFuc1RvRGVncmVlcyIsIkRFRyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LGFBQXhCLEdBQXdDTixLQUFLLEdBQUdPLGFBQVIsR0FBd0JQLEtBQXhCLEdBQWdDTyxhQUEvRTtBQUNILENBUEQ7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXBELElBQUksQ0FBQ3NELE9BQUwsR0FBZSxVQUFVVCxLQUFWLEVBQWlCO0FBQzVCLFNBQU9BLEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBWixHQUFnQkEsS0FBSyxHQUFHLENBQVIsR0FBWUEsS0FBWixHQUFvQixDQUEzQztBQUNILENBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBN0MsSUFBSSxDQUFDdUQsSUFBTCxHQUFZLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI7QUFDM0IsU0FBT0YsQ0FBQyxHQUFHLENBQUNDLENBQUMsR0FBR0QsQ0FBTCxJQUFVRSxDQUFyQjtBQUNILENBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBMUQsSUFBSSxDQUFDMkQsZ0JBQUwsR0FBd0IsVUFBVUMsS0FBVixFQUFpQjtBQUNyQyxTQUFPQSxLQUFLLEdBQUcxQyxFQUFFLENBQUMyQyxLQUFILENBQVNDLEdBQXhCO0FBQ0gsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E5RCxJQUFJLENBQUMrRCxnQkFBTCxHQUF3QixVQUFVSCxLQUFWLEVBQWlCO0FBQ3JDLFNBQU9BLEtBQUssR0FBRzFDLEVBQUUsQ0FBQzJDLEtBQUgsQ0FBU0csR0FBeEI7QUFDSCxDQUZEOztBQUlBOUMsRUFBRSxDQUFDbEIsSUFBSCxHQUFVaUUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCbEUsSUFBM0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYgQ2h1a29uZyBUZWNobm9sb2dpZXMgSW5jLlxyXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXHJcblxyXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcclxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXHJcbiAgbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xyXG4gIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cclxuXHJcbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxyXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cclxuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuIFRIRSBTT0ZUV0FSRS5cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG52YXIganMgPSByZXF1aXJlKCcuLi9wbGF0Zm9ybS9qcycpO1xyXG5cclxuLyoqXHJcbiAqIG1pc2MgdXRpbGl0aWVzXHJcbiAqIEBjbGFzcyBtaXNjXHJcbiAqIEBzdGF0aWNcclxuICovXHJcbnZhciBtaXNjID0ge307XHJcblxyXG5taXNjLnByb3BlcnR5RGVmaW5lID0gZnVuY3Rpb24gKGN0b3IsIHNhbWVOYW1lR2V0U2V0cywgZGlmZk5hbWVHZXRTZXRzKSB7XHJcbiAgICBmdW5jdGlvbiBkZWZpbmUgKG5wLCBwcm9wTmFtZSwgZ2V0dGVyLCBzZXR0ZXIpIHtcclxuICAgICAgICB2YXIgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5wLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgaWYgKHBkKSB7XHJcbiAgICAgICAgICAgIGlmIChwZC5nZXQpIG5wW2dldHRlcl0gPSBwZC5nZXQ7XHJcbiAgICAgICAgICAgIGlmIChwZC5zZXQgJiYgc2V0dGVyKSBucFtzZXR0ZXJdID0gcGQuc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGdldHRlckZ1bmMgPSBucFtnZXR0ZXJdO1xyXG4gICAgICAgICAgICBpZiAoQ0NfREVWICYmICFnZXR0ZXJGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xzTmFtZSA9IChjYy5DbGFzcy5faXNDQ0NsYXNzKGN0b3IpICYmIGpzLmdldENsYXNzTmFtZShjdG9yKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Rvci5uYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYW5vbnltb3VzIGNsYXNzKSc7XHJcbiAgICAgICAgICAgICAgICBjYy53YXJuSUQoNTcwMCwgcHJvcE5hbWUsIGdldHRlciwgY2xzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBqcy5nZXRzZXQobnAsIHByb3BOYW1lLCBnZXR0ZXJGdW5jLCBucFtzZXR0ZXJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBwcm9wTmFtZSwgbnAgPSBjdG9yLnByb3RvdHlwZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtZU5hbWVHZXRTZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcHJvcE5hbWUgPSBzYW1lTmFtZUdldFNldHNbaV07XHJcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHByb3BOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zbGljZSgxKTtcclxuICAgICAgICBkZWZpbmUobnAsIHByb3BOYW1lLCAnZ2V0JyArIHN1ZmZpeCwgJ3NldCcgKyBzdWZmaXgpO1xyXG4gICAgfVxyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkaWZmTmFtZUdldFNldHMpIHtcclxuICAgICAgICB2YXIgZ2V0c2V0ID0gZGlmZk5hbWVHZXRTZXRzW3Byb3BOYW1lXTtcclxuICAgICAgICBkZWZpbmUobnAsIHByb3BOYW1lLCBnZXRzZXRbMF0sIGdldHNldFsxXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKiBDb25zdHJ1Y3RvclxyXG4gKi9cclxubWlzYy5OZXh0UE9UID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIHggPSB4IC0gMTtcclxuICAgIHggPSB4IHwgKHggPj4gMSk7XHJcbiAgICB4ID0geCB8ICh4ID4+IDIpO1xyXG4gICAgeCA9IHggfCAoeCA+PiA0KTtcclxuICAgIHggPSB4IHwgKHggPj4gOCk7XHJcbiAgICB4ID0geCB8ICh4ID4+IDE2KTtcclxuICAgIHJldHVybiB4ICsgMTtcclxufTtcclxuXHJcbi8vdmFyIERpcnR5RmxhZ3MgPSBtLkRpcnR5RmxhZ3MgPSB7XHJcbi8vICAgIFRSQU5TRk9STTogMSA8PCAwLFxyXG4vLyAgICBTSVpFOiAxIDw8IDEsXHJcbi8vICAgIC8vVmlzaWJsZTpcclxuLy8gICAgLy9Db2xvcjpcclxuLy8gICAgLy9PcGFjaXR5XHJcbi8vICAgIC8vQ2FjaGVcclxuLy8gICAgLy9PcmRlclxyXG4vLyAgICAvL1RleHRcclxuLy8gICAgLy9HcmFkaWVudFxyXG4vLyAgICBBTEw6ICgxIDw8IDIpIC0gMVxyXG4vL307XHJcbi8vXHJcbi8vRGlydHlGbGFncy5XSURHRVQgPSBEaXJ0eUZsYWdzLlRSQU5TRk9STSB8IERpcnR5RmxhZ3MuU0laRTtcclxuXHJcbmlmIChDQ19FRElUT1IpIHtcclxuICAgIC8vIHVzZSBhbm9ueW1vdXMgZnVuY3Rpb24gaGVyZSB0byBlbnN1cmUgaXQgd2lsbCBub3QgYmVpbmcgaG9pc3RlZCB3aXRob3V0IENDX0VESVRPUlxyXG5cclxuICAgIG1pc2MudHJ5Q2F0Y2hGdW5jdG9yX0VESVRPUiA9IGZ1bmN0aW9uIChmdW5jTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBGdW5jdGlvbigndGFyZ2V0JyxcclxuICAgICAgICAgICAgJ3RyeSB7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHRhcmdldC4nICsgZnVuY05hbWUgKyAnKCk7XFxuJyArXHJcbiAgICAgICAgICAgICd9XFxuJyArXHJcbiAgICAgICAgICAgICdjYXRjaCAoZSkge1xcbicgK1xyXG4gICAgICAgICAgICAnICBjYy5fdGhyb3coZSk7XFxuJyArXHJcbiAgICAgICAgICAgICd9Jyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5taXNjLkJVSUxUSU5fQ0xBU1NJRF9SRSA9IC9eKD86Y2N8ZHJhZ29uQm9uZXN8c3B8Y2NzZylcXC4uKy87XHJcblxyXG5cclxudmFyIEJBU0U2NF9LRVlTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcclxudmFyIEJBU0U2NF9WQUxVRVMgPSBuZXcgQXJyYXkoMTIzKTsgLy8gbWF4IGNoYXIgY29kZSBpbiBiYXNlNjRLZXlzXHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMTIzOyArK2kpIEJBU0U2NF9WQUxVRVNbaV0gPSA2NDsgLy8gZmlsbCB3aXRoIHBsYWNlaG9sZGVyKCc9JykgaW5kZXhcclxuZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgKytpKSBCQVNFNjRfVkFMVUVTW0JBU0U2NF9LRVlTLmNoYXJDb2RlQXQoaSldID0gaTtcclxuXHJcbi8vIGRlY29kZWQgdmFsdWUgaW5kZXhlZCBieSBiYXNlNjQgY2hhciBjb2RlXHJcbm1pc2MuQkFTRTY0X1ZBTFVFUyA9IEJBU0U2NF9WQUxVRVM7XHJcblxyXG4vLyBzZXQgdmFsdWUgdG8gbWFwLCBpZiBrZXkgZXhpc3RzLCBwdXNoIHRvIGFycmF5XHJcbm1pc2MucHVzaFRvTWFwID0gZnVuY3Rpb24gKG1hcCwga2V5LCB2YWx1ZSwgcHVzaEZyb250KSB7XHJcbiAgICB2YXIgZXhpc3RzID0gbWFwW2tleV07XHJcbiAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RzKSkge1xyXG4gICAgICAgICAgICBpZiAocHVzaEZyb250KSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdHMucHVzaChleGlzdHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgZXhpc3RzWzBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcFtrZXldID0gKHB1c2hGcm9udCA/IFt2YWx1ZSwgZXhpc3RzXSA6IFtleGlzdHMsIHZhbHVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWFwW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiAhI2VuIENsYW1wIGEgdmFsdWUgYmV0d2VlbiBmcm9tIGFuZCB0by5cclxuICogISN6aFxyXG4gKiDpmZDlrprmta7ngrnmlbDnmoTmnIDlpKfmnIDlsI/lgLzjgII8YnIvPlxyXG4gKiDmlbDlgLzlpKfkuo4gbWF4X2luY2x1c2l2ZSDliJnov5Tlm54gbWF4X2luY2x1c2l2ZeOAgjxici8+XHJcbiAqIOaVsOWAvOWwj+S6jiBtaW5faW5jbHVzaXZlIOWImei/lOWbniBtaW5faW5jbHVzaXZl44CCPGJyLz5cclxuICog5ZCm5YiZ6L+U5Zue6Ieq6Lqr44CCXHJcbiAqIEBtZXRob2QgY2xhbXBmXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWluX2luY2x1c2l2ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4X2luY2x1c2l2ZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciB2MSA9IGNjLm1pc2MuY2xhbXBmKDIwLCAwLCAyMCk7IC8vIDIwO1xyXG4gKiB2YXIgdjIgPSBjYy5taXNjLmNsYW1wZigtMSwgMCwgMjApOyAvLyAgMDtcclxuICogdmFyIHYzID0gY2MubWlzYy5jbGFtcGYoMTAsIDAsIDIwKTsgLy8gMTA7XHJcbiAqL1xyXG5taXNjLmNsYW1wZiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluX2luY2x1c2l2ZSwgbWF4X2luY2x1c2l2ZSkge1xyXG4gICAgaWYgKG1pbl9pbmNsdXNpdmUgPiBtYXhfaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBtaW5faW5jbHVzaXZlO1xyXG4gICAgICAgIG1pbl9pbmNsdXNpdmUgPSBtYXhfaW5jbHVzaXZlO1xyXG4gICAgICAgIG1heF9pbmNsdXNpdmUgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlIDwgbWluX2luY2x1c2l2ZSA/IG1pbl9pbmNsdXNpdmUgOiB2YWx1ZSA8IG1heF9pbmNsdXNpdmUgPyB2YWx1ZSA6IG1heF9pbmNsdXNpdmU7XHJcbn07XHJcblxyXG4vKipcclxuICogISNlbiBDbGFtcCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cclxuICogISN6aCDpmZDlrprmta7ngrnmlbDnmoTlj5blgLzojIPlm7TkuLogMCB+IDEg5LmL6Ze044CCXHJcbiAqIEBtZXRob2QgY2xhbXAwMVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgdjEgPSBjYy5taXNjLmNsYW1wMDEoMjApOyAgLy8gMTtcclxuICogdmFyIHYyID0gY2MubWlzYy5jbGFtcDAxKC0xKTsgIC8vIDA7XHJcbiAqIHZhciB2MyA9IGNjLm1pc2MuY2xhbXAwMSgwLjUpOyAvLyAwLjU7XHJcbiAqL1xyXG5taXNjLmNsYW1wMDEgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA8IDAgPyAwIDogdmFsdWUgPCAxID8gdmFsdWUgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gMiBudW1iZXJzLCB0aGUgcmF0aW8gc2V0cyBob3cgbXVjaCBpdCBpcyBiaWFzZWQgdG8gZWFjaCBlbmRcclxuICogQG1ldGhvZCBsZXJwXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIG51bWJlciBBXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIG51bWJlciBCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByIHJhdGlvIGJldHdlZW4gMCBhbmQgMVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqIEBleGFtcGxlIHtAbGluayBjb2NvczJkL2NvcmUvcGxhdGZvcm0vQ0NNYWNyby9sZXJwLmpzfVxyXG4gKi9cclxubWlzYy5sZXJwID0gZnVuY3Rpb24gKGEsIGIsIHIpIHtcclxuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHI7XHJcbn07XHJcblxyXG4vKipcclxuICogY29udmVydHMgZGVncmVlcyB0byByYWRpYW5zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqIEBtZXRob2QgZGVncmVlc1RvUmFkaWFuc1xyXG4gKi9cclxubWlzYy5kZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICByZXR1cm4gYW5nbGUgKiBjYy5tYWNyby5SQUQ7XHJcbn07XHJcblxyXG4vKipcclxuICogY29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqIEBtZXRob2QgcmFkaWFuc1RvRGVncmVlc1xyXG4gKi9cclxubWlzYy5yYWRpYW5zVG9EZWdyZWVzID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICByZXR1cm4gYW5nbGUgKiBjYy5tYWNyby5ERUc7XHJcbn07XHJcblxyXG5jYy5taXNjID0gbW9kdWxlLmV4cG9ydHMgPSBtaXNjOyJdLCJzb3VyY2VSb290IjoiLyJ9