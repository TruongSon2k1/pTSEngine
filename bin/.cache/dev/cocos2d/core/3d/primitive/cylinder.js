
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/3d/primitive/cylinder.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}'use strict';

exports.__esModule = true;
exports["default"] = _default;

var _vec = _interopRequireDefault(require("../../value-types/vec3"));

var _vertexData = _interopRequireDefault(require("./vertex-data"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var temp1 = new _vec["default"]();
var temp2 = new _vec["default"]();
/**
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Object} opts
 * @param {Number} opts.radialSegments
 * @param {Number} opts.heightSegments
 * @param {Boolean} opts.capped
 * @param {Number} opts.arc
 */

function _default(radiusTop, radiusBottom, height, opts) {
  if (radiusTop === void 0) {
    radiusTop = 0.5;
  }

  if (radiusBottom === void 0) {
    radiusBottom = 0.5;
  }

  if (height === void 0) {
    height = 2;
  }

  if (opts === void 0) {
    opts = {
      radialSegments: 32,
      heightSegments: 1,
      capped: true,
      arc: 2.0 * Math.PI
    };
  }

  var halfHeight = height * 0.5;
  var radialSegments = opts.radialSegments;
  var heightSegments = opts.heightSegments;
  var capped = opts.capped;
  var arc = opts.arc;
  var cntCap = 0;

  if (!capped) {
    if (radiusTop > 0) {
      cntCap++;
    }

    if (radiusBottom > 0) {
      cntCap++;
    }
  } // calculate vertex count


  var vertCount = (radialSegments + 1) * (heightSegments + 1);

  if (capped) {
    vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
  } // calculate index count


  var indexCount = radialSegments * heightSegments * 2 * 3;

  if (capped) {
    indexCount += radialSegments * cntCap * 3;
  }

  var indices = new Array(indexCount);
  var positions = new Array(vertCount * 3);
  var normals = new Array(vertCount * 3);
  var uvs = new Array(vertCount * 2);
  var maxRadius = Math.max(radiusTop, radiusBottom);
  var minPos = new _vec["default"](-maxRadius, -halfHeight, -maxRadius);
  var maxPos = new _vec["default"](maxRadius, halfHeight, maxRadius);
  var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
  var index = 0;
  var indexOffset = 0;
  generateTorso();

  if (capped) {
    if (radiusBottom > 0) {
      generateCap(false);
    }

    if (radiusTop > 0) {
      generateCap(true);
    }
  }

  return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius); // =======================
  // internal fucntions
  // =======================

  function generateTorso() {
    var indexArray = []; // this will be used to calculate the normal

    var r = radiusTop - radiusBottom;
    var slope = r * r / height * Math.sign(r); // generate positions, normals and uvs

    for (var y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments; // calculate the radius of the current row

      var radius = v * r + radiusBottom;

      for (var x = 0; x <= radialSegments; ++x) {
        var u = x / radialSegments;
        var theta = u * arc;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        positions[3 * index] = radius * sinTheta;
        positions[3 * index + 1] = v * height - halfHeight;
        positions[3 * index + 2] = radius * cosTheta; // normal

        _vec["default"].normalize(temp1, _vec["default"].set(temp2, sinTheta, -slope, cosTheta));

        normals[3 * index] = temp1.x;
        normals[3 * index + 1] = temp1.y;
        normals[3 * index + 2] = temp1.z; // uv

        uvs[2 * index] = (1 - u) * 2 % 1;
        uvs[2 * index + 1] = v; // save index of vertex in respective row

        indexRow.push(index); // increase index

        ++index;
      } // now save positions of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (var _y = 0; _y < heightSegments; ++_y) {
      for (var _x = 0; _x < radialSegments; ++_x) {
        // we use the index array to access the correct indices
        var i1 = indexArray[_y][_x];
        var i2 = indexArray[_y + 1][_x];
        var i3 = indexArray[_y + 1][_x + 1];
        var i4 = indexArray[_y][_x + 1]; // face one

        indices[indexOffset] = i1;
        ++indexOffset;
        indices[indexOffset] = i4;
        ++indexOffset;
        indices[indexOffset] = i2;
        ++indexOffset; // face two

        indices[indexOffset] = i4;
        ++indexOffset;
        indices[indexOffset] = i3;
        ++indexOffset;
        indices[indexOffset] = i2;
        ++indexOffset;
      }
    }
  }

  function generateCap(top) {
    var centerIndexStart, centerIndexEnd;
    var radius = top ? radiusTop : radiusBottom;
    var sign = top ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (var x = 1; x <= radialSegments; ++x) {
      // vertex
      positions[3 * index] = 0;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = 0; // normal

      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0; // uv

      uvs[2 * index] = 0.5;
      uvs[2 * index + 1] = 0.5; // increase index

      ++index;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding positions, normals and uvs

    for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
      var u = _x2 / radialSegments;
      var theta = u * arc;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta); // vertex

      positions[3 * index] = radius * sinTheta;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = radius * cosTheta; // normal

      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0; // uv

      uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
      uvs[2 * index + 1] = 0.5 + cosTheta * 0.5; // increase index

      ++index;
    } // generate indices


    for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
      var c = centerIndexStart + _x3;
      var i = centerIndexEnd + _x3;

      if (top) {
        // face top
        indices[indexOffset] = i + 1;
        ++indexOffset;
        indices[indexOffset] = c;
        ++indexOffset;
        indices[indexOffset] = i;
        ++indexOffset;
      } else {
        // face bottom
        indices[indexOffset] = c;
        ++indexOffset;
        indices[indexOffset] = i + 1;
        ++indexOffset;
        indices[indexOffset] = i;
        ++indexOffset;
      }
    }
  }
}

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXDNkXFxwcmltaXRpdmVcXGN5bGluZGVyLnRzIl0sIm5hbWVzIjpbInRlbXAxIiwiVmVjMyIsInRlbXAyIiwicmFkaXVzVG9wIiwicmFkaXVzQm90dG9tIiwiaGVpZ2h0Iiwib3B0cyIsInJhZGlhbFNlZ21lbnRzIiwiaGVpZ2h0U2VnbWVudHMiLCJjYXBwZWQiLCJhcmMiLCJNYXRoIiwiUEkiLCJoYWxmSGVpZ2h0IiwiY250Q2FwIiwidmVydENvdW50IiwiaW5kZXhDb3VudCIsImluZGljZXMiLCJBcnJheSIsInBvc2l0aW9ucyIsIm5vcm1hbHMiLCJ1dnMiLCJtYXhSYWRpdXMiLCJtYXgiLCJtaW5Qb3MiLCJtYXhQb3MiLCJib3VuZGluZ1JhZGl1cyIsInNxcnQiLCJpbmRleCIsImluZGV4T2Zmc2V0IiwiZ2VuZXJhdGVUb3JzbyIsImdlbmVyYXRlQ2FwIiwiVmVydGV4RGF0YSIsImluZGV4QXJyYXkiLCJyIiwic2xvcGUiLCJzaWduIiwieSIsImluZGV4Um93IiwidiIsInJhZGl1cyIsIngiLCJ1IiwidGhldGEiLCJzaW5UaGV0YSIsInNpbiIsImNvc1RoZXRhIiwiY29zIiwibm9ybWFsaXplIiwic2V0IiwieiIsInB1c2giLCJpMSIsImkyIiwiaTMiLCJpNCIsInRvcCIsImNlbnRlckluZGV4U3RhcnQiLCJjZW50ZXJJbmRleEVuZCIsImMiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztBQUVBOztBQUNBOzs7O0FBRUEsSUFBSUEsS0FBSyxHQUFHLElBQUlDLGVBQUosRUFBWjtBQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJRCxlQUFKLEVBQVo7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDZSxrQkFBVUUsU0FBVixFQUEyQkMsWUFBM0IsRUFBK0NDLE1BQS9DLEVBQTJEQyxJQUEzRCxFQUE2STtBQUFBLE1BQW5JSCxTQUFtSTtBQUFu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O0FBRUEsU0FBSyxJQUFJYSxHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHbEMsY0FBcEIsRUFBb0MsRUFBRWtDLEdBQXRDLEVBQXlDO0FBQ3ZDLFVBQUlrQixDQUFDLEdBQUdGLGdCQUFnQixHQUFHaEIsR0FBM0I7QUFDQSxVQUFJbUIsQ0FBQyxHQUFHRixjQUFjLEdBQUdqQixHQUF6Qjs7QUFFQSxVQUFJZSxHQUFKLEVBQVM7QUFDUDtBQUNBdkMsUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUIrQixDQUFDLEdBQUcsQ0FBM0I7QUFBOEIsVUFBRS9CLFdBQUY7QUFDOUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCOEIsQ0FBdkI7QUFBMEIsVUFBRTlCLFdBQUY7QUFDMUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCK0IsQ0FBdkI7QUFBMEIsVUFBRS9CLFdBQUY7QUFDM0IsT0FMRCxNQUtPO0FBQ0w7QUFDQVosUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUI4QixDQUF2QjtBQUEwQixVQUFFOUIsV0FBRjtBQUMxQlosUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUIrQixDQUFDLEdBQUcsQ0FBM0I7QUFBOEIsVUFBRS9CLFdBQUY7QUFDOUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCK0IsQ0FBdkI7QUFBMEIsVUFBRS9CLFdBQUY7QUFDM0I7QUFDRjtBQUNGO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgVmVjMyBmcm9tICcuLi8uLi92YWx1ZS10eXBlcy92ZWMzJztcclxuaW1wb3J0IFZlcnRleERhdGEgZnJvbSAnLi92ZXJ0ZXgtZGF0YSc7XHJcblxyXG5sZXQgdGVtcDEgPSBuZXcgVmVjMygpO1xyXG5sZXQgdGVtcDIgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JvdHRvbVxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLnJhZGlhbFNlZ21lbnRzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLmhlaWdodFNlZ21lbnRzXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0cy5jYXBwZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMuYXJjXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocmFkaXVzVG9wID0gMC41LCByYWRpdXNCb3R0b20gPSAwLjUsIGhlaWdodCA9IDIsIG9wdHMgPSB7cmFkaWFsU2VnbWVudHM6IDMyLCBoZWlnaHRTZWdtZW50czogMSwgY2FwcGVkOiB0cnVlLCBhcmM6IDIuMCAqIE1hdGguUEl9KSB7XHJcbiAgbGV0IGhhbGZIZWlnaHQgPSBoZWlnaHQgKiAwLjU7XHJcbiAgbGV0IHJhZGlhbFNlZ21lbnRzID0gb3B0cy5yYWRpYWxTZWdtZW50cztcclxuICBsZXQgaGVpZ2h0U2VnbWVudHMgPSBvcHRzLmhlaWdodFNlZ21lbnRzO1xyXG4gIGxldCBjYXBwZWQgPSBvcHRzLmNhcHBlZDtcclxuICBsZXQgYXJjID0gb3B0cy5hcmM7XHJcblxyXG4gIGxldCBjbnRDYXAgPSAwO1xyXG4gIGlmICghY2FwcGVkKSB7XHJcbiAgICBpZiAocmFkaXVzVG9wID4gMCkge1xyXG4gICAgICBjbnRDYXArKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmFkaXVzQm90dG9tID4gMCkge1xyXG4gICAgICBjbnRDYXArKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGNhbGN1bGF0ZSB2ZXJ0ZXggY291bnRcclxuICBsZXQgdmVydENvdW50ID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiAoaGVpZ2h0U2VnbWVudHMgKyAxKTtcclxuICBpZiAoY2FwcGVkKSB7XHJcbiAgICB2ZXJ0Q291bnQgKz0gKChyYWRpYWxTZWdtZW50cyArIDEpICogY250Q2FwKSArIChyYWRpYWxTZWdtZW50cyAqIGNudENhcCk7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxjdWxhdGUgaW5kZXggY291bnRcclxuICBsZXQgaW5kZXhDb3VudCA9IHJhZGlhbFNlZ21lbnRzICogaGVpZ2h0U2VnbWVudHMgKiAyICogMztcclxuICBpZiAoY2FwcGVkKSB7XHJcbiAgICBpbmRleENvdW50ICs9IHJhZGlhbFNlZ21lbnRzICogY250Q2FwICogMztcclxuICB9XHJcblxyXG4gIGxldCBpbmRpY2VzID0gbmV3IEFycmF5KGluZGV4Q291bnQpO1xyXG4gIGxldCBwb3NpdGlvbnMgPSBuZXcgQXJyYXkodmVydENvdW50ICogMyk7XHJcbiAgbGV0IG5vcm1hbHMgPSBuZXcgQXJyYXkodmVydENvdW50ICogMyk7XHJcbiAgbGV0IHV2cyA9IG5ldyBBcnJheSh2ZXJ0Q291bnQgKiAyKTtcclxuICBsZXQgbWF4UmFkaXVzID0gTWF0aC5tYXgocmFkaXVzVG9wLCByYWRpdXNCb3R0b20pO1xyXG4gIGxldCBtaW5Qb3MgPSBuZXcgVmVjMygtbWF4UmFkaXVzLCAtaGFsZkhlaWdodCwgLW1heFJhZGl1cyk7XHJcbiAgbGV0IG1heFBvcyA9IG5ldyBWZWMzKG1heFJhZGl1cywgaGFsZkhlaWdodCwgbWF4UmFkaXVzKTtcclxuICBsZXQgYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzICogbWF4UmFkaXVzICsgaGFsZkhlaWdodCAqIGhhbGZIZWlnaHQpO1xyXG5cclxuICBsZXQgaW5kZXggPSAwO1xyXG4gIGxldCBpbmRleE9mZnNldCA9IDA7XHJcblxyXG4gIGdlbmVyYXRlVG9yc28oKTtcclxuXHJcbiAgaWYgKGNhcHBlZCkge1xyXG4gICAgaWYgKHJhZGl1c0JvdHRvbSA+IDApIHtcclxuICAgICAgZ2VuZXJhdGVDYXAoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyYWRpdXNUb3AgPiAwKSB7XHJcbiAgICAgIGdlbmVyYXRlQ2FwKHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBWZXJ0ZXhEYXRhKFxyXG4gICAgcG9zaXRpb25zLFxyXG4gICAgbm9ybWFscyxcclxuICAgIHV2cyxcclxuICAgIGluZGljZXMsXHJcbiAgICBtaW5Qb3MsXHJcbiAgICBtYXhQb3MsXHJcbiAgICBib3VuZGluZ1JhZGl1c1xyXG4gICk7XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gaW50ZXJuYWwgZnVjbnRpb25zXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUb3JzbygpIHtcclxuICAgIGxldCBpbmRleEFycmF5OiBudW1iZXJbXVtdID0gW107XHJcblxyXG4gICAgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWxcclxuICAgIGxldCByID0gcmFkaXVzVG9wIC0gcmFkaXVzQm90dG9tO1xyXG4gICAgbGV0IHNsb3BlID0gciAqIHIgLyBoZWlnaHQgKiBNYXRoLnNpZ24ocik7XHJcblxyXG4gICAgLy8gZ2VuZXJhdGUgcG9zaXRpb25zLCBub3JtYWxzIGFuZCB1dnNcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5KyspIHtcclxuICAgICAgbGV0IGluZGV4Um93OiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBsZXQgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzIG9mIHRoZSBjdXJyZW50IHJvd1xyXG4gICAgICBsZXQgcmFkaXVzID0gdiAqIHIgKyByYWRpdXNCb3R0b207XHJcblxyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgICAgbGV0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XHJcbiAgICAgICAgbGV0IHRoZXRhID0gdSAqIGFyYztcclxuXHJcbiAgICAgICAgbGV0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xyXG4gICAgICAgIGxldCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcclxuXHJcbiAgICAgICAgLy8gdmVydGV4XHJcbiAgICAgICAgcG9zaXRpb25zWzMgKiBpbmRleF0gPSByYWRpdXMgKiBzaW5UaGV0YTtcclxuICAgICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMV0gPSB2ICogaGVpZ2h0IC0gaGFsZkhlaWdodDtcclxuICAgICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMl0gPSByYWRpdXMgKiBjb3NUaGV0YTtcclxuXHJcbiAgICAgICAgLy8gbm9ybWFsXHJcbiAgICAgICAgVmVjMy5ub3JtYWxpemUodGVtcDEsIFZlYzMuc2V0KHRlbXAyLCBzaW5UaGV0YSwgLXNsb3BlLCBjb3NUaGV0YSkpO1xyXG4gICAgICAgIG5vcm1hbHNbMyAqIGluZGV4XSA9IHRlbXAxLng7XHJcbiAgICAgICAgbm9ybWFsc1szICogaW5kZXggKyAxXSA9IHRlbXAxLnk7XHJcbiAgICAgICAgbm9ybWFsc1szICogaW5kZXggKyAyXSA9IHRlbXAxLno7XHJcblxyXG4gICAgICAgIC8vIHV2XHJcbiAgICAgICAgdXZzWzIgKiBpbmRleF0gPSAoMSAtIHUpICogMiAlIDE7XHJcbiAgICAgICAgdXZzWzIgKiBpbmRleCArIDFdID0gdjtcclxuXHJcbiAgICAgICAgLy8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcclxuICAgICAgICBpbmRleFJvdy5wdXNoKGluZGV4KTtcclxuXHJcbiAgICAgICAgLy8gaW5jcmVhc2UgaW5kZXhcclxuICAgICAgICArK2luZGV4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBub3cgc2F2ZSBwb3NpdGlvbnMgb2YgdGhlIHJvdyBpbiBvdXIgaW5kZXggYXJyYXlcclxuICAgICAgaW5kZXhBcnJheS5wdXNoKGluZGV4Um93KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBpbmRpY2VzXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyArK3kpIHtcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgICAgLy8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xyXG4gICAgICAgIGxldCBpMSA9IGluZGV4QXJyYXlbeV1beF07XHJcbiAgICAgICAgbGV0IGkyID0gaW5kZXhBcnJheVt5ICsgMV1beF07XHJcbiAgICAgICAgbGV0IGkzID0gaW5kZXhBcnJheVt5ICsgMV1beCArIDFdO1xyXG4gICAgICAgIGxldCBpNCA9IGluZGV4QXJyYXlbeV1beCArIDFdO1xyXG5cclxuICAgICAgICAvLyBmYWNlIG9uZVxyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTE7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpNDsgKytpbmRleE9mZnNldDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGkyOyArK2luZGV4T2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBmYWNlIHR3b1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTQ7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpMzsgKytpbmRleE9mZnNldDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGkyOyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZW5lcmF0ZUNhcCh0b3ApIHtcclxuICAgIGxldCBjZW50ZXJJbmRleFN0YXJ0LCBjZW50ZXJJbmRleEVuZDtcclxuXHJcbiAgICBsZXQgcmFkaXVzID0gdG9wID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xyXG4gICAgbGV0IHNpZ24gPSB0b3AgPyAxIDogLSAxO1xyXG5cclxuICAgIC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XHJcbiAgICBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XHJcblxyXG4gICAgLy8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxyXG4gICAgLy8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXHJcbiAgICAvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XHJcblxyXG4gICAgZm9yIChsZXQgeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7ICsreCkge1xyXG4gICAgICAvLyB2ZXJ0ZXhcclxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleF0gPSAwO1xyXG4gICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMV0gPSBoYWxmSGVpZ2h0ICogc2lnbjtcclxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleCArIDJdID0gMDtcclxuXHJcbiAgICAgIC8vIG5vcm1hbFxyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleF0gPSAwO1xyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleCArIDFdID0gc2lnbjtcclxuICAgICAgbm9ybWFsc1szICogaW5kZXggKyAyXSA9IDA7XHJcblxyXG4gICAgICAvLyB1dlxyXG4gICAgICB1dnNbMiAqIGluZGV4XSA9IDAuNTtcclxuICAgICAgdXZzWzIgKiBpbmRleCArIDFdID0gMC41O1xyXG5cclxuICAgICAgLy8gaW5jcmVhc2UgaW5kZXhcclxuICAgICAgKytpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XHJcbiAgICBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xyXG5cclxuICAgIC8vIG5vdyB3ZSBnZW5lcmF0ZSB0aGUgc3Vycm91bmRpbmcgcG9zaXRpb25zLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgIGxldCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xyXG4gICAgICBsZXQgdGhldGEgPSB1ICogYXJjO1xyXG5cclxuICAgICAgbGV0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xyXG4gICAgICBsZXQgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XHJcblxyXG4gICAgICAvLyB2ZXJ0ZXhcclxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleF0gPSByYWRpdXMgKiBzaW5UaGV0YTtcclxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleCArIDFdID0gaGFsZkhlaWdodCAqIHNpZ247XHJcbiAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAyXSA9IHJhZGl1cyAqIGNvc1RoZXRhO1xyXG5cclxuICAgICAgLy8gbm9ybWFsXHJcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4XSA9IDA7XHJcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4ICsgMV0gPSBzaWduO1xyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleCArIDJdID0gMDtcclxuXHJcbiAgICAgIC8vIHV2XHJcbiAgICAgIHV2c1syICogaW5kZXhdID0gMC41IC0gKHNpblRoZXRhICogMC41ICogc2lnbik7XHJcbiAgICAgIHV2c1syICogaW5kZXggKyAxXSA9IDAuNSArIChjb3NUaGV0YSAqIDAuNSk7XHJcblxyXG4gICAgICAvLyBpbmNyZWFzZSBpbmRleFxyXG4gICAgICArK2luZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdlbmVyYXRlIGluZGljZXNcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyArK3gpIHtcclxuICAgICAgbGV0IGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcclxuICAgICAgbGV0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XHJcblxyXG4gICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgLy8gZmFjZSB0b3BcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGkgKyAxOyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gYzsgKytpbmRleE9mZnNldDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGk7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZmFjZSBib3R0b21cclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGM7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpICsgMTsgKytpbmRleE9mZnNldDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGk7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIvIn0=