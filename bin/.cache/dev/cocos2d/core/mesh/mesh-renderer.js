
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/mesh/mesh-renderer.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler = _interopRequireDefault(require("../renderer/assembler"));

var _gfx = _interopRequireDefault(require("../../renderer/gfx"));

var _vec = _interopRequireDefault(require("../value-types/vec3"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MeshRenderer = require('./CCMeshRenderer');

var _tmp_vec3 = new _vec["default"]();

var MeshRendererAssembler = /*#__PURE__*/function (_Assembler) {
  _inheritsLoose(MeshRendererAssembler, _Assembler);

  function MeshRendererAssembler() {
    return _Assembler.apply(this, arguments) || this;
  }

  var _proto = MeshRendererAssembler.prototype;

  _proto.init = function init(renderComp) {
    _Assembler.prototype.init.call(this, renderComp);

    this._worldDatas = {};
    this._renderNode = null;
  };

  _proto.setRenderNode = function setRenderNode(node) {
    this._renderNode = node;
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    if (!comp.mesh) return;

    comp.mesh._uploadData(); // update culling mask


    var isCullingMaskSame = renderer.cullingMask === comp.node._cullingMask;
    var enableAutoBatch = comp.enableAutoBatch;
    var materials = comp._materials;
    var submeshes = comp.mesh._subMeshes;
    var subDatas = comp.mesh.subDatas;

    for (var i = 0; i < submeshes.length; i++) {
      var ia = submeshes[i];
      var meshData = subDatas[i];
      var material = materials[i] || materials[0];

      if (!enableAutoBatch || !meshData.canBatch || ia._primitiveType !== _gfx["default"].PT_TRIANGLES) {
        renderer._flush();

        renderer.material = material;
        renderer.cullingMask = comp.node._cullingMask;
        renderer.node = this._renderNode;

        renderer._flushIA(ia);

        continue;
      }

      if (!isCullingMaskSame || material.getHash() !== renderer.material.getHash()) {
        renderer._flush();
      }

      renderer.material = material;
      renderer.cullingMask = comp.node._cullingMask;
      renderer.node = renderer._dummyNode;

      this._fillBuffer(comp, meshData, renderer, i);
    }

    if (CC_DEBUG && (cc.macro.SHOW_MESH_WIREFRAME || cc.macro.SHOW_MESH_NORMAL) && !(comp.node._cullingMask & 1 << cc.Node.BuiltinGroupIndex.DEBUG)) {
      renderer._flush();

      renderer.node = this._renderNode;

      comp._updateDebugDatas();

      if (cc.macro.SHOW_MESH_WIREFRAME) {
        this._drawDebugDatas(comp, renderer, 'wireFrame');
      }

      if (cc.macro.SHOW_MESH_NORMAL) {
        this._drawDebugDatas(comp, renderer, 'normal');
      }
    }
  };

  _proto._fillBuffer = function _fillBuffer(comp, meshData, renderer, dataIndex) {
    var vData = meshData.getVData(Float32Array);
    var vtxFormat = meshData.vfm;
    var vertexCount = vData.byteLength / vtxFormat._bytes | 0;
    var indices = meshData.getIData(Uint16Array);
    var indicesCount = indices.length;
    var buffer = renderer.getBuffer('mesh', vtxFormat);
    var offsetInfo = buffer.request(vertexCount, indicesCount); // buffer data may be realloc, need get reference after request.

    var indiceOffset = offsetInfo.indiceOffset,
        vertexOffset = offsetInfo.byteOffset >> 2,
        vertexId = offsetInfo.vertexOffset,
        vbuf = buffer._vData,
        ibuf = buffer._iData;

    if (renderer.worldMatDirty || !this._worldDatas[dataIndex]) {
      this._updateWorldVertices(dataIndex, vertexCount, vData, vtxFormat, comp.node._worldMatrix);
    }

    vbuf.set(this._worldDatas[dataIndex], vertexOffset);

    for (var i = 0; i < indicesCount; i++) {
      ibuf[indiceOffset + i] = vertexId + indices[i];
    }
  };

  _proto._updateWorldVertices = function _updateWorldVertices(dataIndex, vertexCount, local, vtxFormat, wolrdMatrix) {
    var world = this._worldDatas[dataIndex];

    if (!world) {
      world = this._worldDatas[dataIndex] = new Float32Array(local.length);
      world.set(local);
    }

    var floatCount = vtxFormat._bytes / 4;
    var elements = vtxFormat._elements;

    for (var i = 0, n = elements.length; i < n; i++) {
      var element = elements[i];
      var attrOffset = element.offset / 4;

      if (element.name === _gfx["default"].ATTR_POSITION || element.name === _gfx["default"].ATTR_NORMAL) {
        var transformMat4 = element.name === _gfx["default"].ATTR_NORMAL ? _vec["default"].transformMat4Normal : _vec["default"].transformMat4;

        for (var j = 0; j < vertexCount; j++) {
          var offset = j * floatCount + attrOffset;
          _tmp_vec3.x = local[offset];
          _tmp_vec3.y = local[offset + 1];
          _tmp_vec3.z = local[offset + 2];
          transformMat4(_tmp_vec3, _tmp_vec3, wolrdMatrix);
          world[offset] = _tmp_vec3.x;
          world[offset + 1] = _tmp_vec3.y;
          world[offset + 2] = _tmp_vec3.z;
        }
      }
    }
  };

  _proto._drawDebugDatas = function _drawDebugDatas(comp, renderer, name) {
    var debugDatas = comp._debugDatas[name];
    if (!debugDatas) return;

    for (var i = 0; i < debugDatas.length; i++) {
      var debugData = debugDatas[i];
      if (!debugData) continue;
      var material = debugData.material;
      renderer.material = material;

      renderer._flushIA(debugData.ia);
    }
  };

  return MeshRendererAssembler;
}(_assembler["default"]);

exports["default"] = MeshRendererAssembler;

_assembler["default"].register(MeshRenderer, MeshRendererAssembler);

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXG1lc2hcXG1lc2gtcmVuZGVyZXIuanMiXSwibmFtZXMiOlsiTWVzaFJlbmRlcmVyIiwicmVxdWlyZSIsIl90bXBfdmVjMyIsIlZlYzMiLCJNZXNoUmVuZGVyZXJBc3NlbWJsZXIiLCJpbml0IiwicmVuZGVyQ29tcCIsIl93b3JsZERhdGFzIiwiX3JlbmRlck5vZGUiLCJzZXRSZW5kZXJOb2RlIiwibm9kZSIsImZpbGxCdWZmZXJzIiwiY29tcCIsInJlbmRlcmVyIiwibWVzaCIsIl91cGxvYWREYXRhIiwiaXNDdWxsaW5nTWFza1NhbWUiLCJjdWxsaW5nTWFzayIsIl9jdWxsaW5nTWFzayIsImVuYWJsZUF1dG9CYXRjaCIsIm1hdGVyaWFscyIsIl9tYXRlcmlhbHMiLCJzdWJtZXNoZXMiLCJfc3ViTWVzaGVzIiwic3ViRGF0YXMiLCJpIiwibGVuZ3RoIiwiaWEiLCJtZXNoRGF0YSIsIm1hdGVyaWFsIiwiY2FuQmF0Y2giLCJfcHJpbWl0aXZlVHlwZSIsImdmeCIsIlBUX1RSSUFOR0xFUyIsIl9mbHVzaCIsIl9mbHVzaElBIiwiZ2V0SGFzaCIsIl9kdW1teU5vZGUiLCJfZmlsbEJ1ZmZlciIsIkNDX0RFQlVHIiwiY2MiLCJtYWNybyIsIlNIT1dfTUVTSF9XSVJFRlJBTUUiLCJTSE9XX01FU0hfTk9STUFMIiwiTm9kZSIsIkJ1aWx0aW5Hcm91cEluZGV4IiwiREVCVUciLCJfdXBkYXRlRGVidWdEYXRhcyIsIl9kcmF3RGVidWdEYXRhcyIsImRhdGFJbmRleCIsInZEYXRhIiwiZ2V0VkRhdGEiLCJGbG9hdDMyQXJyYXkiLCJ2dHhGb3JtYXQiLCJ2Zm0iLCJ2ZXJ0ZXhDb3VudCIsImJ5dGVMZW5ndGgiLCJfYnl0ZXMiLCJpbmRpY2VzIiwiZ2V0SURhdGEiLCJVaW50MTZBcnJheSIsImluZGljZXNDb3VudCIsImJ1ZmZlciIsImdldEJ1ZmZlciIsIm9mZnNldEluZm8iLCJyZXF1ZXN0IiwiaW5kaWNlT2Zmc2V0IiwidmVydGV4T2Zmc2V0IiwiYnl0ZU9mZnNldCIsInZlcnRleElkIiwidmJ1ZiIsIl92RGF0YSIsImlidWYiLCJfaURhdGEiLCJ3b3JsZE1hdERpcnR5IiwiX3VwZGF0ZVdvcmxkVmVydGljZXMiLCJfd29ybGRNYXRyaXgiLCJzZXQiLCJsb2NhbCIsIndvbHJkTWF0cml4Iiwid29ybGQiLCJmbG9hdENvdW50IiwiZWxlbWVudHMiLCJfZWxlbWVudHMiLCJuIiwiZWxlbWVudCIsImF0dHJPZmZzZXQiLCJvZmZzZXQiLCJuYW1lIiwiQVRUUl9QT1NJVElPTiIsIkFUVFJfTk9STUFMIiwidHJhbnNmb3JtTWF0NCIsInRyYW5zZm9ybU1hdDROb3JtYWwiLCJqIiwieCIsInkiLCJ6IiwiZGVidWdEYXRhcyIsIl9kZWJ1Z0RhdGFzIiwiZGVidWdEYXRhIiwiQXNzZW1ibGVyIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsa0JBQUQsQ0FBNUI7O0FBRUEsSUFBSUMsU0FBUyxHQUFHLElBQUlDLGVBQUosRUFBaEI7O0lBRXFCQzs7Ozs7Ozs7O1NBQ2pCQyxPQUFBLGNBQU1DLFVBQU4sRUFBa0I7QUFDZCx5QkFBTUQsSUFBTixZQUFXQyxVQUFYOztBQUVBLFNBQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0g7O1NBRURDLGdCQUFBLHVCQUFlQyxJQUFmLEVBQXFCO0FBQ2pCLFNBQUtGLFdBQUwsR0FBbUJFLElBQW5CO0FBQ0g7O1NBRURDLGNBQUEscUJBQWFDLElBQWIsRUFBbUJDLFFBQW5CLEVBQTZCO0FBQ3pCLFFBQUksQ0FBQ0QsSUFBSSxDQUFDRSxJQUFWLEVBQWdCOztBQUVoQkYsSUFBQUEsSUFBSSxDQUFDRSxJQUFMLENBQVVDLFdBQVYsR0FIeUIsQ0FLekI7OztBQUNBLFFBQUlDLGlCQUFpQixHQUFHSCxRQUFRLENBQUNJLFdBQVQs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VUFBVSxDQUFDdkUsTUFBL0IsRUFBdUNELENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsVUFBSTBFLFNBQVMsR0FBR0YsVUFBVSxDQUFDeEUsQ0FBRCxDQUExQjtBQUNBLFVBQUksQ0FBQzBFLFNBQUwsRUFBZ0I7QUFDaEIsVUFBSXRFLFFBQVEsR0FBR3NFLFNBQVMsQ0FBQ3RFLFFBQXpCO0FBQ0FoQixNQUFBQSxRQUFRLENBQUNnQixRQUFULEdBQW9CQSxRQUFwQjs7QUFDQWhCLE1BQUFBLFFBQVEsQ0FBQ3NCLFFBQVQsQ0FBa0JnRSxTQUFTLENBQUN4RSxFQUE1QjtBQUNIO0FBQ0o7OztFQWhKOEN5RTs7OztBQW1KbkRBLHNCQUFVQyxRQUFWLENBQW1CckcsWUFBbkIsRUFBaUNJLHFCQUFqQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zLmNvbVxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmltcG9ydCBBc3NlbWJsZXIgZnJvbSAnLi4vcmVuZGVyZXIvYXNzZW1ibGVyJztcclxuaW1wb3J0IGdmeCBmcm9tICcuLi8uLi9yZW5kZXJlci9nZngnO1xyXG5pbXBvcnQgVmVjMyBmcm9tICcuLi92YWx1ZS10eXBlcy92ZWMzJztcclxuXHJcbmNvbnN0IE1lc2hSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ0NNZXNoUmVuZGVyZXInKTtcclxuXHJcbmxldCBfdG1wX3ZlYzMgPSBuZXcgVmVjMygpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzaFJlbmRlcmVyQXNzZW1ibGVyIGV4dGVuZHMgQXNzZW1ibGVyIHtcclxuICAgIGluaXQgKHJlbmRlckNvbXApIHtcclxuICAgICAgICBzdXBlci5pbml0KHJlbmRlckNvbXApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3dvcmxkRGF0YXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJOb2RlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRSZW5kZXJOb2RlIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTm9kZSA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgZmlsbEJ1ZmZlcnMgKGNvbXAsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKCFjb21wLm1lc2gpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29tcC5tZXNoLl91cGxvYWREYXRhKCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBjdWxsaW5nIG1hc2tcclxuICAgICAgICBsZXQgaXNDdWxsaW5nTWFza1NhbWUgPSByZW5kZXJlci5jdWxsaW5nTWFzayA9PT0gY29tcC5ub2RlLl9jdWxsaW5nTWFzaztcclxuXHJcbiAgICAgICAgbGV0IGVuYWJsZUF1dG9CYXRjaCA9IGNvbXAuZW5hYmxlQXV0b0JhdGNoO1xyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWxzID0gY29tcC5fbWF0ZXJpYWxzO1xyXG4gICAgICAgIGxldCBzdWJtZXNoZXMgPSBjb21wLm1lc2guX3N1Yk1lc2hlcztcclxuICAgICAgICBsZXQgc3ViRGF0YXMgPSBjb21wLm1lc2guc3ViRGF0YXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJtZXNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGlhID0gc3VibWVzaGVzW2ldO1xyXG4gICAgICAgICAgICBsZXQgbWVzaERhdGEgPSBzdWJEYXRhc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtYXRlcmlhbCA9IG1hdGVyaWFsc1tpXSB8fCBtYXRlcmlhbHNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVuYWJsZUF1dG9CYXRjaCB8fCAhbWVzaERhdGEuY2FuQmF0Y2ggfHwgaWEuX3ByaW1pdGl2ZVR5cGUgIT09IGdmeC5QVF9UUklBTkdMRVMpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9mbHVzaCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jdWxsaW5nTWFzayA9IGNvbXAubm9kZS5fY3VsbGluZ01hc2s7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5ub2RlID0gdGhpcy5fcmVuZGVyTm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5fZmx1c2hJQShpYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaXNDdWxsaW5nTWFza1NhbWUgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmdldEhhc2goKSAhPT0gcmVuZGVyZXIubWF0ZXJpYWwuZ2V0SGFzaCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5fZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICAgICAgcmVuZGVyZXIuY3VsbGluZ01hc2sgPSBjb21wLm5vZGUuX2N1bGxpbmdNYXNrO1xyXG4gICAgICAgICAgICByZW5kZXJlci5ub2RlID0gcmVuZGVyZXIuX2R1bW15Tm9kZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxCdWZmZXIoY29tcCwgbWVzaERhdGEsIHJlbmRlcmVyLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChDQ19ERUJVRyAmJlxyXG4gICAgICAgICAgICAoY2MubWFjcm8uU0hPV19NRVNIX1dJUkVGUkFNRSB8fCBjYy5tYWNyby5TSE9XX01FU0hfTk9STUFMKSAmJiBcclxuICAgICAgICAgICAgIShjb21wLm5vZGUuX2N1bGxpbmdNYXNrICYgKDE8PGNjLk5vZGUuQnVpbHRpbkdyb3VwSW5kZXguREVCVUcpKSkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5fZmx1c2goKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIubm9kZSA9IHRoaXMuX3JlbmRlck5vZGU7XHJcbiAgICAgICAgICAgIGNvbXAuX3VwZGF0ZURlYnVnRGF0YXMoKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNjLm1hY3JvLlNIT1dfTUVTSF9XSVJFRlJBTUUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEZWJ1Z0RhdGFzKGNvbXAsIHJlbmRlcmVyLCAnd2lyZUZyYW1lJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNjLm1hY3JvLlNIT1dfTUVTSF9OT1JNQUwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEZWJ1Z0RhdGFzKGNvbXAsIHJlbmRlcmVyLCAnbm9ybWFsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2ZpbGxCdWZmZXIgKGNvbXAsIG1lc2hEYXRhLCByZW5kZXJlciwgZGF0YUluZGV4KSB7XHJcbiAgICAgICAgbGV0IHZEYXRhID0gbWVzaERhdGEuZ2V0VkRhdGEoRmxvYXQzMkFycmF5KTtcclxuXHJcbiAgICAgICAgbGV0IHZ0eEZvcm1hdCA9IG1lc2hEYXRhLnZmbTtcclxuICAgICAgICBsZXQgdmVydGV4Q291bnQgPSAodkRhdGEuYnl0ZUxlbmd0aCAvIHZ0eEZvcm1hdC5fYnl0ZXMpIHwgMDtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgaW5kaWNlcyA9IG1lc2hEYXRhLmdldElEYXRhKFVpbnQxNkFycmF5KTtcclxuICAgICAgICBsZXQgaW5kaWNlc0NvdW50ID0gaW5kaWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCBidWZmZXIgPSByZW5kZXJlci5nZXRCdWZmZXIoJ21lc2gnLCB2dHhGb3JtYXQpO1xyXG4gICAgICAgIGxldCBvZmZzZXRJbmZvID0gYnVmZmVyLnJlcXVlc3QodmVydGV4Q291bnQsIGluZGljZXNDb3VudCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gYnVmZmVyIGRhdGEgbWF5IGJlIHJlYWxsb2MsIG5lZWQgZ2V0IHJlZmVyZW5jZSBhZnRlciByZXF1ZXN0LlxyXG4gICAgICAgIGxldCBpbmRpY2VPZmZzZXQgPSBvZmZzZXRJbmZvLmluZGljZU9mZnNldCxcclxuICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby5ieXRlT2Zmc2V0ID4+IDIsXHJcbiAgICAgICAgICAgIHZlcnRleElkID0gb2Zmc2V0SW5mby52ZXJ0ZXhPZmZzZXQsXHJcbiAgICAgICAgICAgIHZidWYgPSBidWZmZXIuX3ZEYXRhLFxyXG4gICAgICAgICAgICBpYnVmID0gYnVmZmVyLl9pRGF0YTtcclxuXHJcbiAgICAgICAgaWYgKHJlbmRlcmVyLndvcmxkTWF0RGlydHkgfHwgIXRoaXMuX3dvcmxkRGF0YXNbZGF0YUluZGV4XSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVXb3JsZFZlcnRpY2VzKGRhdGFJbmRleCwgdmVydGV4Q291bnQsIHZEYXRhLCB2dHhGb3JtYXQsIGNvbXAubm9kZS5fd29ybGRNYXRyaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmJ1Zi5zZXQodGhpcy5fd29ybGREYXRhc1tkYXRhSW5kZXhdLCB2ZXJ0ZXhPZmZzZXQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlidWZbaW5kaWNlT2Zmc2V0ICsgaV0gPSB2ZXJ0ZXhJZCArIGluZGljZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVXb3JsZFZlcnRpY2VzIChkYXRhSW5kZXgsIHZlcnRleENvdW50LCBsb2NhbCwgdnR4Rm9ybWF0LCB3b2xyZE1hdHJpeCkge1xyXG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuX3dvcmxkRGF0YXNbZGF0YUluZGV4XTtcclxuICAgICAgICBpZiAoIXdvcmxkKSB7XHJcbiAgICAgICAgICAgIHdvcmxkID0gdGhpcy5fd29ybGREYXRhc1tkYXRhSW5kZXhdID0gbmV3IEZsb2F0MzJBcnJheShsb2NhbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB3b3JsZC5zZXQobG9jYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGZsb2F0Q291bnQgPSB2dHhGb3JtYXQuX2J5dGVzIC8gNDtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgZWxlbWVudHMgPSB2dHhGb3JtYXQuX2VsZW1lbnRzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgIGxldCBhdHRyT2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQgLyA0O1xyXG4gICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmFtZSA9PT0gZ2Z4LkFUVFJfUE9TSVRJT04gfHwgZWxlbWVudC5uYW1lID09PSBnZnguQVRUUl9OT1JNQUwpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1NYXQ0ID0gZWxlbWVudC5uYW1lID09PSBnZnguQVRUUl9OT1JNQUwgPyBWZWMzLnRyYW5zZm9ybU1hdDROb3JtYWwgOiBWZWMzLnRyYW5zZm9ybU1hdDQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRleENvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaiAqIGZsb2F0Q291bnQgKyBhdHRyT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdG1wX3ZlYzMueCA9IGxvY2FsW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgX3RtcF92ZWMzLnkgPSBsb2NhbFtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBfdG1wX3ZlYzMueiA9IGxvY2FsW29mZnNldCArIDJdO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU1hdDQoX3RtcF92ZWMzLCBfdG1wX3ZlYzMsIHdvbHJkTWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbb2Zmc2V0XSA9IF90bXBfdmVjMy54O1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW29mZnNldCArIDFdID0gX3RtcF92ZWMzLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbb2Zmc2V0ICsgMl0gPSBfdG1wX3ZlYzMuejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZHJhd0RlYnVnRGF0YXMgKGNvbXAsIHJlbmRlcmVyLCBuYW1lKSB7XHJcbiAgICAgICAgbGV0IGRlYnVnRGF0YXMgPSBjb21wLl9kZWJ1Z0RhdGFzW25hbWVdO1xyXG4gICAgICAgIGlmICghZGVidWdEYXRhcykgcmV0dXJuO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVidWdEYXRhcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZGVidWdEYXRhID0gZGVidWdEYXRhc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFkZWJ1Z0RhdGEpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBsZXQgbWF0ZXJpYWwgPSBkZWJ1Z0RhdGEubWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLl9mbHVzaElBKGRlYnVnRGF0YS5pYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5Bc3NlbWJsZXIucmVnaXN0ZXIoTWVzaFJlbmRlcmVyLCBNZXNoUmVuZGVyZXJBc3NlbWJsZXIpO1xyXG4iXSwic291cmNlUm9vdCI6Ii8ifQ==