
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/sprite/2d/mesh.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MeshSpriteAssembler = /*#__PURE__*/function (_Assembler2D) {
  _inheritsLoose(MeshSpriteAssembler, _Assembler2D);

  function MeshSpriteAssembler() {
    return _Assembler2D.apply(this, arguments) || this;
  }

  var _proto = MeshSpriteAssembler.prototype;

  _proto.initData = function initData(sprite) {
    this._renderData.createFlexData(0, 4, 6, this.getVfmt());
  };

  _proto.updateRenderData = function updateRenderData(sprite) {
    this.packToDynamicAtlas(sprite, sprite._spriteFrame);
    var frame = sprite.spriteFrame;

    if (frame) {
      var vertices = frame.vertices;

      if (vertices) {
        this.verticesCount = vertices.x.length;
        this.indicesCount = vertices.triangles.length;
        var renderData = this._renderData;
        var flexBuffer = renderData._flexBuffer;

        if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
          this.updateColor(sprite);
          sprite._vertsDirty = true;
        }

        flexBuffer.used(this.verticesCount, this.indicesCount);
        this.updateIndices(vertices.triangles);

        if (sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          this.updateWorldVerts(sprite);
          sprite._vertsDirty = false;
        }
      }
    }
  };

  _proto.updateIndices = function updateIndices(triangles) {
    this._renderData.iDatas[0].set(triangles);
  };

  _proto.updateUVs = function updateUVs(sprite) {
    var vertices = sprite.spriteFrame.vertices,
        u = vertices.nu,
        v = vertices.nv;
    var uvOffset = this.uvOffset;
    var floatsPerVert = this.floatsPerVert;
    var verts = this._renderData.vDatas[0];

    for (var i = 0; i < u.length; i++) {
      var dstOffset = floatsPerVert * i + uvOffset;
      verts[dstOffset] = u[i];
      verts[dstOffset + 1] = v[i];
    }
  };

  _proto.updateVerts = function updateVerts(sprite) {
    var node = sprite.node,
        contentWidth = Math.abs(node.width),
        contentHeight = Math.abs(node.height),
        appx = node.anchorX * contentWidth,
        appy = node.anchorY * contentHeight;
    var frame = sprite.spriteFrame,
        vertices = frame.vertices,
        x = vertices.x,
        y = vertices.y,
        originalWidth = frame._originalSize.width,
        originalHeight = frame._originalSize.height,
        rectWidth = frame._rect.width,
        rectHeight = frame._rect.height,
        offsetX = frame._offset.x,
        offsetY = frame._offset.y,
        trimX = offsetX + (originalWidth - rectWidth) / 2,
        trimY = offsetY + (originalHeight - rectHeight) / 2;
    var scaleX = contentWidth / (sprite.trim ? rectWidth : originalWidth),
        scaleY = contentHeight / (sprite.trim ? rectHeight : originalHeight);
    var local = this._local;

    if (!sprite.trim) {
      for (var i = 0, l = x.length; i < l; i++) {
        var offset = i * 2;
        local[offset] = x[i] * scaleX - appx;
        local[offset + 1] = (originalHeight - y[i]) * scaleY - appy;
      }
    } else {
      for (var _i = 0, _l = x.length; _i < _l; _i++) {
        var _offset = _i * 2;

        local[_offset] = (x[_i] - trimX) * scaleX - appx;
        local[_offset + 1] = (originalHeight - y[_i] - trimY) * scaleY - appy;
      }
    }

    if (frame._flipX) {
      for (var _i2 = 0, _l2 = this.verticesCount; _i2 < _l2; _i2++) {
        local[_i2 * 2] = contentWidth - local[_i2 * 2] - 2 * appx;
      }
    }

    if (frame._flipY) {
      for (var _i3 = 0, _l3 = this.verticesCount; _i3 < _l3; _i3++) {
        local[_i3 * 2 + 1] = contentHeight - local[_i3 * 2 + 1] - 2 * appy;
      }
    }
  };

  _proto.updateWorldVerts = function updateWorldVerts(sprite) {
    var node = sprite.node;
    var matrix = node._worldMatrix;
    var matrixm = matrix.m;
    var a = matrixm[0],
        b = matrixm[1],
        c = matrixm[4],
        d = matrixm[5],
        tx = matrixm[12],
        ty = matrixm[13];
    var local = this._local;
    var world = this._renderData.vDatas[0];
    var floatsPerVert = this.floatsPerVert;

    for (var i = 0, l = this.verticesCount; i < l; i++) {
      var lx = local[i * 2];
      var ly = local[i * 2 + 1];
      world[floatsPerVert * i] = lx * a + ly * c + tx;
      world[floatsPerVert * i + 1] = lx * b + ly * d + ty;
    }
  };

  return MeshSpriteAssembler;
}(_assembler2d["default"]);

exports["default"] = MeshSpriteAssembler;
module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXHJlbmRlcmVyXFx3ZWJnbFxcYXNzZW1ibGVyc1xcc3ByaXRlXFwyZFxcbWVzaC5qcyJdLCJuYW1lcyI6WyJNZXNoU3ByaXRlQXNzZW1ibGVyIiwiaW5pdERhdGEiLCJzcHJpdGUiLCJfcmVuZGVyRGF0YSIsImNyZWF0ZUZsZXhEYXRhIiwiZ2V0VmZtdCIsInVwZGF0ZVJlbmRlckRhdGEiLCJwYWNrVG9EeW5hbWljQXRsYXMiLCJfc3ByaXRlRnJhbWUiLCJmcmFtZSIsInNwcml0ZUZyYW1lIiwidmVydGljZXMiLCJ2ZXJ0aWNlc0NvdW50IiwieCIsImxlbmd0aCIsImluZGljZXNDb3VudCIsInRyaWFuZ2xlcyIsInJlbmRlckRhdGEiLCJmbGV4QnVmZmVyIiwiX2ZsZXhCdWZmZXIiLCJyZXNlcnZlIiwidXBkYXRlQ29sb3IiLCJfdmVydHNEaXJ0eSIsInVzZWQiLCJ1cGRhdGVJbmRpY2VzIiwidXBkYXRlVVZzIiwidXBkYXRlVmVydHMiLCJ1cGRhdGVXb3JsZFZlcnRzIiwiaURhdGFzIiwic2V0IiwidSIsIm51IiwidiIsIm52IiwidXZPZmZzZXQiLCJmbG9hdHNQZXJWZXJ0IiwidmVydHMiLCJ2RGF0YXMiLCJpIiwiZHN0T2Zmc2V0Iiwibm9kZSIsImNvbnRlbnRXaWR0aCIsIk1hdGgiLCJhYnMiLCJ3aWR0aCIsImNvbnRlbnRIZWlnaHQiLCJoZWlnaHQiLCJhcHB4IiwiYW5jaG9yWCIsImFwcHkiLCJhbmNob3JZIiwieSIsIm9yaWdpbmFsV2lkdGgiLCJfb3JpZ2luYWxTaXplIiwib3JpZ2luYWxIZWlnaHQiLCJyZWN0V2lkdGgiLCJfcmVjdCIsInJlY3RIZWlnaHQiLCJvZmZzZXRYIiwiX29mZnNldCIsIm9mZnNldFkiLCJ0cmltWCIsInRyaW1ZIiwic2NhbGVYIiwidHJpbSIsInNjYWxlWSIsImxvY2FsIiwiX2xvY2FsIiwibCIsIm9mZnNldCIsIl9mbGlwWCIsIl9mbGlwWSIsIm1hdHJpeCIsIl93b3JsZE1hdHJpeCIsIm1hdHJpeG0iLCJtIiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJ3b3JsZCIsImx4IiwibHkiLCJBc3NlbWJsZXIyRCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7SUFFcUJBOzs7Ozs7Ozs7U0FDakJDLFdBQUEsa0JBQVVDLE1BQVYsRUFBa0I7QUFDZCxTQUFLQyxXQUFMLENBQWlCQyxjQUFqQixDQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxLQUFLQyxPQUFMLEVBQXpDO0FBQ0g7O1NBRURDLG1CQUFBLDBCQUFrQkosTUFBbEIsRUFBMEI7QUFDdEIsU0FBS0ssa0JBQUwsQ0FBd0JMLE1BQXhCLEVBQWdDQSxNQUFNLENBQUNNLFlBQXZDO0FBRUEsUUFBSUMsS0FBSyxHQUFHUCxNQUFNLENBQUNRLFdBQW5COztBQUNBLFFBQUlELEtBQUosRUFBVztBQUNQLFVBQUlFLFFBQVEsR0FBR0YsS0FBSyxDQUFDRSxRQUFyQjs7QUFDQSxVQUFJQSxRQUFKLEVBQWM7QUFDVixhQUFLQyxhQUFMLEdBQXFCRCxRQUFRLENBQUNFLENBQVQsQ0FBV0MsTUFBaEM7QUFDQSxhQUFLQyxZQUFMLEdBQW9CSixRQUFRLENBQUNLLFNBQVQsQ0FBbUJGLE1BQXZDO0FBRUEsWUFBSUcsVUFBVSxHQUFHLEtBQUtkLFdBQXRCO0FBQ0EsWUFBSWUsVUFBVSxHQUFHRCxVQUFVLENBQUNFLFdBQTVCOztBQUNBLFlBQUlELFVBQVUsQ0FBQ0UsT0FBWCxDQUFtQixLQUFLUixhQUF4QixFQUF1QyxLQUFLRyxZQUE1QyxDQUFKLEVBQStEO0FBQzNELGVBQUtNLFdBQUwsQ0FBaUJuQixNQUFqQjtBQUNBQSxVQUFBQSxNQUFNLENBQUNvQixXQUFQLEdBQXFCLElBQXJCO0FBQ0g7O0FBQ0RKLFFBQUFBLFVBQVUsQ0FBQ0ssSUFBWCxDQUFnQixLQUFLWCxhQUFyQixFQUFvQyxLQUFLRyxZQUF6QztBQUVBLGFBQUtTLGFBQUwsQ0FBbUJiLFFBQVEsQ0FBQ0ssU0FB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KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwczovL3d3dy5jb2Nvcy5jb20vXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXHJcbiB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXHJcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxyXG4gbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xyXG4gdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXHJcblxyXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cclxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuaW1wb3J0IEFzc2VtYmxlcjJEIGZyb20gJy4uLy4uLy4uLy4uL2Fzc2VtYmxlci0yZCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXNoU3ByaXRlQXNzZW1ibGVyIGV4dGVuZHMgQXNzZW1ibGVyMkQge1xyXG4gICAgaW5pdERhdGEgKHNwcml0ZSkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckRhdGEuY3JlYXRlRmxleERhdGEoMCwgNCwgNiwgdGhpcy5nZXRWZm10KCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB1cGRhdGVSZW5kZXJEYXRhIChzcHJpdGUpIHtcclxuICAgICAgICB0aGlzLnBhY2tUb0R5bmFtaWNBdGxhcyhzcHJpdGUsIHNwcml0ZS5fc3ByaXRlRnJhbWUpO1xyXG5cclxuICAgICAgICBsZXQgZnJhbWUgPSBzcHJpdGUuc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0aWNlcyA9IGZyYW1lLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNDb3VudCA9IHZlcnRpY2VzLngubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzQ291bnQgPSB2ZXJ0aWNlcy50cmlhbmdsZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJEYXRhID0gdGhpcy5fcmVuZGVyRGF0YTtcclxuICAgICAgICAgICAgICAgIGxldCBmbGV4QnVmZmVyID0gcmVuZGVyRGF0YS5fZmxleEJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGlmIChmbGV4QnVmZmVyLnJlc2VydmUodGhpcy52ZXJ0aWNlc0NvdW50LCB0aGlzLmluZGljZXNDb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKHNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLl92ZXJ0c0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZsZXhCdWZmZXIudXNlZCh0aGlzLnZlcnRpY2VzQ291bnQsIHRoaXMuaW5kaWNlc0NvdW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluZGljZXModmVydGljZXMudHJpYW5nbGVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3ByaXRlLl92ZXJ0c0RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVVVnMoc3ByaXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZlcnRzKHNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLl92ZXJ0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSW5kaWNlcyAodHJpYW5nbGVzKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyRGF0YS5pRGF0YXNbMF0uc2V0KHRyaWFuZ2xlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVVZzIChzcHJpdGUpIHtcclxuICAgICAgICBsZXQgdmVydGljZXMgPSBzcHJpdGUuc3ByaXRlRnJhbWUudmVydGljZXMsXHJcbiAgICAgICAgICAgIHUgPSB2ZXJ0aWNlcy5udSxcclxuICAgICAgICAgICAgdiA9IHZlcnRpY2VzLm52O1xyXG5cclxuICAgICAgICBsZXQgdXZPZmZzZXQgPSB0aGlzLnV2T2Zmc2V0O1xyXG4gICAgICAgIGxldCBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZHN0T2Zmc2V0ID0gZmxvYXRzUGVyVmVydCAqIGkgKyB1dk9mZnNldDtcclxuICAgICAgICAgICAgdmVydHNbZHN0T2Zmc2V0XSA9IHVbaV07XHJcbiAgICAgICAgICAgIHZlcnRzW2RzdE9mZnNldCArIDFdID0gdltpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVmVydHMgKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBub2RlID0gc3ByaXRlLm5vZGUsXHJcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGguYWJzKG5vZGUud2lkdGgpLFxyXG4gICAgICAgICAgICBjb250ZW50SGVpZ2h0ID0gTWF0aC5hYnMobm9kZS5oZWlnaHQpLFxyXG4gICAgICAgICAgICBhcHB4ID0gbm9kZS5hbmNob3JYICogY29udGVudFdpZHRoLFxyXG4gICAgICAgICAgICBhcHB5ID0gbm9kZS5hbmNob3JZICogY29udGVudEhlaWdodDtcclxuXHJcbiAgICAgICAgbGV0IGZyYW1lID0gc3ByaXRlLnNwcml0ZUZyYW1lLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IGZyYW1lLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICB4ID0gdmVydGljZXMueCxcclxuICAgICAgICAgICAgeSA9IHZlcnRpY2VzLnksXHJcbiAgICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSBmcmFtZS5fb3JpZ2luYWxTaXplLndpZHRoLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEhlaWdodCA9IGZyYW1lLl9vcmlnaW5hbFNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICByZWN0V2lkdGggPSBmcmFtZS5fcmVjdC53aWR0aCxcclxuICAgICAgICAgICAgcmVjdEhlaWdodCA9IGZyYW1lLl9yZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgb2Zmc2V0WCA9IGZyYW1lLl9vZmZzZXQueCxcclxuICAgICAgICAgICAgb2Zmc2V0WSA9IGZyYW1lLl9vZmZzZXQueSxcclxuICAgICAgICAgICAgdHJpbVggPSBvZmZzZXRYICsgKG9yaWdpbmFsV2lkdGggLSByZWN0V2lkdGgpIC8gMixcclxuICAgICAgICAgICAgdHJpbVkgPSBvZmZzZXRZICsgKG9yaWdpbmFsSGVpZ2h0IC0gcmVjdEhlaWdodCkgLyAyO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGVYID0gY29udGVudFdpZHRoIC8gKHNwcml0ZS50cmltID8gcmVjdFdpZHRoIDogb3JpZ2luYWxXaWR0aCksXHJcbiAgICAgICAgICAgIHNjYWxlWSA9IGNvbnRlbnRIZWlnaHQgLyAoc3ByaXRlLnRyaW0gPyByZWN0SGVpZ2h0IDogb3JpZ2luYWxIZWlnaHQpO1xyXG5cclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICBpZiAoIXNwcml0ZS50cmltKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogMjtcclxuICAgICAgICAgICAgICAgIGxvY2FsW29mZnNldF0gPSAoeFtpXSkgKiBzY2FsZVggLSBhcHB4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxbb2Zmc2V0ICsgMV0gPSAob3JpZ2luYWxIZWlnaHQgLSB5W2ldKSAqIHNjYWxlWSAtIGFwcHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogMjtcclxuICAgICAgICAgICAgICAgIGxvY2FsW29mZnNldF0gPSAoeFtpXSAtIHRyaW1YKSAqIHNjYWxlWCAtIGFwcHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFtvZmZzZXQgKyAxXSA9IChvcmlnaW5hbEhlaWdodCAtIHlbaV0gLSB0cmltWSkgKiBzY2FsZVkgLSBhcHB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFtZS5fZmxpcFgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzQ291bnQ7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsW2kgKiAyXSA9IGNvbnRlbnRXaWR0aCAtIGxvY2FsW2kgKiAyXSAtIDIgKiBhcHB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFtZS5fZmxpcFkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzQ291bnQ7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsW2kgKiAyICsgMV0gPSBjb250ZW50SGVpZ2h0IC0gbG9jYWxbaSAqIDIgKyAxXSAtIDIgKiBhcHB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVdvcmxkVmVydHMgKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBub2RlID0gc3ByaXRlLm5vZGU7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IG5vZGUuX3dvcmxkTWF0cml4O1xyXG4gICAgICAgIGxldCBtYXRyaXhtID0gbWF0cml4Lm07XHJcbiAgICAgICAgbGV0IGEgPSBtYXRyaXhtWzBdLCBiID0gbWF0cml4bVsxXSwgYyA9IG1hdHJpeG1bNF0sIGQgPSBtYXRyaXhtWzVdLFxyXG4gICAgICAgICAgICB0eCA9IG1hdHJpeG1bMTJdLCB0eSA9IG1hdHJpeG1bMTNdO1xyXG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xyXG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG4gICAgICAgIGxldCBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlc0NvdW50OyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBseCA9IGxvY2FsW2kqMl07XHJcbiAgICAgICAgICAgIGxldCBseSA9IGxvY2FsW2kqMiArIDFdO1xyXG4gICAgICAgICAgICB3b3JsZFtmbG9hdHNQZXJWZXJ0ICogaV0gPSBseCAqIGEgKyBseSAqIGMgKyB0eDtcclxuICAgICAgICAgICAgd29ybGRbZmxvYXRzUGVyVmVydCAqIGkgKyAxXSA9IGx4ICogYiArIGx5ICogZCArIHR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6Ii8ifQ==