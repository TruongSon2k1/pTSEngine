
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/mask-assembler.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports.MaskAssembler = void 0;

var _assembler = _interopRequireDefault(require("../../assembler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Mask = require('../../../components/CCMask');

var RenderFlow = require('../../render-flow');

var SimpleSpriteAssembler = require('./sprite/2d/simple');

var GraphicsAssembler = require('./graphics');

var gfx = require('../../../../renderer/gfx');

var vfmtPos = require('../vertex-format').vfmtPos; // todo: 8 is least Stencil depth supported by webGL device, it could be adjusted to vendor implementation value


var _maxLevel = 8; // Current mask

var _maskStack = [];

function getWriteMask() {
  return 0x01 << _maskStack.length - 1;
}

function getStencilRef() {
  var result = 0;

  for (var i = 0; i < _maskStack.length; ++i) {
    result += 0x01 << i;
  }

  return result;
}

function applyStencil(material, func, failOp, ref, stencilMask, writeMask) {
  var effect = material.effect;
  var zFailOp = gfx.STENCIL_OP_KEEP,
      zPassOp = gfx.STENCIL_OP_KEEP;
  effect.setStencil(gfx.STENCIL_ENABLE, func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
}

function pushMask(mask) {
  if (_maskStack.length + 1 > _maxLevel) {
    cc.errorID(9000, _maxLevel);
  }

  _maskStack.push(mask);
}

function exitMask(mask, renderer) {
  if (_maskStack.length === 0) {
    cc.errorID(9001);
  }

  _maskStack.pop();

  if (_maskStack.length === 0) {
    renderer._flushMaterial(mask._exitMaterial);
  } else {
    enableMask(renderer);
  }
}

function applyClearMask(mask, renderer) {
  var func = gfx.DS_FUNC_NEVER;
  var ref = getWriteMask();
  var stencilMask = ref;
  var writeMask = ref;
  var failOp = mask.inverted ? gfx.STENCIL_OP_REPLACE : gfx.STENCIL_OP_ZERO;
  applyStencil(mask._clearMaterial, func, failOp, ref, stencilMask, writeMask);
  var buffer = renderer.getBuffer('mesh', vfmtPos);
  var offsetInfo = buffer.request(4, 6);
  var indiceOffset = offsetInfo.indiceOffset,
      vertexOffset = offsetInfo.byteOffset >> 2,
      vertexId = offsetInfo.vertexOffset,
      vbuf = buffer._vData,
      ibuf = buffer._iData;
  vbuf[vertexOffset++] = -1;
  vbuf[vertexOffset++] = -1;
  vbuf[vertexOffset++] = -1;
  vbuf[vertexOffset++] = 1;
  vbuf[vertexOffset++] = 1;
  vbuf[vertexOffset++] = 1;
  vbuf[vertexOffset++] = 1;
  vbuf[vertexOffset++] = -1;
  ibuf[indiceOffset++] = vertexId;
  ibuf[indiceOffset++] = vertexId + 3;
  ibuf[indiceOffset++] = vertexId + 1;
  ibuf[indiceOffset++] = vertexId + 1;
  ibuf[indiceOffset++] = vertexId + 3;
  ibuf[indiceOffset++] = vertexId + 2;
  renderer.node = renderer._dummyNode;
  renderer.material = mask._clearMaterial;

  renderer._flush();
}

function applyAreaMask(mask, renderer) {
  var func = gfx.DS_FUNC_NEVER;
  var ref = getWriteMask();
  var stencilMask = ref;
  var writeMask = ref;
  var failOp = mask.inverted ? gfx.STENCIL_OP_ZERO : gfx.STENCIL_OP_REPLACE;
  applyStencil(mask._materials[0], func, failOp, ref, stencilMask, writeMask); // vertex buffer

  renderer.material = mask._materials[0];

  if (mask._type === Mask.Type.IMAGE_STENCIL) {
    renderer.node = renderer._dummyNode;
    SimpleSpriteAssembler.prototype.fillBuffers.call(mask._assembler, mask, renderer);

    renderer._flush();
  } else {
    renderer.node = mask.node;
    GraphicsAssembler.prototype.fillBuffers.call(mask._graphics._assembler, mask._graphics, renderer);
  }
}

function enableMask(renderer) {
  var func = gfx.DS_FUNC_EQUAL;
  var failOp = gfx.STENCIL_OP_KEEP;
  var ref = getStencilRef();
  var stencilMask = ref;
  var writeMask = getWriteMask();
  var mask = _maskStack[_maskStack.length - 1];
  applyStencil(mask._enableMaterial, func, failOp, ref, stencilMask, writeMask);

  renderer._flushMaterial(mask._enableMaterial);
}

var MaskAssembler = /*#__PURE__*/function (_SimpleSpriteAssemble) {
  _inheritsLoose(MaskAssembler, _SimpleSpriteAssemble);

  function MaskAssembler() {
    return _SimpleSpriteAssemble.apply(this, arguments) || this;
  }

  var _proto = MaskAssembler.prototype;

  _proto.updateRenderData = function updateRenderData(mask) {
    if (mask._type === Mask.Type.IMAGE_STENCIL) {
      if (mask.spriteFrame) {
        SimpleSpriteAssembler.prototype.updateRenderData.call(this, mask);
      } else {
        mask.setMaterial(0, null);
      }
    } else {
      mask._graphics.setMaterial(0, mask._materials[0]);

      GraphicsAssembler.prototype.updateRenderData.call(mask._graphics._assembler, mask._graphics, mask._graphics);
    }
  };

  _proto.fillBuffers = function fillBuffers(mask, renderer) {
    // Invalid state
    if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
      // HACK: Must push mask after batch, so we can only put this logic in fillVertexBuffer or fillIndexBuffer
      pushMask(mask);
      applyClearMask(mask, renderer);
      applyAreaMask(mask, renderer);
      enableMask(renderer);
    }

    mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
  };

  _proto.postFillBuffers = function postFillBuffers(mask, renderer) {
    // Invalid state
    if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
      // HACK: Must pop mask after batch, so we can only put this logic in fillBuffers
      exitMask(mask, renderer);
    }

    mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
  };

  return MaskAssembler;
}(SimpleSpriteAssembler);

exports.MaskAssembler = MaskAssembler;
;

_assembler["default"].register(Mask, MaskAssembler);
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXHJlbmRlcmVyXFx3ZWJnbFxcYXNzZW1ibGVyc1xcbWFzay1hc3NlbWJsZXIuanMiXSwibmFtZXMiOlsiTWFzayIsInJlcXVpcmUiLCJSZW5kZXJGbG93IiwiU2ltcGxlU3ByaXRlQXNzZW1ibGVyIiwiR3JhcGhpY3NBc3NlbWJsZXIiLCJnZngiLCJ2Zm10UG9zIiwiX21heExldmVsIiwiX21hc2tTdGFjayIsImdldFdyaXRlTWFzayIsImxlbmd0aCIsImdldFN0ZW5jaWxSZWYiLCJyZXN1bHQiLCJpIiwiYXBwbHlTdGVuY2lsIiwibWF0ZXJpYWwiLCJmdW5jIiwiZmFpbE9wIiwicmVmIiwic3RlbmNpbE1hc2siLCJ3cml0ZU1hc2siLCJlZmZlY3QiLCJ6RmFpbE9wIiwiU1RFTkNJTF9PUF9LRUVQIiwielBhc3NPcCIsInNldFN0ZW5jaWwiLCJTVEVOQ0lMX0VOQUJMRSIsInB1c2hNYXNrIiwibWFzayIsImNjIiwiZXJyb3JJRCIsInB1c2giLCJleGl0TWFzayIsInJlbmRlcmVyIiwicG9wIiwiX2ZsdXNoTWF0ZXJpYWwiLCJfZXhpdE1hdGVyaWFsIiwiZW5hYmxlTWFzayIsImFwcGx5Q2xlYXJNYXNrIiwiRFNfRlVOQ19ORVZFUiIsImludmVydGVkIiwiU1RFTkNJTF9PUF9SRVBMQUNFIiwiU1RFTkNJTF9PUF9aRVJPIiwiX2NsZWFyTWF0ZXJpYWwiLCJidWZmZXIiLCJnZXRCdWZmZXIiLCJvZmZzZXRJbmZvIiwicmVxdWVzdCIsImluZGljZU9mZnNldCIsInZlcnRleE9mZnNldCIsImJ5dGVPZmZzZXQiLCJ2ZXJ0ZXhJZCIsInZidWYiLCJfdkRhdGEiLCJpYnVmIiwiX2lEYXRhIiwibm9kZSIsIl9kdW1teU5vZGUiLCJfZmx1c2giLCJhcHBseUFyZWFNYXNrIiwiX21hdGVyaWFscyIsIl90eXBlIiwiVHlwZSIsIklNQUdFX1NURU5DSUwiLCJwcm90b3R5cGUiLCJmaWxsQnVmZmVycyIsImNhbGwiLCJfYXNzZW1ibGVyIiwiX2dyYXBoaWNzIiwiRFNfRlVOQ19FUVVBTCIsIl9lbmFibGVNYXRlcmlhbCIsIk1hc2tBc3NlbWJsZXIiLCJ1cGRhdGVSZW5kZXJEYXRhIiwic3ByaXRlRnJhbWUiLCJzZXRNYXRlcmlhbCIsIl9yZW5kZXJGbGFnIiwiRkxBR19VUERBVEVfUkVOREVSX0RBVEEiLCJwb3N0RmlsbEJ1ZmZlcnMiLCJBc3NlbWJsZXIiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7QUFFQSxJQUFNQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyw0QkFBRCxDQUFwQjs7QUFDQSxJQUFNQyxVQUFVLEdBQUdELE9BQU8sQ0FBQyxtQkFBRCxDQUExQjs7QUFDQSxJQUFNRSxxQkFBcUIsR0FBR0YsT0FBTyxDQUFDLG9CQUFELENBQXJDOztBQUNBLElBQU1HLGlCQUFpQixHQUFHSCxPQUFPLENBQUMsWUFBRCxDQUFqQzs7QUFDQSxJQUFNSSxHQUFHLEdBQUdKLE9BQU8sQ0FBQywwQkFBRCxDQUFuQjs7QUFDQSxJQUFNSyxPQUFPLEdBQUdMLE9BQU8sQ0FBQyxrQkFBRCxDQUFQLENBQTRCSyxPQUE1QyxFQUVBOzs7QUFDQSxJQUFJQyxTQUFTLEdBQUcsQ0FBaEIsRUFDQTs7QUFDQSxJQUFJQyxVQUFVLEdBQUcsRUFBakI7O0FBRUEsU0FBU0MsWUFBVCxHQUF5QjtBQUNyQixTQUFPLFFBQVNELFVBQVUsQ0FBQ0UsTUFBWCxHQUFvQixDQUFwQztBQUNIOztBQUVELFNBQVNDLGFBQVQsR0FBMEI7QUFDdEIsTUFBSUMsTUFBTSxHQUFHLENBQWI7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHTCxVQUFVLENBQUNFLE1BQS9CLEVBQXVDLEVBQUVHLENBQXpDLEVBQTRDO0FBQ3hDRCxJQUFBQSxNQUFNLElBQUssUUFBUUMsQ0FBbkI7QUFDSDs7QUFDRCxTQUFPRCxNQUFQO0FBQ0g7O0FBRUQsU0FBU0UsWUFBVCxDQUF1QkMsUUFBdkIsRUFB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QyxJQUFJLENBQUN3QyxTQUFsRztBQUNIO0FBQ0o7O1NBRURILGNBQUEscUJBQWFyQyxJQUFiLEVBQW1CSyxRQUFuQixFQUE2QjtBQUN6QjtBQUNBLFFBQUlMLElBQUksQ0FBQ2lDLEtBQUwsS0FBZTdELElBQUksQ0FBQzhELElBQUwsQ0FBVUMsYUFBekIsSUFBMENuQyxJQUFJLENBQUM2QyxXQUFuRCxFQUFnRTtBQUM1RDtBQUNBOUMsTUFBQUEsUUFBUSxDQUFDQyxJQUFELENBQVI7QUFFQVUsTUFBQUEsY0FBYyxDQUFDVixJQUFELEVBQU9LLFFBQVAsQ0FBZDtBQUNBMEIsTUFBQUEsYUFBYSxDQUFDL0IsSUFBRCxFQUFPSyxRQUFQLENBQWI7QUFFQUksTUFBQUEsVUFBVSxDQUFDSixRQUFELENBQVY7QUFDSDs7QUFFREwsSUFBQUEsSUFBSSxDQUFDNEIsSUFBTCxDQUFVbUIsV0FBVixJQUF5QnpFLFVBQVUsQ0FBQzBFLHVCQUFwQztBQUNIOztTQUVEQyxrQkFBQSx5QkFBaUJqRCxJQUFqQixFQUF1QkssUUFBdkIsRUFBaUM7QUFDN0I7QUFDQSxRQUFJTCxJQUFJLENBQUNpQyxLQUFMLEtBQWU3RCxJQUFJLENBQUM4RCxJQUFMLENBQVVDLGFBQXpCLElBQTBDbkMsSUFBSSxDQUFDNkMsV0FBbkQsRUFBZ0U7QUFDNUQ7QUFDQXpDLE1BQUFBLFFBQVEsQ0FBQ0osSUFBRCxFQUFPSyxRQUFQLENBQVI7QUFDSDs7QUFFREwsSUFBQUEsSUFBSSxDQUFDNEIsSUFBTCxDQUFVbUIsV0FBVixJQUF5QnpFLFVBQVUsQ0FBQzBFLHVCQUFwQztBQUNIOzs7RUF2QytCekU7OztBQXdDbkM7O0FBRUQyRSxzQkFBVUMsUUFBVixDQUFtQi9FLElBQW5CLEVBQXlCdUUsYUFBekIiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXHJcblxyXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmltcG9ydCBBc3NlbWJsZXIgZnJvbSAnLi4vLi4vYXNzZW1ibGVyJztcclxuXHJcbmNvbnN0IE1hc2sgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL0NDTWFzaycpO1xyXG5jb25zdCBSZW5kZXJGbG93ID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyLWZsb3cnKTtcclxuY29uc3QgU2ltcGxlU3ByaXRlQXNzZW1ibGVyID0gcmVxdWlyZSgnLi9zcHJpdGUvMmQvc2ltcGxlJyk7XHJcbmNvbnN0IEdyYXBoaWNzQXNzZW1ibGVyID0gcmVxdWlyZSgnLi9ncmFwaGljcycpO1xyXG5jb25zdCBnZnggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9yZW5kZXJlci9nZngnKTtcclxuY29uc3QgdmZtdFBvcyA9IHJlcXVpcmUoJy4uL3ZlcnRleC1mb3JtYXQnKS52Zm10UG9zO1xyXG5cclxuLy8gdG9kbzogOCBpcyBsZWFzdCBTdGVuY2lsIGRlcHRoIHN1cHBvcnRlZCBieSB3ZWJHTCBkZXZpY2UsIGl0IGNvdWxkIGJlIGFkanVzdGVkIHRvIHZlbmRvciBpbXBsZW1lbnRhdGlvbiB2YWx1ZVxyXG5sZXQgX21heExldmVsID0gODtcclxuLy8gQ3VycmVudCBtYXNrXHJcbmxldCBfbWFza1N0YWNrID0gW107XHJcblxyXG5mdW5jdGlvbiBnZXRXcml0ZU1hc2sgKCkge1xyXG4gICAgcmV0dXJuIDB4MDEgPDwgKF9tYXNrU3RhY2subGVuZ3RoIC0gMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFN0ZW5jaWxSZWYgKCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9tYXNrU3RhY2subGVuZ3RoOyArK2kpIHtcclxuICAgICAgICByZXN1bHQgKz0gKDB4MDEgPDwgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVN0ZW5jaWwgKG1hdGVyaWFsLCBmdW5jLCBmYWlsT3AsIHJlZiwgc3RlbmNpbE1hc2ssIHdyaXRlTWFzaykge1xyXG4gICAgbGV0IGVmZmVjdCA9IG1hdGVyaWFsLmVmZmVjdDtcclxuICAgIGxldCB6RmFpbE9wID0gZ2Z4LlNURU5DSUxfT1BfS0VFUCxcclxuICAgICAgICB6UGFzc09wID0gZ2Z4LlNURU5DSUxfT1BfS0VFUDtcclxuICAgIGVmZmVjdC5zZXRTdGVuY2lsKGdmeC5TVEVOQ0lMX0VOQUJMRSwgZnVuYywgcmVmLCBzdGVuY2lsTWFzaywgZmFpbE9wLCB6RmFpbE9wLCB6UGFzc09wLCB3cml0ZU1hc2spO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcHVzaE1hc2sgKG1hc2spIHtcclxuICAgIGlmIChfbWFza1N0YWNrLmxlbmd0aCArIDEgPiBfbWF4TGV2ZWwpIHtcclxuICAgICAgICBjYy5lcnJvcklEKDkwMDAsIF9tYXhMZXZlbCk7XHJcbiAgICB9XHJcbiAgICBfbWFza1N0YWNrLnB1c2gobWFzayk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4aXRNYXNrIChtYXNrLCByZW5kZXJlcikge1xyXG4gICAgaWYgKF9tYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY2MuZXJyb3JJRCg5MDAxKTtcclxuICAgIH1cclxuICAgIF9tYXNrU3RhY2sucG9wKCk7XHJcbiAgICBpZiAoX21hc2tTdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZW5kZXJlci5fZmx1c2hNYXRlcmlhbChtYXNrLl9leGl0TWF0ZXJpYWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZW5hYmxlTWFzayhyZW5kZXJlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5Q2xlYXJNYXNrIChtYXNrLCByZW5kZXJlcikge1xyXG4gICAgbGV0IGZ1bmMgPSBnZnguRFNfRlVOQ19ORVZFUjtcclxuICAgIGxldCByZWYgPSBnZXRXcml0ZU1hc2soKTtcclxuICAgIGxldCBzdGVuY2lsTWFzayA9IHJlZjtcclxuICAgIGxldCB3cml0ZU1hc2sgPSByZWY7XHJcbiAgICBsZXQgZmFpbE9wID0gbWFzay5pbnZlcnRlZCA/IGdmeC5TVEVOQ0lMX09QX1JFUExBQ0UgOiBnZnguU1RFTkNJTF9PUF9aRVJPO1xyXG5cclxuICAgIGFwcGx5U3RlbmNpbChtYXNrLl9jbGVhck1hdGVyaWFsLCBmdW5jLCBmYWlsT3AsIHJlZiwgc3RlbmNpbE1hc2ssIHdyaXRlTWFzayk7XHJcblxyXG4gICAgbGV0IGJ1ZmZlciA9IHJlbmRlcmVyLmdldEJ1ZmZlcignbWVzaCcsIHZmbXRQb3MpO1xyXG4gICAgbGV0IG9mZnNldEluZm8gPSBidWZmZXIucmVxdWVzdCg0LCA2KTtcclxuICAgIGxldCBpbmRpY2VPZmZzZXQgPSBvZmZzZXRJbmZvLmluZGljZU9mZnNldCxcclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSBvZmZzZXRJbmZvLmJ5dGVPZmZzZXQgPj4gMixcclxuICAgICAgICB2ZXJ0ZXhJZCA9IG9mZnNldEluZm8udmVydGV4T2Zmc2V0LFxyXG4gICAgICAgIHZidWYgPSBidWZmZXIuX3ZEYXRhLFxyXG4gICAgICAgIGlidWYgPSBidWZmZXIuX2lEYXRhO1xyXG4gICAgXHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IC0xO1xyXG4gICAgdmJ1Zlt2ZXJ0ZXhPZmZzZXQrK10gPSAtMTtcclxuICAgIHZidWZbdmVydGV4T2Zmc2V0KytdID0gLTE7XHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICB2YnVmW3ZlcnRleE9mZnNldCsrXSA9IC0xO1xyXG5cclxuICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gdmVydGV4SWQ7XHJcbiAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHZlcnRleElkICsgMztcclxuICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gdmVydGV4SWQgKyAxO1xyXG4gICAgaWJ1ZltpbmRpY2VPZmZzZXQrK10gPSB2ZXJ0ZXhJZCArIDE7XHJcbiAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHZlcnRleElkICsgMztcclxuICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gdmVydGV4SWQgKyAyO1xyXG5cclxuICAgIHJlbmRlcmVyLm5vZGUgPSByZW5kZXJlci5fZHVtbXlOb2RlO1xyXG4gICAgcmVuZGVyZXIubWF0ZXJpYWwgPSBtYXNrLl9jbGVhck1hdGVyaWFsO1xyXG4gICAgcmVuZGVyZXIuX2ZsdXNoKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5QXJlYU1hc2sgKG1hc2ssIHJlbmRlcmVyKSB7XHJcbiAgICBsZXQgZnVuYyA9IGdmeC5EU19GVU5DX05FVkVSO1xyXG4gICAgbGV0IHJlZiA9IGdldFdyaXRlTWFzaygpO1xyXG4gICAgbGV0IHN0ZW5jaWxNYXNrID0gcmVmO1xyXG4gICAgbGV0IHdyaXRlTWFzayA9IHJlZjtcclxuICAgIGxldCBmYWlsT3AgPSBtYXNrLmludmVydGVkID8gZ2Z4LlNURU5DSUxfT1BfWkVSTyA6IGdmeC5TVEVOQ0lMX09QX1JFUExBQ0U7XHJcblxyXG4gICAgYXBwbHlTdGVuY2lsKG1hc2suX21hdGVyaWFsc1swXSwgZnVuYywgZmFpbE9wLCByZWYsIHN0ZW5jaWxNYXNrLCB3cml0ZU1hc2spO1xyXG5cclxuICAgIC8vIHZlcnRleCBidWZmZXJcclxuICAgIHJlbmRlcmVyLm1hdGVyaWFsID0gbWFzay5fbWF0ZXJpYWxzWzBdO1xyXG5cclxuICAgIGlmIChtYXNrLl90eXBlID09PSBNYXNrLlR5cGUuSU1BR0VfU1RFTkNJTCkge1xyXG4gICAgICAgIHJlbmRlcmVyLm5vZGUgPSByZW5kZXJlci5fZHVtbXlOb2RlO1xyXG4gICAgICAgIFNpbXBsZVNwcml0ZUFzc2VtYmxlci5wcm90b3R5cGUuZmlsbEJ1ZmZlcnMuY2FsbChtYXNrLl9hc3NlbWJsZXIsIG1hc2ssIHJlbmRlcmVyKTtcclxuICAgICAgICByZW5kZXJlci5fZmx1c2goKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlbmRlcmVyLm5vZGUgPSBtYXNrLm5vZGU7XHJcbiAgICAgICAgR3JhcGhpY3NBc3NlbWJsZXIucHJvdG90eXBlLmZpbGxCdWZmZXJzLmNhbGwobWFzay5fZ3JhcGhpY3MuX2Fzc2VtYmxlciwgbWFzay5fZ3JhcGhpY3MsIHJlbmRlcmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5hYmxlTWFzayAocmVuZGVyZXIpIHtcclxuICAgIGxldCBmdW5jID0gZ2Z4LkRTX0ZVTkNfRVFVQUw7XHJcbiAgICBsZXQgZmFpbE9wID0gZ2Z4LlNURU5DSUxfT1BfS0VFUDtcclxuICAgIGxldCByZWYgPSBnZXRTdGVuY2lsUmVmKCk7XHJcbiAgICBsZXQgc3RlbmNpbE1hc2sgPSByZWY7XHJcbiAgICBsZXQgd3JpdGVNYXNrID0gZ2V0V3JpdGVNYXNrKCk7XHJcbiAgICBcclxuICAgIGxldCBtYXNrID0gX21hc2tTdGFja1tfbWFza1N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgYXBwbHlTdGVuY2lsKG1hc2suX2VuYWJsZU1hdGVyaWFsLCBmdW5jLCBmYWlsT3AsIHJlZiwgc3RlbmNpbE1hc2ssIHdyaXRlTWFzayk7XHJcbiAgICByZW5kZXJlci5fZmx1c2hNYXRlcmlhbChtYXNrLl9lbmFibGVNYXRlcmlhbCk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNYXNrQXNzZW1ibGVyICBleHRlbmRzIFNpbXBsZVNwcml0ZUFzc2VtYmxlciB7XHJcbiAgICB1cGRhdGVSZW5kZXJEYXRhIChtYXNrKSB7XHJcbiAgICAgICAgaWYgKG1hc2suX3R5cGUgPT09IE1hc2suVHlwZS5JTUFHRV9TVEVOQ0lMKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXNrLnNwcml0ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGVTcHJpdGVBc3NlbWJsZXIucHJvdG90eXBlLnVwZGF0ZVJlbmRlckRhdGEuY2FsbCh0aGlzLCBtYXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hc2suc2V0TWF0ZXJpYWwoMCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hc2suX2dyYXBoaWNzLnNldE1hdGVyaWFsKDAsIG1hc2suX21hdGVyaWFsc1swXSk7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzQXNzZW1ibGVyLnByb3RvdHlwZS51cGRhdGVSZW5kZXJEYXRhLmNhbGwobWFzay5fZ3JhcGhpY3MuX2Fzc2VtYmxlciwgbWFzay5fZ3JhcGhpY3MsIG1hc2suX2dyYXBoaWNzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmlsbEJ1ZmZlcnMgKG1hc2ssIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgLy8gSW52YWxpZCBzdGF0ZVxyXG4gICAgICAgIGlmIChtYXNrLl90eXBlICE9PSBNYXNrLlR5cGUuSU1BR0VfU1RFTkNJTCB8fCBtYXNrLnNwcml0ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IE11c3QgcHVzaCBtYXNrIGFmdGVyIGJhdGNoLCBzbyB3ZSBjYW4gb25seSBwdXQgdGhpcyBsb2dpYyBpbiBmaWxsVmVydGV4QnVmZmVyIG9yIGZpbGxJbmRleEJ1ZmZlclxyXG4gICAgICAgICAgICBwdXNoTWFzayhtYXNrKTtcclxuXHJcbiAgICAgICAgICAgIGFwcGx5Q2xlYXJNYXNrKG1hc2ssIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgYXBwbHlBcmVhTWFzayhtYXNrLCByZW5kZXJlcik7XHJcblxyXG4gICAgICAgICAgICBlbmFibGVNYXNrKHJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hc2subm9kZS5fcmVuZGVyRmxhZyB8PSBSZW5kZXJGbG93LkZMQUdfVVBEQVRFX1JFTkRFUl9EQVRBO1xyXG4gICAgfVxyXG5cclxuICAgIHBvc3RGaWxsQnVmZmVycyAobWFzaywgcmVuZGVyZXIpIHtcclxuICAgICAgICAvLyBJbnZhbGlkIHN0YXRlXHJcbiAgICAgICAgaWYgKG1hc2suX3R5cGUgIT09IE1hc2suVHlwZS5JTUFHRV9TVEVOQ0lMIHx8IG1hc2suc3ByaXRlRnJhbWUpIHtcclxuICAgICAgICAgICAgLy8gSEFDSzogTXVzdCBwb3AgbWFzayBhZnRlciBiYXRjaCwgc28gd2UgY2FuIG9ubHkgcHV0IHRoaXMgbG9naWMgaW4gZmlsbEJ1ZmZlcnNcclxuICAgICAgICAgICAgZXhpdE1hc2sobWFzaywgcmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWFzay5ub2RlLl9yZW5kZXJGbGFnIHw9IFJlbmRlckZsb3cuRkxBR19VUERBVEVfUkVOREVSX0RBVEE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NlbWJsZXIucmVnaXN0ZXIoTWFzaywgTWFza0Fzc2VtYmxlcik7XHJcbiJdLCJzb3VyY2VSb290IjoiLyJ9