
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/sprite/2d/sliced.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SlicedAssembler = /*#__PURE__*/function (_Assembler2D) {
  _inheritsLoose(SlicedAssembler, _Assembler2D);

  function SlicedAssembler() {
    return _Assembler2D.apply(this, arguments) || this;
  }

  var _proto = SlicedAssembler.prototype;

  _proto.initData = function initData(sprite) {
    if (this._renderData.meshCount > 0) return;

    this._renderData.createData(0, this.verticesFloats, this.indicesCount);

    var indices = this._renderData.iDatas[0];
    var indexOffset = 0;

    for (var r = 0; r < 3; ++r) {
      for (var c = 0; c < 3; ++c) {
        var start = r * 4 + c;
        indices[indexOffset++] = start;
        indices[indexOffset++] = start + 1;
        indices[indexOffset++] = start + 4;
        indices[indexOffset++] = start + 1;
        indices[indexOffset++] = start + 5;
        indices[indexOffset++] = start + 4;
      }
    }
  };

  _proto.initLocal = function initLocal() {
    this._local = [];
    this._local.length = 8;
  };

  _proto.updateRenderData = function updateRenderData(sprite) {
    var frame = sprite._spriteFrame;
    this.packToDynamicAtlas(sprite, frame);

    if (sprite._vertsDirty) {
      this.updateUVs(sprite);
      this.updateVerts(sprite);
      sprite._vertsDirty = false;
    }
  };

  _proto.updateVerts = function updateVerts(sprite) {
    var node = sprite.node,
        width = node.width,
        height = node.height,
        appx = node.anchorX * width,
        appy = node.anchorY * height;
    var frame = sprite.spriteFrame;
    var leftWidth = frame.insetLeft;
    var rightWidth = frame.insetRight;
    var topHeight = frame.insetTop;
    var bottomHeight = frame.insetBottom;
    var sizableWidth = width - leftWidth - rightWidth;
    var sizableHeight = height - topHeight - bottomHeight;
    var xScale = width / (leftWidth + rightWidth);
    var yScale = height / (topHeight + bottomHeight);
    xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
    yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
    sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
    sizableHeight = sizableHeight < 0 ? 0 : sizableHeight; // update local

    var local = this._local;
    local[0] = -appx;
    local[1] = -appy;
    local[2] = leftWidth * xScale - appx;
    local[3] = bottomHeight * yScale - appy;
    local[4] = local[2] + sizableWidth;
    local[5] = local[3] + sizableHeight;
    local[6] = width - appx;
    local[7] = height - appy;
    this.updateWorldVerts(sprite);
  };

  _proto.updateUVs = function updateUVs(sprite) {
    var verts = this._renderData.vDatas[0];
    var uvSliced = sprite.spriteFrame.uvSliced;
    var uvOffset = this.uvOffset;
    var floatsPerVert = this.floatsPerVert;

    for (var row = 0; row < 4; ++row) {
      for (var col = 0; col < 4; ++col) {
        var vid = row * 4 + col;
        var uv = uvSliced[vid];
        var voffset = vid * floatsPerVert;
        verts[voffset + uvOffset] = uv.u;
        verts[voffset + uvOffset + 1] = uv.v;
      }
    }
  };

  _proto.updateWorldVerts = function updateWorldVerts(sprite) {
    var matrix = sprite.node._worldMatrix;
    var matrixm = matrix.m,
        a = matrixm[0],
        b = matrixm[1],
        c = matrixm[4],
        d = matrixm[5],
        tx = matrixm[12],
        ty = matrixm[13];
    var local = this._local;
    var world = this._renderData.vDatas[0];
    var floatsPerVert = this.floatsPerVert;

    for (var row = 0; row < 4; ++row) {
      var localRowY = local[row * 2 + 1];

      for (var col = 0; col < 4; ++col) {
        var localColX = local[col * 2];
        var worldIndex = (row * 4 + col) * floatsPerVert;
        world[worldIndex] = localColX * a + localRowY * c + tx;
        world[worldIndex + 1] = localColX * b + localRowY * d + ty;
      }
    }
  };

  return SlicedAssembler;
}(_assembler2d["default"]);

exports["default"] = SlicedAssembler;
Object.assign(SlicedAssembler.prototype, {
  verticesCount: 16,
  indicesCount: 54
});
module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXHJlbmRlcmVyXFx3ZWJnbFxcYXNzZW1ibGVyc1xcc3ByaXRlXFwyZFxcc2xpY2VkLmpzIl0sIm5hbWVzIjpbIlNsaWNlZEFzc2VtYmxlciIsImluaXREYXRhIiwic3ByaXRlIiwiX3JlbmRlckRhdGEiLCJtZXNoQ291bnQiLCJjcmVhdGVEYXRhIiwidmVydGljZXNGbG9hdHMiLCJpbmRpY2VzQ291bnQiLCJpbmRpY2VzIiwiaURhdGFzIiwiaW5kZXhPZmZzZXQiLCJyIiwiYyIsInN0YXJ0IiwiaW5pdExvY2FsIiwiX2xvY2FsIiwibGVuZ3RoIiwidXBkYXRlUmVuZGVyRGF0YSIsImZyYW1lIiwiX3Nwcml0ZUZyYW1lIiwicGFja1RvRHluYW1pY0F0bGFzIiwiX3ZlcnRzRGlydHkiLCJ1cGRhdGVVVnMiLCJ1cGRhdGVWZXJ0cyIsIm5vZGUiLCJ3aWR0aCIsImhlaWdodCIsImFwcHgiLCJhbmNob3JYIiwiYXBweSIsImFuY2hvclkiLCJzcHJpdGVGcmFtZSIsImxlZnRXaWR0aCIsImluc2V0TGVmdCIsInJpZ2h0V2lkdGgiLCJpbnNldFJpZ2h0IiwidG9wSGVpZ2h0IiwiaW5zZXRUb3AiLCJib3R0b21IZWlnaHQiLCJpbnNldEJvdHRvbSIsInNpemFibGVXaWR0aCIsInNpemFibGVIZWlnaHQiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJpc05hTiIsImxvY2FsIiwidXBkYXRlV29ybGRWZXJ0cyIsInZlcnRzIiwidkRhdGFzIiwidXZTbGljZWQiLCJ1dk9mZnNldCIsImZsb2F0c1BlclZlcnQiLCJyb3ciLCJjb2wiLCJ2aWQiLCJ1diIsInZvZmZzZXQiLCJ1IiwidiIsIm1hdHJpeCIsIl93b3JsZE1hdHJpeCIsIm1hdHJpeG0iLCJtIiwiYSIsImIiLCJkIiwidHgiLCJ0eSIsIndvcmxkIiwibG9jYWxSb3dZIiwibG9jYWxDb2xYIiwid29ybGRJbmRleCIsIkFzc2VtYmxlcjJEIiwiT2JqZWN0IiwiYXNzaWduIiwicHJv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LENBQWQsQ0FBTCxHQUF3QkQsU0FBUyxHQUFHTixDQUFaLEdBQWdCSyxTQUFTLEdBQUdKLENBQTVCLEdBQWdDRSxFQUF4RDtBQUNIO0FBQ0o7QUFDSjs7O0VBekd3Q0s7OztBQTRHN0NDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjMUUsZUFBZSxDQUFDMkUsU0FBOUIsRUFBeUM7QUFDckNDLEVBQUFBLGFBQWEsRUFBRSxFQURzQjtBQUVyQ3JFLEVBQUFBLFlBQVksRUFBRTtBQUZ1QixDQUF6QyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zLmNvbVxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmltcG9ydCBBc3NlbWJsZXIyRCBmcm9tICcuLi8uLi8uLi8uLi9hc3NlbWJsZXItMmQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpY2VkQXNzZW1ibGVyIGV4dGVuZHMgQXNzZW1ibGVyMkQge1xyXG4gICAgaW5pdERhdGEgKHNwcml0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJEYXRhLm1lc2hDb3VudCA+IDApIHJldHVybjtcclxuICAgICAgICB0aGlzLl9yZW5kZXJEYXRhLmNyZWF0ZURhdGEoMCwgdGhpcy52ZXJ0aWNlc0Zsb2F0cywgdGhpcy5pbmRpY2VzQ291bnQpO1xyXG5cclxuICAgICAgICBsZXQgaW5kaWNlcyA9IHRoaXMuX3JlbmRlckRhdGEuaURhdGFzWzBdO1xyXG4gICAgICAgIGxldCBpbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyArK3IpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCAzOyArK2MpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHIgKiA0ICsgYztcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydDtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0KytdID0gc3RhcnQgKyA0O1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldCsrXSA9IHN0YXJ0ICsgMTtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydCArIDU7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0KytdID0gc3RhcnQgKyA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluaXRMb2NhbCAoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWwgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2NhbC5sZW5ndGggPSA4O1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVJlbmRlckRhdGEgKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBmcmFtZSA9IHNwcml0ZS5fc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgdGhpcy5wYWNrVG9EeW5hbWljQXRsYXMoc3ByaXRlLCBmcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGUuX3ZlcnRzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVVnMoc3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWZXJ0cyhzcHJpdGUpO1xyXG4gICAgICAgICAgICBzcHJpdGUuX3ZlcnRzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVmVydHMgKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBub2RlID0gc3ByaXRlLm5vZGUsXHJcbiAgICAgICAgICAgIHdpZHRoID0gbm9kZS53aWR0aCwgaGVpZ2h0ID0gbm9kZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIGFwcHggPSBub2RlLmFuY2hvclggKiB3aWR0aCwgYXBweSA9IG5vZGUuYW5jaG9yWSAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgbGV0IGZyYW1lID0gc3ByaXRlLnNwcml0ZUZyYW1lO1xyXG4gICAgICAgIGxldCBsZWZ0V2lkdGggPSBmcmFtZS5pbnNldExlZnQ7XHJcbiAgICAgICAgbGV0IHJpZ2h0V2lkdGggPSBmcmFtZS5pbnNldFJpZ2h0O1xyXG4gICAgICAgIGxldCB0b3BIZWlnaHQgPSBmcmFtZS5pbnNldFRvcDtcclxuICAgICAgICBsZXQgYm90dG9tSGVpZ2h0ID0gZnJhbWUuaW5zZXRCb3R0b207XHJcblxyXG4gICAgICAgIGxldCBzaXphYmxlV2lkdGggPSB3aWR0aCAtIGxlZnRXaWR0aCAtIHJpZ2h0V2lkdGg7XHJcbiAgICAgICAgbGV0IHNpemFibGVIZWlnaHQgPSBoZWlnaHQgLSB0b3BIZWlnaHQgLSBib3R0b21IZWlnaHQ7XHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IHdpZHRoIC8gKGxlZnRXaWR0aCArIHJpZ2h0V2lkdGgpO1xyXG4gICAgICAgIGxldCB5U2NhbGUgPSBoZWlnaHQgLyAodG9wSGVpZ2h0ICsgYm90dG9tSGVpZ2h0KTtcclxuICAgICAgICB4U2NhbGUgPSAoaXNOYU4oeFNjYWxlKSB8fCB4U2NhbGUgPiAxKSA/IDEgOiB4U2NhbGU7XHJcbiAgICAgICAgeVNjYWxlID0gKGlzTmFOKHlTY2FsZSkgfHwgeVNjYWxlID4gMSkgPyAxIDogeVNjYWxlO1xyXG4gICAgICAgIHNpemFibGVXaWR0aCA9IHNpemFibGVXaWR0aCA8IDAgPyAwIDogc2l6YWJsZVdpZHRoO1xyXG4gICAgICAgIHNpemFibGVIZWlnaHQgPSBzaXphYmxlSGVpZ2h0IDwgMCA/IDAgOiBzaXphYmxlSGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbG9jYWxcclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICBsb2NhbFswXSA9IC1hcHB4O1xyXG4gICAgICAgIGxvY2FsWzFdID0gLWFwcHk7XHJcbiAgICAgICAgbG9jYWxbMl0gPSBsZWZ0V2lkdGggKiB4U2NhbGUgLSBhcHB4O1xyXG4gICAgICAgIGxvY2FsWzNdID0gYm90dG9tSGVpZ2h0ICogeVNjYWxlIC0gYXBweTtcclxuICAgICAgICBsb2NhbFs0XSA9IGxvY2FsWzJdICsgc2l6YWJsZVdpZHRoO1xyXG4gICAgICAgIGxvY2FsWzVdID0gbG9jYWxbM10gKyBzaXphYmxlSGVpZ2h0O1xyXG4gICAgICAgIGxvY2FsWzZdID0gd2lkdGggLSBhcHB4O1xyXG4gICAgICAgIGxvY2FsWzddID0gaGVpZ2h0IC0gYXBweTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVVZzIChzcHJpdGUpIHtcclxuICAgICAgICBsZXQgdmVydHMgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcclxuICAgICAgICBsZXQgdXZTbGljZWQgPSBzcHJpdGUuc3ByaXRlRnJhbWUudXZTbGljZWQ7XHJcbiAgICAgICAgbGV0IHV2T2Zmc2V0ID0gdGhpcy51dk9mZnNldDtcclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA0OyArK3Jvdykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA0OyArK2NvbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZpZCA9IHJvdyAqIDQgKyBjb2w7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXYgPSB1dlNsaWNlZFt2aWRdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZvZmZzZXQgPSB2aWQgKiBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdm9mZnNldCArIHV2T2Zmc2V0XSA9IHV2LnU7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t2b2Zmc2V0ICsgdXZPZmZzZXQgKyAxXSA9IHV2LnY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlV29ybGRWZXJ0cyAoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IHNwcml0ZS5ub2RlLl93b3JsZE1hdHJpeDtcclxuICAgICAgICBsZXQgbWF0cml4bSA9IG1hdHJpeC5tLFxyXG4gICAgICAgICAgICBhID0gbWF0cml4bVswXSwgYiA9IG1hdHJpeG1bMV0sIGMgPSBtYXRyaXhtWzRdLCBkID0gbWF0cml4bVs1XSxcclxuICAgICAgICAgICAgdHggPSBtYXRyaXhtWzEyXSwgdHkgPSBtYXRyaXhtWzEzXTtcclxuXHJcbiAgICAgICAgbGV0IGxvY2FsID0gdGhpcy5fbG9jYWw7XHJcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5fcmVuZGVyRGF0YS52RGF0YXNbMF07XHJcblxyXG4gICAgICAgIGxldCBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDQ7ICsrcm93KSB7XHJcbiAgICAgICAgICAgIGxldCBsb2NhbFJvd1kgPSBsb2NhbFtyb3cgKiAyICsgMV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDQ7ICsrY29sKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxDb2xYID0gbG9jYWxbY29sICogMl07XHJcbiAgICAgICAgICAgICAgICBsZXQgd29ybGRJbmRleCA9IChyb3cgKiA0ICsgY29sKSAqIGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFt3b3JsZEluZGV4XSA9IGxvY2FsQ29sWCAqIGEgKyBsb2NhbFJvd1kgKiBjICsgdHg7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFt3b3JsZEluZGV4ICsgMV0gPSBsb2NhbENvbFggKiBiICsgbG9jYWxSb3dZICogZCArIHR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKFNsaWNlZEFzc2VtYmxlci5wcm90b3R5cGUsIHtcclxuICAgIHZlcnRpY2VzQ291bnQ6IDE2LFxyXG4gICAgaW5kaWNlc0NvdW50OiA1NFxyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvIn0=