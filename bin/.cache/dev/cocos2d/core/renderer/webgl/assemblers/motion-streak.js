
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/motion-streak.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler2d = _interopRequireDefault(require("../../assembler-2d"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MotionStreak = require('../../../components/CCMotionStreak');

var RenderFlow = require('../../render-flow');

function Point(point, dir) {
  this.point = point || cc.v2();
  this.dir = dir || cc.v2();
  this.distance = 0;
  this.time = 0;
}

Point.prototype.setPoint = function (x, y) {
  this.point.x = x;
  this.point.y = y;
};

Point.prototype.setDir = function (x, y) {
  this.dir.x = x;
  this.dir.y = y;
};

var _tangent = cc.v2();

var _miter = cc.v2();

var _normal = cc.v2();

var _vec2 = cc.v2();

function normal(out, dir) {
  //get perpendicular
  out.x = -dir.y;
  out.y = dir.x;
  return out;
}

function computeMiter(miter, lineA, lineB, halfThick, maxMultiple) {
  //get tangent line
  lineA.add(lineB, _tangent);

  _tangent.normalizeSelf(); //get miter as a unit vector


  miter.x = -_tangent.y;
  miter.y = _tangent.x;
  _vec2.x = -lineA.y;
  _vec2.y = lineA.x; //get the necessary length of our miter

  var multiple = 1 / miter.dot(_vec2);

  if (maxMultiple) {
    multiple = Math.min(multiple, maxMultiple);
  }

  return halfThick * multiple;
}

var MotionStreakAssembler = /*#__PURE__*/function (_Assembler2D) {
  _inheritsLoose(MotionStreakAssembler, _Assembler2D);

  function MotionStreakAssembler() {
    return _Assembler2D.apply(this, arguments) || this;
  }

  var _proto = MotionStreakAssembler.prototype;

  _proto.initData = function initData() {
    this._renderData.createFlexData(0, 16, (16 - 2) * 3);
  };

  _proto.update = function update(comp, dt) {
    if (CC_EDITOR && !comp.preview) return;
    var stroke = comp._stroke / 2;
    var node = comp.node;
    var matrix = node._worldMatrix.m;
    var tx = matrix[12],
        ty = matrix[13];
    var points = comp._points;
    var cur;

    if (points.length > 1) {
      var difx = points[0].point.x - tx;
      var dify = points[0].point.y - ty;

      if (difx * difx + dify * dify < comp.minSeg) {
        cur = points[0];
      }
    }

    if (!cur) {
      cur = new Point();
      points.splice(0, 0, cur);
    }

    cur.setPoint(tx, ty);
    cur.time = comp._fadeTime + dt;
    var verticesCount = 0;
    var indicesCount = 0;

    if (points.length < 2) {
      return;
    }

    var color = comp._color,
        cr = color.r,
        cg = color.g,
        cb = color.b,
        ca = color.a;
    var prev = points[1];
    prev.distance = cur.point.sub(prev.point, _vec2).mag();

    _vec2.normalizeSelf();

    prev.setDir(_vec2.x, _vec2.y);
    cur.setDir(_vec2.x, _vec2.y);
    var flexBuffer = this._renderData._flexBuffer;
    flexBuffer.reserve(points.length * 2, (points.length - 1) * 6);
    var vData = flexBuffer.vData;
    var uintVData = flexBuffer.uintVData;
    var vertsOffset = 5;
    var fadeTime = comp._fadeTime;
    var findLast = false;

    for (var i = points.length - 1; i >= 0; i--) {
      var p = points[i];
      var point = p.point;
      var dir = p.dir;
      p.time -= dt;

      if (p.time < 0) {
        points.splice(i, 1);
        continue;
      }

      var progress = p.time / fadeTime;
      var next = points[i - 1];

      if (!findLast) {
        if (!next) {
          points.splice(i, 1);
          continue;
        }

        point.x = next.point.x - dir.x * progress;
        point.y = next.point.y - dir.y * progress;
      }

      findLast = true;
      normal(_normal, dir);
      var da = progress * ca;
      var c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
      var offset = verticesCount * vertsOffset;
      vData[offset] = point.x + _normal.x * stroke;
      vData[offset + 1] = point.y + _normal.y * stroke;
      vData[offset + 2] = 1;
      vData[offset + 3] = progress;
      uintVData[offset + 4] = c;
      offset += vertsOffset;
      vData[offset] = point.x - _normal.x * stroke;
      vData[offset + 1] = point.y - _normal.y * stroke;
      vData[offset + 2] = 0;
      vData[offset + 3] = progress;
      uintVData[offset + 4] = c;
      verticesCount += 2;
    }

    indicesCount = verticesCount <= 2 ? 0 : (verticesCount - 2) * 3;
    flexBuffer.used(verticesCount, indicesCount);
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    var _this$_renderData$_fl = this._renderData._flexBuffer,
        vData = _this$_renderData$_fl.vData,
        usedVertices = _this$_renderData$_fl.usedVertices,
        usedIndices = _this$_renderData$_fl.usedIndices,
        usedVerticesFloats = _this$_renderData$_fl.usedVerticesFloats;
    var buffer = renderer._meshBuffer;
    var offsetInfo = buffer.request(usedVertices, usedIndices); // buffer data may be realloc, need get reference after request.
    // fill vertices

    var vertexOffset = offsetInfo.byteOffset >> 2,
        vbuf = buffer._vData;

    if (vData.length + vertexOffset > vbuf.length) {
      vbuf.set(vData.subarray(0, usedVerticesFloats), vertexOffset);
    } else {
      vbuf.set(vData, vertexOffset);
    } // fill indices


    var ibuf = buffer._iData,
        indiceOffset = offsetInfo.indiceOffset,
        vertexId = offsetInfo.vertexOffset; // index buffer

    for (var i = 0, l = usedVertices; i < l; i += 2) {
      var start = vertexId + i;
      ibuf[indiceOffset++] = start;
      ibuf[indiceOffset++] = start + 2;
      ibuf[indiceOffset++] = start + 1;
      ibuf[indiceOffset++] = start + 1;
      ibuf[indiceOffset++] = start + 2;
      ibuf[indiceOffset++] = start + 3;
    }

    comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
  };

  return MotionStreakAssembler;
}(_assembler2d["default"]);

exports["default"] = MotionStreakAssembler;
MotionStreakAssembler.register(MotionStreak, MotionStreakAssembler);
module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGNvY29zMmRcXGNvcmVcXHJlbmRlcmVyXFx3ZWJnbFxcYXNzZW1ibGVyc1xcbW90aW9uLXN0cmVhay5qcyJdLCJuYW1lcyI6WyJNb3Rpb25TdHJlYWsiLCJyZXF1aXJlIiwiUmVuZGVyRmxvdyIsIlBvaW50IiwicG9pbnQiLCJkaXIiLCJjYyIsInYyIiwiZGlzdGFuY2UiLCJ0aW1lIiwicHJvdG90eXBlIiwic2V0UG9pbnQiLCJ4IiwieSIsInNldERpciIsIl90YW5nZW50IiwiX21pdGVyIiwiX25vcm1hbCIsIl92ZWMyIiwibm9ybWFsIiwib3V0IiwiY29tcHV0ZU1pdGVyIiwibWl0ZXIiLCJsaW5lQSIsImxpbmVCIiwiaGFsZlRoaWNrIiwibWF4TXVsdGlwbGUiLCJhZGQiLCJub3JtYWxpemVTZWxmIiwibXVsdGlwbGUiLCJkb3QiLCJNYXRoIiwibWluIiwiTW90aW9uU3RyZWFrQXNzZW1ibGVyIiwiaW5pdERhdGEiLCJfcmVuZGVyRGF0YSIsImNyZWF0ZUZsZXhEYXRhIiwidXBkYXRlIiwiY29tcCIsImR0IiwiQ0NfRURJVE9SIiwicHJldmlldyIsInN0cm9rZSIsIl9zdHJva2UiLCJub2RlIiwibWF0cml4IiwiX3dvcmxkTWF0cml4IiwibSIsInR4IiwidHkiLCJwb2ludHMiLCJfcG9pbnRzIiwiY3VyIiwibGVuZ3RoIiwiZGlmeCIsImRpZnkiLCJtaW5TZWciLCJzcGxpY2UiLCJfZmFkZVRpbWUiLCJ2ZXJ0aWNlc0NvdW50IiwiaW5kaWNlc0NvdW50IiwiY29sb3IiLCJfY29sb3IiLCJjciIsInIiLCJjZyIsImciLCJjYiIsImIiLCJjYSIsImEiLCJwcmV2Iiwic3ViIiwibWFnIiwiZmxleEJ1ZmZlciIsIl9mbGV4QnVmZmVyIiwicmVzZXJ2ZSIsInZEYXRhIiwidWludFZEYXRhIiwidmVydHNPZmZzZXQiLCJmYWRlVGltZSIsImZpbmRMYXN0IiwiaSIsInAiLCJwcm9ncmVzcyIsIm5leHQiLCJkYSIsImMiLCJvZmZzZXQiLCJ1c2VkIiwiZmlsbEJ1ZmZlcnMiLCJyZW5kZXJlciIsInVzZWRWZXJ0aWNlcyIsInVzZWRJbmRpY2VzIiwidXNlZFZlcnRpY2VzRmxvYXRzIiwiYnVmZmVyIiwiX21lc2hCdWZmZXIiLCJvZmZzZXRJbmZvIiwicmVxdWVzdCIsInZlcnRleE9mZnNldCIsImJ5dGVPZmZzZXQiLCJ2YnVmIiwiX3ZEYXRhIiwic2V0Iiwic3ViYXJyYXkiLCJpYnVmIiwiX2lEYXRhIiwiaW5kaWNlT2Zmc2V0IiwidmVydGV4SWQiLCJsIiwic3RhcnQiLCJfcmVuZGVyRmxhZyIsIkZMQUdfVVBEQVRFX1JFTkRFUl9EQVRBIiwiQXNzZW1ibGVyMkQiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZLEdBQUdDLE9BQU8sQ0FBQyxvQ0FBRCxDQUE1Qjs7QUFDQSxJQUFNQyxVQUFVLEdBQUdELE9BQU8sQ0FBQyxtQkFBRCxDQUExQjs7QUFFQSxTQUFTRSxLQUFULENBQWdCQyxLQUFoQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsT0FBS0QsS0FBTCxHQUFhQSxLQUFLLElBQUlFLEVBQUUsQ0FBQ0MsRUFBSCxFQUF0QjtBQUNBLE9BQUtGLEdBQUwsR0FBV0EsR0FBRyxJQUFJQyxFQUFFLENBQUNDLEVBQUgsRUFBbEI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsT0FBS0MsSUFBTCxHQUFZLENBQVo7QUFDSDs7QUFFRE4sS0FBSyxDQUFDTyxTQUFOLENBQWdCQyxRQUFoQixHQUEyQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDdkMsT0FBS1QsS0FBTCxDQUFXUSxDQUFYLEdBQWVBLENBQWY7QUFDQSxPQUFLUixLQUFMLENBQVdTLENBQVgsR0FBZUEsQ0FBZjtBQUNILENBSEQ7O0FBS0FWLEtBQUssQ0FBQ08sU0FBTixDQUFnQkksTUFBaEIsR0FBeUIsVUFBVUYsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3JDLE9BQUtSLEdBQUwsQ0FBU08sQ0FBVCxHQUFhQSxDQUFiO0FBQ0EsT0FBS1AsR0FBTCxDQUFTUSxDQUFULEdBQWFBLENBQWI7QUFDSCxDQUhEOztBQUtBLElBQUlFLFFBQVEsR0FBR1QsRUFBRSxDQUFDQyxFQUFILEVBQWY7O0FBQ0EsSUFBSVMsTUFBTSxHQUFHVixFQUFFLENBQUNDLEVBQUgsRUFBYjs7QUFDQSxJQUFJVSxPQUFPLEdBQUdYLEVBQUUsQ0FBQ0MsRUFBSCxFQUFkOztBQUNBLElBQUlXLEtBQUssR0FBR1osRUFBRSxDQUFDQyxFQUFILEVBQVo7O0FBRUEsU0FBU1ksTUFBVCxDQUFpQkMsR0FBakIsRUFBc0JmLEdBQXRCLEVBQTJCO0FBQ3ZCO0FBQ0FlLEVBQUFBLEdBQUcsQ0FBQ1IsQ0FBSixHQUFRLENBQUNQLEdBQUcsQ0FBQ1EsQ0FBYjtBQUNBTyxFQUFBQSxHQUFHLENBQUNQLENBQUosR0FBUVIsR0FBRyxDQUFDTyxDQUFaO0FBQ0EsU0FBT1EsR0FBUDtBQUNIOztBQUVELFNBQVNDLFlBQVQsQ0FBdUJDLEtBQXZCLEVBQThCQyxLQUE5QixFQUFxQ0MsS0FBckMsRUFBNENDLFNBQTVDLEVBQXVEQyxXQUF2RCxFQUFvRTtBQUNoRTtBQUNBSCxFQUFBQSxLQUFLLENBQUNJLEdBQU4sQ0FBVUgsS0FBVixFQUFpQlQsUUFBakI7O0FBQ0FBLEVBQUFBLFFBQVEsQ0FBQ2EsYUFBVCxHQUhnRSxDQUtoRTs7O0FBQ0FOLEVBQUFBLEtBQUssQ0FBQ1YsQ0FBTixHQUFVLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBcEI7QUFDQVMsRUFBQUEsS0FBSyxDQUFDVCxDQUFOLEdBQVVFLFFBQVEsQ0FBQ0gsQ0FBbkI7QUFDQU0sRUFBQUEsS0FBSyxDQUFDTixDQUFOLEdBQVUsQ0FBQ1csS0FBSyxDQUFDVixDQUFqQjtBQUNBSyxFQUFBQSxLQUFLLENBQUNMLENBQU4sR0FBVVUsS0FBSyxDQUFDWCxDQUFoQixDQVRnRSxDQVdoRTs7QUFDQSxNQUFJaUIsUUFBUSxHQUFHLElBQUlQLEtBQUssQ0FBQ1EsR0FBTixDQUFVWixLQUFWLENBQW5COztBQUNBLE1BQUlRLFdBQUosRUFBaUI7QUFDYkcsSUFBQUEsUUFBUSxHQUFHRSxJQUFJLENBQUNDLEdBQUwsQ0FBU0gsUUFBVCxFQUFtQkgsV0FBbkIsQ0FBWDtBQUNIOztBQUNELFNBQU9ELFNBQVMsR0FBR0ksUUFBbkI7QUFDSDs7SUFFb0JJOzs7Ozs7Ozs7U0FDakJDLFdBQUEsb0JBQVk7QUFDUixTQUFLQyxXQUFMLENBQWlCQyxjQUFqQixDQUFnQyxDQUFoQyxFQUFtQyxFQUFuQyxFQUF1QyxDQUFDLEtBQUssQ0FBTixJQUFXLENBQWxEO0FBQ0g7O1NBRURDLFNBQUEsZ0JBQVFDLElBQVIsRUFBY0MsRUFBZCxFQUFrQjtBQUNkLFFBQUlDLFNBQVMsSUFBSSxDQUFDRixJQUFJLENBQUNHLE9BQXZCLEVBQWdDO0FBRWhDLFFBQUlDLE1BQU0sR0FBR0osSUFBSSxDQUFDSyxPQUFMLEdBQWUsQ0FBNUI7QUFFQSxRQUFJQyxJQUFJLEdBQUdOLElBQUksQ0FBQ00sSUFBaEI7QUFDQSxRQUFJQyxNQUFNLEdBQUdELElBQUksQ0FBQ0UsWUFBTCxDQUFrQkMsQ0FBL0I7QUFDQSxRQUFJQyxFQUFFLEdBQUdILE1BQU0sQ0FBQyxFQUFELENBQWY7QUFBQSxRQUFxQkksRUFBRSxHQUFHSixNQUFNLENBQUMsRUFBRCxDQUFoQztBQUVBLFFBQUlLLE1BQU0sR0FBR1osSUFBSSxDQUFDYSxPQUFsQjtBQUVBLFFBQUlDLEdBQUo7O0FBQ0EsUUFBSUYsTUFBTSxDQUFDRyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLFVBQUlDLElBQUksR0FBR0osTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVOUMsS0FBVixDQUFnQlEsQ0FBaEIsR0FBb0JvQyxFQUEvQjtBQUNBLFVBQUlPLElBQUksR0FBR0wsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVOUMsS0FBVixDQUFnQlMsQ0FBaEIsR0FBb0JvQyxFQUEvQjs7QUFDQSxVQUFLSyxJQUFJLEdBQUNBLElBQUwsR0FBWUMsSUFBSSxHQUFDQSxJQUFsQixHQUEwQmpCLElBQUksQ0FBQ2tCLE1BQW5DLEVBQTJDO0FBQ3ZDSixRQUFBQSxHQUFHLEdBQUdGLE1BQU0sQ0FBQyxDQUFELENBQVo7QUFDSDtBQUNKOztBQUVELFFBQUksQ0FBQ0UsR0FBTCxFQUFVO0FBQ05BLE1BQUFBLEdBQUcsR0FBRyxJQUFJakQsS0FBSixFQUFOO0FBQ0ErQyxNQUFBQSxNQUFNLENBQUNPLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CTCxHQUFwQjtBQUNIOztBQUVEQSxJQUFBQSxHQUFHLENBQUN6QyxRQUFKLENBQWFxQyxFQUFiLEVBQWlCQyxFQUFqQjtBQUNBRyxJQUFBQSxHQUFHLENBQUMzQyxJQUFKLEdBQVc2QixJQUFJLENBQUNvQixTQUFMLEdBQWlCbkIsRUFBNUI7QUFFQSxRQUFJb0IsYUFBYSxHQUFHLENBQXBCO0FBQ0EsUUFBSUMsWUFBWSxHQUFHLENBQW5COztBQUVBLFFBQUlWLE1BQU0sQ0FBQ0csTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNuQjtBQUNIOztBQUVELFFBQUlRLEtBQUssR0FBR3ZCLElBQUksQ0FBQ3dCLE1BQWpCO0FBQUEsUUFDSUMsRUFBRSxHQUFHRixLQUFLLENBQUNHLENBRGY7QUFBQSxRQUNrQkMsRUFBRSxHQUFHSixLQUFLLENBQUNLLENBRDdCO0FBQUEsUUFDZ0NDLEVBQUUsR0FBR04sS0FBSyxDQUFDTyxDQUQzQztBQUFBLFFBQzhDQyxFQUFFLEdBQUdSLEtBQUssQ0FBQ1MsQ0FEekQ7QUFHQSxRQUFJQyxJQUFJLEdBQUdyQixNQUFNLENBQUMsQ0FBRCxDQUFqQjtBQUNBcUIsSUFBQUEsSUFBSSxDQUFDL0QsUUFBTCxHQUFnQjRDLEdBQUcsQ0FBQ2hELEtBQUosQ0FBVW9FLEdBQVYsQ0FBY0QsSUFBSSxDQUFDbkUsS0FBbkIsRUFBMEJjLEtBQTFCLEVBQWlDdUQsR0FBakMsRUFBaEI7O0FBQ0F2RCxJQUFBQSxLQUFLLENBQUNVLGFBQU47O0FBQ0EyQyxJQUFBQSxJQUFJLENBQUN6RCxNQUFMLENBQVlJLEtBQUssQ0FBQ04sQ0FBbEIsRUFBcUJNLEtBQUssQ0FBQ0wsQ0FBM0I7QUFDQXVDLElBQUFBLEdBQUcsQ0FBQ3RDLE1BQUosQ0FBV0ksS0FBSyxDQUFDTixDQUFqQixFQUFvQk0sS0FBSyxDQUFDTCxDQUExQjtBQUVBLFFBQUk2RCxVQUFVLEdBQUcsS0FBS3ZDLFdBQUwsQ0FBaUJ3QyxXQUFsQztBQUNBRCxJQUFBQSxVQUFVLENBQUNFLE9BQVgsQ0FBbUIxQixNQUFNLENBQUNHLE1BQVAsR0FBYyxDQUFqQyxFQUFvQyxDQUFDSCxNQUFNLENBQUNHLE1BQVAsR0FBYyxDQUFmLElBQWtCLENBQXREO0FBQ0EsUUFBSXdCLEtBQUssR0FBR0gsVUFBVSxDQUFDRyxLQUF2QjtBQUNBLFFBQUlDLFNBQVMsR0FBR0osVUFBVSxDQUFDSSxTQUEzQjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxDQUFsQjtBQUVBLFFBQUlDLFFBQVEsR0FBRzFDLElBQUksQ0FBQ29CLFNBQXBCO0FBQ0EsUUFBSXVCLFFBQVEsR0FBRyxLQUFmOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHaEMsTUFBTSxDQUFDRyxNQUFQLEdBQWdCLENBQTdCLEVBQWdDNkIsQ0FBQyxJQUFHLENBQXBDLEVBQXdDQSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDLFVBQUlDLENBQUMsR0FBR2pDLE1BQU0sQ0FBQ2dDLENBQUQsQ0FBZDtBQUNBLFVBQUk5RSxLQUFLLEdBQUcrRSxDQUFDLENBQUMvRSxLQUFkO0FBQ0EsVUFBSUMsR0FBRyxHQUFHOEUsQ0FBQyxDQUFDOUUsR0FBWjtBQUNBOEUsTUFBQUEsQ0FBQyxDQUFDMUUsSUFBRixJQUFVOEIsRUFBVjs7QUFFQSxVQUFJNEMsQ0FBQyxDQUFDMUUsSUFBRixHQUFTLENBQWIsRUFBZ0I7QUFDWnlDLFFBQUFBLE1BQU0sQ0FBQ08sTUFBUCxDQUFjeUIsQ0FBZCxFQUFpQixDQUFqQjtBQUNBO0FBQ0g7O0FBRUQsVUFBSUUsUUFBUSxHQUFHRCxDQUFDLENBQUMxRSxJQUFGLEdBQVN1RSxRQUF4QjtBQUVBLFVBQUlLLElBQUksR0FBR25DLE1BQU0sQ0FBQ2dDLENBQUMsR0FBRyxDQUFMLENBQWpCOztBQUNBLFVBQUksQ0FBQ0QsUUFBTCxFQUFlO0FBQ1gsWUFBSSxDQUFDSSxJQUFMLEVBQVc7QUFDUG5DLFVBQUFBLE1BQU0sQ0FBQ08sTUFBUCxDQUFjeUIsQ0FBZCxFQUFpQixDQUFqQjtBQUNBO0FBQ0g7O0FBRUQ5RSxRQUFBQSxLQUFLLENBQUNRLENBQU4sR0FBVXlFLElBQUksQ0FBQ2pGLEtBQUwsQ0FBV1EsQ0FBWCxHQUFlUCxHQUFHLENBQUNPLENBQUosR0FBUXdFLFFBQWpDO0FBQ0FoRixRQUFBQSxLQUFLLENBQUNTLENBQU4sR0FBVXdFLElBQUksQ0FBQ2pGLEtBQUwsQ0FBV1MsQ0FBWCxHQUFlUixHQUFHLENBQUNRLENBQUosR0FBUXVFLFFBQWpDO0FBQ0g7O0FBQ0RILE1BQUFBLFFBQVEsR0FBRyxJQUFYO0FBRUE5RCxNQUFBQSxNQUFNLENBQUNGLE9BQUQsRUFBVVosR0FBVixDQUFOO0FBR0EsVUFBSWlGLEVBQUUsR0FBR0YsUUFBUSxHQUFDZixFQUFsQjtBQUNBLFVBQUlrQixDQUFDLEdBQUcsQ0FBRUQsRUFBRSxJQUFFLEVBQUwsS0FBYSxDQUFkLEtBQW9CbkIsRUFBRSxJQUFFLEVBQXhCLEtBQStCRixFQUFFLElBQUUsQ0FBbkMsSUFBd0NGLEVBQWhEO0FBRUEsVUFBSXlCLE1BQU0sR0FBRzdCLGFBQWEsR0FBR29CLFdBQTdCO0FBRUFGLE1BQUFBLEtBQUssQ0FBQ1csTUFBRCxDQUFMLEdBQWdCcEYsS0FBSyxDQUFDUSxDQUFOLEdBQVVLLE9BQU8sQ0FBQ0wsQ0FBUixHQUFZOEIsTUFBdEM7QUFDQW1DLE1BQUFBLEtBQUssQ0FBQ1csTUFBTSxHQUFHLENBQVYsQ0FBTCxHQUFvQnBGLEtBQUssQ0FBQ1MsQ0FBTixHQUFVSSxPQUFPLENBQUNKLENBQVIsR0FBWTZCLE1BQTFDO0FBQ0FtQyxNQUFBQSxLQUFLLENBQUNXLE1BQU0sR0FBRyxDQUFWLENBQUwsR0FBb0IsQ0FBcEI7QUFDQVgsTUFBQUEsS0FBSyxDQUFDVyxNQUFNLEdBQUcsQ0FBVixDQUFMLEdBQW9CSixRQUFwQjtBQUNBTixNQUFBQSxTQUFTLENBQUNVLE1BQU0sR0FBRyxDQUFWLENBQVQsR0FBd0JELENBQXhCO0FBRUFDLE1BQUFBLE1BQU0sSUFBSVQsV0FBVjtBQUVBRixNQUFBQSxLQUFLLENBQUNXLE1BQUQsQ0FBTCxHQUFnQnBGLEtBQUssQ0FBQ1EsQ0FBTixHQUFVSyxPQUFPLENBQUNMLENBQVIsR0FBWThCLE1BQXRDO0FBQ0FtQyxNQUFBQSxLQUFLLENBQUNXLE1BQU0sR0FBRyxDQUFWLENBQUwsR0FBb0JwRixLQUFLLENBQUNTLENBQU4sR0FBVUksT0FBTyxDQUFDSixDQUFSLEdBQVk2QixNQUExQztBQUNBbUMsTUFBQUEsS0FBSyxDQUFDVyxNQUFNLEdBQUcsQ0FBVixDQUFMLEdBQW9CLENBQXBCO0FBQ0FYLE1BQUFBLEtBQUssQ0FBQ1csTUFBTSxHQUFHLENBQVYsQ0FBTCxHQUFvQkosUUFBcEI7QUFDQU4sTUFBQUEsU0FBUyxDQUFDVSxNQUFNLEdBQUcsQ0FBVixDQUFULEdBQXdCRCxDQUF4QjtBQUVBNUIsTUFBQUEsYUFBYSxJQUFJLENBQWpCO0FBQ0g7O0FBRURDLElBQUFBLFlBQVksR0FBR0QsYUFBYSxJQUFJLENBQWpCLEdBQXFCLENBQXJCLEdBQXlCLENBQUNBLGFBQWEsR0FBRyxDQUFqQixJQUFvQixDQUE1RDtBQUVBZSxJQUFBQSxVQUFVLENBQUNlLElBQVgsQ0FBZ0I5QixhQUFoQixFQUErQkMsWUFBL0I7QUFDSDs7U0FFRDhCLGNBQUEscUJBQWFwRCxJQUFiLEVBQW1CcUQsUUFBbkIsRUFBNkI7QUFBQSxnQ0FDc0MsS0FBS3hELFdBQUwsQ0FBaUJ3QyxXQUR2RDtBQUFBLFFBQ25CRSxLQURtQix5QkFDbkJBLEtBRG1CO0FBQUEsUUFDWmUsWUFEWSx5QkFDWkEsWUFEWTtBQUFBLFFBQ0VDLFdBREYseUJBQ0VBLFdBREY7QUFBQSxRQUNlQyxrQkFEZix5QkFDZUEsa0JBRGY7QUFHekIsUUFBSUMsTUFBTSxHQUFHSixRQUFRLENBQUNLLFdBQXRCO0FBQ0EsUUFBSUMsVUFBVSxHQUFHRixNQUFNLENBQUNHLE9BQVAsQ0FBZU4sWUFBZixFQUE2QkMsV0FBN0IsQ0FBakIsQ0FKeUIsQ0FNekI7QUFFQTs7QUFDQSxRQUFJTSxZQUFZLEdBQUdGLFVBQVUsQ0FBQ0csVUFBWCxJQUF5QixDQUE1QztBQUFBLFFBQ0lDLElBQUksR0FBR04sTUFBTSxDQUFDTyxNQURsQjs7QUFHQSxRQUFJekIsS0FBSyxDQUFDeEIsTUFBTixHQUFlOEMsWUFBZixHQUE4QkUsSUFBSSxDQUFDaEQsTUFBdkMsRUFBK0M7QUFDM0NnRCxNQUFBQSxJQUFJLENBQUNFLEdBQUwsQ0FBUzFCLEtBQUssQ0FBQzJCLFFBQU4sQ0FBZSxDQUFmLEVBQWtCVixrQkFBbEIsQ0FBVCxFQUFnREssWUFBaEQ7QUFDSCxLQUZELE1BR0s7QUFDREUsTUFBQUEsSUFBSSxDQUFDRSxHQUFMLENBQVMxQixLQUFULEVBQWdCc0IsWUFBaEI7QUFDSCxLQWpCd0IsQ0FtQnpCOzs7QUFDQSxRQUFJTSxJQUFJLEdBQUdWLE1BQU0sQ0FBQ1csTUFBbEI7QUFBQSxRQUNJQyxZQUFZLEdBQUdWLFVBQVUsQ0FBQ1UsWUFEOUI7QUFBQSxRQUVJQyxRQUFRLEdBQUdYLFVBQVUsQ0FBQ0UsWUFGMUIsQ0FwQnlCLENBd0J6Qjs7QUFDQSxTQUFLLElBQUlqQixDQUFDLEdBQUcsQ0FBUixFQUFXMkIsQ0FBQyxHQUFHakIsWUFBcEIsRUFBa0NWLENBQUMsR0FBRzJCLENBQXRDLEVBQXlDM0IsQ0FBQyxJQUFJLENBQTlDLEVBQWlEO0FBQzdDLFVBQUk0QixLQUFLLEdBQUdGLFFBQVEsR0FBRzFCLENBQXZCO0FBQ0F1QixNQUFBQSxJQUFJLENBQUNFLFlBQVksRUFBYixDQUFKLEdBQXVCRyxLQUF2QjtBQUNBTCxNQUFBQSxJQUFJLENBQUNFLFlBQVksRUFBYixDQUFKLEdBQXVCRyxLQUFLLEdBQUcsQ0FBL0I7QUFDQUwsTUFBQUEsSUFBSSxDQUFDRSxZQUFZLEVBQWIsQ0FBSixHQUF1QkcsS0FBSyxHQUFHLENBQS9CO0FBQ0FMLE1BQUFBLElBQUksQ0FBQ0UsWUFBWSxFQUFiLENBQUosR0FBdUJHLEtBQUssR0FBRyxDQUEvQjtBQUNBTCxNQUFBQSxJQUFJLENBQUNFLFlBQVksRUFBYixDQUFKLEdBQXVCRyxLQUFLLEdBQUcsQ0FBL0I7QUFDQUwsTUFBQUEsSUFBSSxDQUFDRSxZQUFZLEVBQWIsQ0FBSixHQUF1QkcsS0FBSyxHQUFHLENBQS9CO0FBQ0g7O0FBRUR4RSxJQUFBQSxJQUFJLENBQUNNLElBQUwsQ0FBVW1FLFdBQVYsSUFBeUI3RyxVQUFVLENBQUM4Ryx1QkFBcEM7QUFDSDs7O0VBcEo4Q0M7OztBQXVKbkRoRixxQkFBcUIsQ0FBQ2lGLFFBQXRCLENBQStCbEgsWUFBL0IsRUFBNkNpQyxxQkFBN0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXHJcblxyXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmltcG9ydCBBc3NlbWJsZXIyRCBmcm9tICcuLi8uLi9hc3NlbWJsZXItMmQnO1xyXG5cclxuY29uc3QgTW90aW9uU3RyZWFrID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9DQ01vdGlvblN0cmVhaycpO1xyXG5jb25zdCBSZW5kZXJGbG93ID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyLWZsb3cnKTtcclxuXHJcbmZ1bmN0aW9uIFBvaW50IChwb2ludCwgZGlyKSB7XHJcbiAgICB0aGlzLnBvaW50ID0gcG9pbnQgfHwgY2MudjIoKTtcclxuICAgIHRoaXMuZGlyID0gZGlyIHx8IGNjLnYyKCk7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcclxuICAgIHRoaXMudGltZSA9IDA7XHJcbn1cclxuXHJcblBvaW50LnByb3RvdHlwZS5zZXRQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICB0aGlzLnBvaW50LnggPSB4O1xyXG4gICAgdGhpcy5wb2ludC55ID0geTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5zZXREaXIgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdGhpcy5kaXIueCA9IHg7XHJcbiAgICB0aGlzLmRpci55ID0geTtcclxufTtcclxuXHJcbmxldCBfdGFuZ2VudCA9IGNjLnYyKCk7XHJcbmxldCBfbWl0ZXIgPSBjYy52MigpO1xyXG5sZXQgX25vcm1hbCA9IGNjLnYyKCk7XHJcbmxldCBfdmVjMiA9IGNjLnYyKCk7XHJcblxyXG5mdW5jdGlvbiBub3JtYWwgKG91dCwgZGlyKSB7XHJcbiAgICAvL2dldCBwZXJwZW5kaWN1bGFyXHJcbiAgICBvdXQueCA9IC1kaXIueTtcclxuICAgIG91dC55ID0gZGlyLng7XHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVNaXRlciAobWl0ZXIsIGxpbmVBLCBsaW5lQiwgaGFsZlRoaWNrLCBtYXhNdWx0aXBsZSkge1xyXG4gICAgLy9nZXQgdGFuZ2VudCBsaW5lXHJcbiAgICBsaW5lQS5hZGQobGluZUIsIF90YW5nZW50KTtcclxuICAgIF90YW5nZW50Lm5vcm1hbGl6ZVNlbGYoKTtcclxuXHJcbiAgICAvL2dldCBtaXRlciBhcyBhIHVuaXQgdmVjdG9yXHJcbiAgICBtaXRlci54ID0gLV90YW5nZW50Lnk7XHJcbiAgICBtaXRlci55ID0gX3RhbmdlbnQueDtcclxuICAgIF92ZWMyLnggPSAtbGluZUEueTsgXHJcbiAgICBfdmVjMi55ID0gbGluZUEueDtcclxuXHJcbiAgICAvL2dldCB0aGUgbmVjZXNzYXJ5IGxlbmd0aCBvZiBvdXIgbWl0ZXJcclxuICAgIGxldCBtdWx0aXBsZSA9IDEgLyBtaXRlci5kb3QoX3ZlYzIpO1xyXG4gICAgaWYgKG1heE11bHRpcGxlKSB7XHJcbiAgICAgICAgbXVsdGlwbGUgPSBNYXRoLm1pbihtdWx0aXBsZSwgbWF4TXVsdGlwbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbGZUaGljayAqIG11bHRpcGxlO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3Rpb25TdHJlYWtBc3NlbWJsZXIgZXh0ZW5kcyBBc3NlbWJsZXIyRCB7XHJcbiAgICBpbml0RGF0YSAoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyRGF0YS5jcmVhdGVGbGV4RGF0YSgwLCAxNiwgKDE2IC0gMikgKiAzKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgKGNvbXAsIGR0KSB7XHJcbiAgICAgICAgaWYgKENDX0VESVRPUiAmJiAhY29tcC5wcmV2aWV3KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBzdHJva2UgPSBjb21wLl9zdHJva2UgLyAyO1xyXG5cclxuICAgICAgICBsZXQgbm9kZSA9IGNvbXAubm9kZTtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbm9kZS5fd29ybGRNYXRyaXgubTtcclxuICAgICAgICBsZXQgdHggPSBtYXRyaXhbMTJdLCB0eSA9IG1hdHJpeFsxM107XHJcblxyXG4gICAgICAgIGxldCBwb2ludHMgPSBjb21wLl9wb2ludHM7XHJcblxyXG4gICAgICAgIGxldCBjdXI7XHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxldCBkaWZ4ID0gcG9pbnRzWzBdLnBvaW50LnggLSB0eDtcclxuICAgICAgICAgICAgbGV0IGRpZnkgPSBwb2ludHNbMF0ucG9pbnQueSAtIHR5O1xyXG4gICAgICAgICAgICBpZiAoKGRpZngqZGlmeCArIGRpZnkqZGlmeSkgPCBjb21wLm1pblNlZykge1xyXG4gICAgICAgICAgICAgICAgY3VyID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWN1cikge1xyXG4gICAgICAgICAgICBjdXIgPSBuZXcgUG9pbnQoKTtcclxuICAgICAgICAgICAgcG9pbnRzLnNwbGljZSgwLCAwLCBjdXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VyLnNldFBvaW50KHR4LCB0eSk7XHJcbiAgICAgICAgY3VyLnRpbWUgPSBjb21wLl9mYWRlVGltZSArIGR0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB2ZXJ0aWNlc0NvdW50ID0gMDtcclxuICAgICAgICBsZXQgaW5kaWNlc0NvdW50ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2xvciA9IGNvbXAuX2NvbG9yLFxyXG4gICAgICAgICAgICBjciA9IGNvbG9yLnIsIGNnID0gY29sb3IuZywgY2IgPSBjb2xvci5iLCBjYSA9IGNvbG9yLmE7XHJcblxyXG4gICAgICAgIGxldCBwcmV2ID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHByZXYuZGlzdGFuY2UgPSBjdXIucG9pbnQuc3ViKHByZXYucG9pbnQsIF92ZWMyKS5tYWcoKTtcclxuICAgICAgICBfdmVjMi5ub3JtYWxpemVTZWxmKCk7XHJcbiAgICAgICAgcHJldi5zZXREaXIoX3ZlYzIueCwgX3ZlYzIueSk7XHJcbiAgICAgICAgY3VyLnNldERpcihfdmVjMi54LCBfdmVjMi55KTtcclxuXHJcbiAgICAgICAgbGV0IGZsZXhCdWZmZXIgPSB0aGlzLl9yZW5kZXJEYXRhLl9mbGV4QnVmZmVyO1xyXG4gICAgICAgIGZsZXhCdWZmZXIucmVzZXJ2ZShwb2ludHMubGVuZ3RoKjIsIChwb2ludHMubGVuZ3RoLTEpKjYpO1xyXG4gICAgICAgIGxldCB2RGF0YSA9IGZsZXhCdWZmZXIudkRhdGE7XHJcbiAgICAgICAgbGV0IHVpbnRWRGF0YSA9IGZsZXhCdWZmZXIudWludFZEYXRhO1xyXG4gICAgICAgIGxldCB2ZXJ0c09mZnNldCA9IDU7XHJcblxyXG4gICAgICAgIGxldCBmYWRlVGltZSA9IGNvbXAuX2ZhZGVUaW1lO1xyXG4gICAgICAgIGxldCBmaW5kTGFzdCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PTAgOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHAucG9pbnQ7XHJcbiAgICAgICAgICAgIGxldCBkaXIgPSBwLmRpcjtcclxuICAgICAgICAgICAgcC50aW1lIC09IGR0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHAudGltZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gcC50aW1lIC8gZmFkZVRpbWU7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IHBvaW50c1tpIC0gMV07XHJcbiAgICAgICAgICAgIGlmICghZmluZExhc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHBvaW50LnggPSBuZXh0LnBvaW50LnggLSBkaXIueCAqIHByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IG5leHQucG9pbnQueSAtIGRpci55ICogcHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluZExhc3QgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsKF9ub3JtYWwsIGRpcik7XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGRhID0gcHJvZ3Jlc3MqY2E7XHJcbiAgICAgICAgICAgIGxldCBjID0gKChkYTw8MjQpID4+PiAwKSArIChjYjw8MTYpICsgKGNnPDw4KSArIGNyO1xyXG5cclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHZlcnRpY2VzQ291bnQgKiB2ZXJ0c09mZnNldDtcclxuXHJcbiAgICAgICAgICAgIHZEYXRhW29mZnNldF0gPSBwb2ludC54ICsgX25vcm1hbC54ICogc3Ryb2tlO1xyXG4gICAgICAgICAgICB2RGF0YVtvZmZzZXQgKyAxXSA9IHBvaW50LnkgKyBfbm9ybWFsLnkgKiBzdHJva2U7XHJcbiAgICAgICAgICAgIHZEYXRhW29mZnNldCArIDJdID0gMTtcclxuICAgICAgICAgICAgdkRhdGFbb2Zmc2V0ICsgM10gPSBwcm9ncmVzcztcclxuICAgICAgICAgICAgdWludFZEYXRhW29mZnNldCArIDRdID0gYztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG9mZnNldCArPSB2ZXJ0c09mZnNldDtcclxuXHJcbiAgICAgICAgICAgIHZEYXRhW29mZnNldF0gPSBwb2ludC54IC0gX25vcm1hbC54ICogc3Ryb2tlO1xyXG4gICAgICAgICAgICB2RGF0YVtvZmZzZXQgKyAxXSA9IHBvaW50LnkgLSBfbm9ybWFsLnkgKiBzdHJva2U7XHJcbiAgICAgICAgICAgIHZEYXRhW29mZnNldCArIDJdID0gMDtcclxuICAgICAgICAgICAgdkRhdGFbb2Zmc2V0ICsgM10gPSBwcm9ncmVzcztcclxuICAgICAgICAgICAgdWludFZEYXRhW29mZnNldCArIDRdID0gYztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZlcnRpY2VzQ291bnQgKz0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGljZXNDb3VudCA9IHZlcnRpY2VzQ291bnQgPD0gMiA/IDAgOiAodmVydGljZXNDb3VudCAtIDIpKjM7XHJcblxyXG4gICAgICAgIGZsZXhCdWZmZXIudXNlZCh2ZXJ0aWNlc0NvdW50LCBpbmRpY2VzQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbGxCdWZmZXJzIChjb21wLCByZW5kZXJlcikge1xyXG4gICAgICAgIGxldCB7IHZEYXRhLCB1c2VkVmVydGljZXMsIHVzZWRJbmRpY2VzLCB1c2VkVmVydGljZXNGbG9hdHMgfSA9IHRoaXMuX3JlbmRlckRhdGEuX2ZsZXhCdWZmZXI7XHJcblxyXG4gICAgICAgIGxldCBidWZmZXIgPSByZW5kZXJlci5fbWVzaEJ1ZmZlcjtcclxuICAgICAgICBsZXQgb2Zmc2V0SW5mbyA9IGJ1ZmZlci5yZXF1ZXN0KHVzZWRWZXJ0aWNlcywgdXNlZEluZGljZXMpO1xyXG5cclxuICAgICAgICAvLyBidWZmZXIgZGF0YSBtYXkgYmUgcmVhbGxvYywgbmVlZCBnZXQgcmVmZXJlbmNlIGFmdGVyIHJlcXVlc3QuXHJcblxyXG4gICAgICAgIC8vIGZpbGwgdmVydGljZXNcclxuICAgICAgICBsZXQgdmVydGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby5ieXRlT2Zmc2V0ID4+IDIsXHJcbiAgICAgICAgICAgIHZidWYgPSBidWZmZXIuX3ZEYXRhO1xyXG5cclxuICAgICAgICBpZiAodkRhdGEubGVuZ3RoICsgdmVydGV4T2Zmc2V0ID4gdmJ1Zi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmJ1Zi5zZXQodkRhdGEuc3ViYXJyYXkoMCwgdXNlZFZlcnRpY2VzRmxvYXRzKSwgdmVydGV4T2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZidWYuc2V0KHZEYXRhLCB2ZXJ0ZXhPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmlsbCBpbmRpY2VzXHJcbiAgICAgICAgbGV0IGlidWYgPSBidWZmZXIuX2lEYXRhLFxyXG4gICAgICAgICAgICBpbmRpY2VPZmZzZXQgPSBvZmZzZXRJbmZvLmluZGljZU9mZnNldCxcclxuICAgICAgICAgICAgdmVydGV4SWQgPSBvZmZzZXRJbmZvLnZlcnRleE9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gaW5kZXggYnVmZmVyXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1c2VkVmVydGljZXM7IGkgPCBsOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdmVydGV4SWQgKyBpO1xyXG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHN0YXJ0ICsgMjtcclxuICAgICAgICAgICAgaWJ1ZltpbmRpY2VPZmZzZXQrK10gPSBzdGFydCArIDE7XHJcbiAgICAgICAgICAgIGlidWZbaW5kaWNlT2Zmc2V0KytdID0gc3RhcnQgKyAxO1xyXG4gICAgICAgICAgICBpYnVmW2luZGljZU9mZnNldCsrXSA9IHN0YXJ0ICsgMjtcclxuICAgICAgICAgICAgaWJ1ZltpbmRpY2VPZmZzZXQrK10gPSBzdGFydCArIDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wLm5vZGUuX3JlbmRlckZsYWcgfD0gUmVuZGVyRmxvdy5GTEFHX1VQREFURV9SRU5ERVJfREFUQTtcclxuICAgIH1cclxufVxyXG5cclxuTW90aW9uU3RyZWFrQXNzZW1ibGVyLnJlZ2lzdGVyKE1vdGlvblN0cmVhaywgTW90aW9uU3RyZWFrQXNzZW1ibGVyKTtcclxuIl0sInNvdXJjZVJvb3QiOiIvIn0=