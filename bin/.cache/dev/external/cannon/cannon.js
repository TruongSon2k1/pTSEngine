
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/external/cannon/cannon.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

// Tue, 21 Jul 2020 02:42:12 GMT

/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
!function (e) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.CANNON = e();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          throw new Error("Cannot find module '" + o + "'");
        }

        var f = n[o] = {
          exports: {}
        };
        t[o][0].call(f.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, f, f.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof require == "function" && require;

    for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }

    return s;
  }({
    1: [function (_dereq_, module, exports) {
      module.exports = {
        "name": "@cocos/cannon",
        "version": "1.1.1-exp.3",
        "description": "A lightweight 3D physics engine written in JavaScript.",
        "homepage": "https://github.com/cocos-creator/cannon.js",
        "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se), JayceLai",
        "keywords": ["cannon.js", "cocos", "creator", "physics", "engine", "3d"],
        "scripts": {
          "build": "grunt && npm run preprocess && grunt addLicense && grunt addDate",
          "preprocess": "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -c -m"
        },
        "main": "./build/cannon.min.js",
        "engines": {
          "node": "*"
        },
        "repository": {
          "type": "git",
          "url": "https://github.com/cocos-creator/cannon.js.git"
        },
        "bugs": {
          "url": "https://github.com/cocos-creator/cannon.js/issues"
        },
        "licenses": [{
          "type": "MIT"
        }],
        "devDependencies": {
          "jshint": "latest",
          "uglify-js": "latest",
          "nodeunit": "^0.9.0",
          "grunt": "~0.4.0",
          "grunt-contrib-jshint": "~0.1.1",
          "grunt-contrib-nodeunit": "^0.4.1",
          "grunt-contrib-concat": "~0.1.3",
          "grunt-contrib-uglify": "^0.5.1",
          "grunt-browserify": "^2.1.4",
          "grunt-contrib-yuidoc": "^0.5.2",
          "browserify": "*"
        },
        "dependencies": {}
      };
    }, {}],
    2: [function (_dereq_, module, exports) {
      // Export classes
      module.exports = {
        version: _dereq_('../package.json').version,
        AABB: _dereq_('./collision/AABB'),
        ArrayCollisionMatrix: _dereq_('./collision/ArrayCollisionMatrix'),
        Body: _dereq_('./objects/Body'),
        Box: _dereq_('./shapes/Box'),
        Broadphase: _dereq_('./collision/Broadphase'),
        Constraint: _dereq_('./constraints/Constraint'),
        ContactEquation: _dereq_('./equations/ContactEquation'),
        Narrowphase: _dereq_('./world/Narrowphase'),
        ConeTwistConstraint: _dereq_('./constraints/ConeTwistConstraint'),
        ContactMaterial: _dereq_('./material/ContactMaterial'),
        ConvexPolyhedron: _dereq_('./shapes/ConvexPolyhedron'),
        Cylinder: _dereq_('./shapes/Cylinder'),
        DistanceConstraint: _dereq_('./constraints/DistanceConstraint'),
        Equation: _dereq_('./equations/Equation'),
        EventTarget: _dereq_('./utils/EventTarget'),
        FrictionEquation: _dereq_('./equations/FrictionEquation'),
        GSSolver: _dereq_('./solver/GSSolver'),
        GridBroadphase: _dereq_('./collision/GridBroadphase'),
        Heightfield: _dereq_('./shapes/Heightfield'),
        HingeConstraint: _dereq_('./constraints/HingeConstraint'),
        LockConstraint: _dereq_('./constraints/LockConstraint'),
        Mat3: _dereq_('./math/Mat3'),
        Material: _dereq_('./material/Material'),
        NaiveBroadphase: _dereq_('./collision/NaiveBroadphase'),
        ObjectCollisionMatrix: _dereq_('./collision/ObjectCollisionMatrix'),
        Pool: _dereq_('./utils/Pool'),
        Particle: _dereq_('./shapes/Particle'),
        Plane: _dereq_('./shapes/Plane'),
        PointToPointConstraint: _dereq_('./constraints/PointToPointConstraint'),
        Quaternion: _dereq_('./math/Quaternion'),
        Ray: _dereq_('./collision/Ray'),
        RaycastVehicle: _dereq_('./objects/RaycastVehicle'),
        RaycastResult: _dereq_('./collision/RaycastResult'),
        RigidVehicle: _dereq_('./objects/RigidVehicle'),
        RotationalEquation: _dereq_('./equations/RotationalEquation'),
        RotationalMotorEquation: _dereq_('./equations/RotationalMotorEquation'),
        SAPBroadphase: _dereq_('./collision/SAPBroadphase'),
        SPHSystem: _dereq_('./objects/SPHSystem'),
        Shape: _dereq_('./shapes/Shape'),
        Solver: _dereq_('./solver/Solver'),
        Sphere: _dereq_('./shapes/Sphere'),
        SplitSolver: _dereq_('./solver/SplitSolver'),
        Spring: _dereq_('./objects/Spring'),
        Transform: _dereq_('./math/Transform'),
        Trimesh: _dereq_('./shapes/Trimesh'),
        Vec3: _dereq_('./math/Vec3'),
        Vec3Pool: _dereq_('./utils/Vec3Pool'),
        World: _dereq_('./world/World'),
        Octree: _dereq_('./utils/Octree'),
        CMath: _dereq_('./math/CMath')
      };
    }, {
      "../package.json": 1,
      "./collision/AABB": 3,
      "./collision/ArrayCollisionMatrix": 4,
      "./collision/Broadphase": 5,
      "./collision/GridBroadphase": 6,
      "./collision/NaiveBroadphase": 7,
      "./collision/ObjectCollisionMatrix": 8,
      "./collision/Ray": 10,
      "./collision/RaycastResult": 11,
      "./collision/SAPBroadphase": 12,
      "./constraints/ConeTwistConstraint": 13,
      "./constraints/Constraint": 14,
      "./constraints/DistanceConstraint": 15,
      "./constraints/HingeConstraint": 16,
      "./constraints/LockConstraint": 17,
      "./constraints/PointToPointConstraint": 18,
      "./equations/ContactEquation": 20,
      "./equations/Equation": 21,
      "./equations/FrictionEquation": 22,
      "./equations/RotationalEquation": 23,
      "./equations/RotationalMotorEquation": 24,
      "./material/ContactMaterial": 25,
      "./material/Material": 26,
      "./math/CMath": 27,
      "./math/Mat3": 29,
      "./math/Quaternion": 30,
      "./math/Transform": 31,
      "./math/Vec3": 32,
      "./objects/Body": 33,
      "./objects/RaycastVehicle": 34,
      "./objects/RigidVehicle": 35,
      "./objects/SPHSystem": 36,
      "./objects/Spring": 37,
      "./shapes/Box": 39,
      "./shapes/ConvexPolyhedron": 40,
      "./shapes/Cylinder": 41,
      "./shapes/Heightfield": 42,
      "./shapes/Particle": 43,
      "./shapes/Plane": 44,
      "./shapes/Shape": 45,
      "./shapes/Sphere": 46,
      "./shapes/Trimesh": 47,
      "./solver/GSSolver": 48,
      "./solver/Solver": 49,
      "./solver/SplitSolver": 50,
      "./utils/EventTarget": 51,
      "./utils/Octree": 52,
      "./utils/Pool": 53,
      "./utils/Vec3Pool": 56,
      "./world/Narrowphase": 57,
      "./world/World": 58
    }],
    3: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      var Utils = _dereq_('../utils/Utils');

      module.exports = AABB;
      /**
       * Axis aligned bounding box class.
       * @class AABB
       * @constructor
       * @param {Object} [options]
       * @param {Vec3}   [options.upperBound]
       * @param {Vec3}   [options.lowerBound]
       */

      function AABB(options) {
        options = options || {};
        /**
         * The lower bound of the bounding box.
         * @property lowerBound
         * @type {Vec3}
         */

        this.lowerBound = new Vec3();

        if (options.lowerBound) {
          this.lowerBound.copy(options.lowerBound);
        }
        /**
         * The upper bound of the bounding box.
         * @property upperBound
         * @type {Vec3}
         */


        this.upperBound = new Vec3();

        if (options.upperBound) {
          this.upperBound.copy(options.upperBound);
        }
      }

      var tmp = new Vec3();
      /**
       * Set the AABB bounds from a set of points.
       * @method setFromPoints
       * @param {Array} points An array of Vec3's.
       * @param {Vec3} position
       * @param {Quaternion} quaternion
       * @param {number} skinSize
       * @return {AABB} The self object
       */

      AABB.prototype.setFromPoints = function (points, position, quaternion, skinSize) {
        var l = this.lowerBound,
            u = this.upperBound,
            q = quaternion; // Set to the first point

        l.copy(points[0]);

        if (q) {
          q.vmult(l, l);
        }

        u.copy(l);

        for (var i = 1; i < points.length; i++) {
          var p = points[i];

          if (q) {
            q.vmult(p, tmp);
            p = tmp;
          }

          if (p.x > u.x) {
            u.x = p.x;
          }

          if (p.x < l.x) {
            l.x = p.x;
          }

          if (p.y > u.y) {
            u.y = p.y;
          }

          if (p.y < l.y) {
            l.y = p.y;
          }

          if (p.z > u.z) {
            u.z = p.z;
          }

          if (p.z < l.z) {
            l.z = p.z;
          }
        } // Add offset


        if (position) {
          position.vadd(l, l);
          position.vadd(u, u);
        }

        if (skinSize) {
          l.x -= skinSize;
          l.y -= skinSize;
          l.z -= skinSize;
          u.x += skinSize;
          u.y += skinSize;
          u.z += skinSize;
        }

        return this;
      };
      /**
       * Copy bounds from an AABB to this AABB
       * @method copy
       * @param  {AABB} aabb Source to copy from
       * @return {AABB} The this object, for chainability
       */


      AABB.prototype.copy = function (aabb) {
        this.lowerBound.copy(aabb.lowerBound);
        this.upperBound.copy(aabb.upperBound);
        return this;
      };
      /**
       * Clone an AABB
       * @method clone
       */


      AABB.prototype.clone = function () {
        return new AABB().copy(this);
      };
      /**
       * Extend this AABB so that it covers the given AABB too.
       * @method extend
       * @param  {AABB} aabb
       */


      AABB.prototype.extend = function (aabb) {
        this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
        this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
        this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
        this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
        this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
        this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
      };
      /**
       * Returns true if the given AABB overlaps this AABB.
       * @method overlaps
       * @param  {AABB} aabb
       * @return {Boolean}
       */


      AABB.prototype.overlaps = function (aabb) {
        var l1 = this.lowerBound,
            u1 = this.upperBound,
            l2 = aabb.lowerBound,
            u2 = aabb.upperBound; //      l2        u2
        //      |---------|
        // |--------|
        // l1       u1

        var overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
        var overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
        var overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
        return overlapsX && overlapsY && overlapsZ;
      }; // Mostly for debugging


      AABB.prototype.volume = function () {
        var l = this.lowerBound,
            u = this.upperBound;
        return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
      };
      /**
       * Returns true if the given AABB is fully contained in this AABB.
       * @method contains
       * @param {AABB} aabb
       * @return {Boolean}
       */


      AABB.prototype.contains = function (aabb) {
        var l1 = this.lowerBound,
            u1 = this.upperBound,
            l2 = aabb.lowerBound,
            u2 = aabb.upperBound; //      l2        u2
        //      |---------|
        // |---------------|
        // l1              u1

        return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
      };
      /**
       * @method getCorners
       * @param {Vec3} a
       * @param {Vec3} b
       * @param {Vec3} c
       * @param {Vec3} d
       * @param {Vec3} e
       * @param {Vec3} f
       * @param {Vec3} g
       * @param {Vec3} h
       */


      AABB.prototype.getCorners = function (a, b, c, d, e, f, g, h) {
        var l = this.lowerBound,
            u = this.upperBound;
        a.copy(l);
        b.set(u.x, l.y, l.z);
        c.set(u.x, u.y, l.z);
        d.set(l.x, u.y, u.z);
        e.set(u.x, l.y, u.z);
        f.set(l.x, u.y, l.z);
        g.set(l.x, l.y, u.z);
        h.copy(u);
      };

      var transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
      /**
       * Get the representation of an AABB in another frame.
       * @method toLocalFrame
       * @param  {Transform} frame
       * @param  {AABB} target
       * @return {AABB} The "target" AABB object.
       */

      AABB.prototype.toLocalFrame = function (frame, target) {
        var corners = transformIntoFrame_corners;
        var a = corners[0];
        var b = corners[1];
        var c = corners[2];
        var d = corners[3];
        var e = corners[4];
        var f = corners[5];
        var g = corners[6];
        var h = corners[7]; // Get corners in current frame

        this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

        for (var i = 0; i !== 8; i++) {
          var corner = corners[i];
          frame.pointToLocal(corner, corner);
        }

        return target.setFromPoints(corners);
      };
      /**
       * Get the representation of an AABB in the global frame.
       * @method toWorldFrame
       * @param  {Transform} frame
       * @param  {AABB} target
       * @return {AABB} The "target" AABB object.
       */


      AABB.prototype.toWorldFrame = function (frame, target) {
        var corners = transformIntoFrame_corners;
        var a = corners[0];
        var b = corners[1];
        var c = corners[2];
        var d = corners[3];
        var e = corners[4];
        var f = corners[5];
        var g = corners[6];
        var h = corners[7]; // Get corners in current frame

        this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

        for (var i = 0; i !== 8; i++) {
          var corner = corners[i];
          frame.pointToWorld(corner, corner);
        }

        return target.setFromPoints(corners);
      };
      /**
       * Check if the AABB is hit by a ray.
       * @param  {Ray} ray
       * @return {number}
       */


      AABB.prototype.overlapsRay = function (ray) {
        var t = 0; // ray.direction is unit direction vector of ray

        var dirFracX = 1 / ray._direction.x;
        var dirFracY = 1 / ray._direction.y;
        var dirFracZ = 1 / ray._direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

        var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
        var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
        var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
        var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
        var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
        var t6 = (this.upperBound.z - ray.from.z) * dirFracZ; // var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
        // var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

        if (tmax < 0) {
          //t = tmax;
          return false;
        } // if tmin > tmax, ray doesn't intersect AABB


        if (tmin > tmax) {
          //t = tmax;
          return false;
        }

        return true;
      };
    }, {
      "../math/Vec3": 32,
      "../utils/Utils": 55
    }],
    4: [function (_dereq_, module, exports) {
      module.exports = ArrayCollisionMatrix;
      /**
       * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
       * @class ArrayCollisionMatrix
       * @constructor
       */

      function ArrayCollisionMatrix() {
        /**
         * The matrix storage
         * @property matrix
         * @type {Array}
         */
        this.matrix = [];
      }
      /**
       * Get an element
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Number}
       */


      ArrayCollisionMatrix.prototype.get = function (i, j) {
        i = i.index;
        j = j.index;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return this.matrix[(i * (i + 1) >> 1) + j - 1];
      };
      /**
       * Set an element
       * @method set
       * @param {Number} i
       * @param {Number} j
       * @param {Number} value
       */


      ArrayCollisionMatrix.prototype.set = function (i, j, value) {
        i = i.index;
        j = j.index;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
      };
      /**
       * Sets all elements to zero
       * @method reset
       */


      ArrayCollisionMatrix.prototype.reset = function () {
        for (var i = 0, l = this.matrix.length; i !== l; i++) {
          this.matrix[i] = 0;
        }
      };
      /**
       * Sets the max number of objects
       * @method setNumObjects
       * @param {Number} n
       */


      ArrayCollisionMatrix.prototype.setNumObjects = function (n) {
        this.matrix.length = n * (n - 1) >> 1;
      };
    }, {}],
    5: [function (_dereq_, module, exports) {
      var Body = _dereq_('../objects/Body');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Shape = _dereq_('../shapes/Shape');

      var Plane = _dereq_('../shapes/Plane');

      module.exports = Broadphase;
      /**
       * Base class for broadphase implementations
       * @class Broadphase
       * @constructor
       * @author schteppe
       */

      function Broadphase() {
        /**
        * The world to search for collisions in.
        * @property world
        * @type {World}
        */
        this.world = null;
        /**
         * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
         * @property useBoundingBoxes
         * @type {Boolean}
         */

        this.useBoundingBoxes = false;
        /**
         * Set to true if the objects in the world moved.
         * @property {Boolean} dirty
         */

        this.dirty = true;
      }
      /**
       * Get the collision pairs from the world
       * @method collisionPairs
       * @param {World} world The world to search in
       * @param {Array} p1 Empty array to be filled with body objects
       * @param {Array} p2 Empty array to be filled with body objects
       */


      Broadphase.prototype.collisionPairs = function (world, p1, p2) {
        throw new Error("collisionPairs not implemented for this BroadPhase class!");
      };
      /**
       * Check if a body pair needs to be intersection tested at all.
       * @method needBroadphaseCollision
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @return {bool}
       */


      Broadphase.prototype.needBroadphaseCollision = function (bodyA, bodyB) {
        // Check collision filter masks
        if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
          return false;
        } // Check has trigger


        if (bodyA.hasTrigger || bodyB.hasTrigger) {
          return true;
        } // Check types


        if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
          // Both bodies are static or sleeping. Skip.
          return false;
        }

        return true;
      };
      /**
       * Check if the bounding volumes of two bodies intersect.
       * @method intersectionTest
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {array} pairs1
       * @param {array} pairs2
        */


      Broadphase.prototype.intersectionTest = function (bodyA, bodyB, pairs1, pairs2) {
        if (this.useBoundingBoxes) {
          this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
        } else {
          this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
        }
      };
      /**
       * Check if the bounding spheres of two bodies are intersecting.
       * @method doBoundingSphereBroadphase
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Array} pairs1 bodyA is appended to this array if intersection
       * @param {Array} pairs2 bodyB is appended to this array if intersection
       */


      var Broadphase_collisionPairs_r = new Vec3(),
          // Temp objects
      Broadphase_collisionPairs_normal = new Vec3(),
          Broadphase_collisionPairs_quat = new Quaternion(),
          Broadphase_collisionPairs_relpos = new Vec3();

      Broadphase.prototype.doBoundingSphereBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
        var r = Broadphase_collisionPairs_r;
        bodyB.position.vsub(bodyA.position, r);
        var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
        var norm2 = r.norm2();

        if (norm2 < boundingRadiusSum2) {
          pairs1.push(bodyA);
          pairs2.push(bodyB);
        }
      };
      /**
       * Check if the bounding boxes of two bodies are intersecting.
       * @method doBoundingBoxBroadphase
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Array} pairs1
       * @param {Array} pairs2
       */


      Broadphase.prototype.doBoundingBoxBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
        if (bodyA.aabbNeedsUpdate) {
          bodyA.computeAABB();
        }

        if (bodyB.aabbNeedsUpdate) {
          bodyB.computeAABB();
        } // Check AABB / AABB


        if (bodyA.aabb.overlaps(bodyB.aabb)) {
          pairs1.push(bodyA);
          pairs2.push(bodyB);
        }
      };
      /**
       * Removes duplicate pairs from the pair arrays.
       * @method makePairsUnique
       * @param {Array} pairs1
       * @param {Array} pairs2
       */


      var Broadphase_makePairsUnique_temp = {
        keys: []
      },
          Broadphase_makePairsUnique_p1 = [],
          Broadphase_makePairsUnique_p2 = [];

      Broadphase.prototype.makePairsUnique = function (pairs1, pairs2) {
        var t = Broadphase_makePairsUnique_temp,
            p1 = Broadphase_makePairsUnique_p1,
            p2 = Broadphase_makePairsUnique_p2,
            N = pairs1.length;

        for (var i = 0; i !== N; i++) {
          p1[i] = pairs1[i];
          p2[i] = pairs2[i];
        }

        pairs1.length = 0;
        pairs2.length = 0;

        for (var i = 0; i !== N; i++) {
          var id1 = p1[i].id,
              id2 = p2[i].id;
          var key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
          t[key] = i;
          t.keys.push(key);
        }

        for (var i = 0; i !== t.keys.length; i++) {
          var key = t.keys.pop(),
              pairIndex = t[key];
          pairs1.push(p1[pairIndex]);
          pairs2.push(p2[pairIndex]);
          delete t[key];
        }
      };
      /**
       * To be implemented by subcasses
       * @method setWorld
       * @param {World} world
       */


      Broadphase.prototype.setWorld = function (world) {};
      /**
       * Check if the bounding spheres of two bodies overlap.
       * @method boundingSphereCheck
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @return {boolean}
       */


      var bsc_dist = new Vec3();

      Broadphase.boundingSphereCheck = function (bodyA, bodyB) {
        var dist = bsc_dist;
        bodyA.position.vsub(bodyB.position, dist);
        return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
      };
      /**
       * Returns all the bodies within the AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param  {array} result An array to store resulting bodies in.
       * @return {array}
       */


      Broadphase.prototype.aabbQuery = function (world, aabb, result) {
        console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
        return [];
      };
    }, {
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../objects/Body": 33,
      "../shapes/Plane": 44,
      "../shapes/Shape": 45
    }],
    6: [function (_dereq_, module, exports) {
      module.exports = GridBroadphase;

      var Broadphase = _dereq_('./Broadphase');

      var Vec3 = _dereq_('../math/Vec3');

      var Shape = _dereq_('../shapes/Shape');
      /**
       * Axis aligned uniform grid broadphase.
       * @class GridBroadphase
       * @constructor
       * @extends Broadphase
       * @todo Needs support for more than just planes and spheres.
       * @param {Vec3} aabbMin
       * @param {Vec3} aabbMax
       * @param {Number} nx Number of boxes along x
       * @param {Number} ny Number of boxes along y
       * @param {Number} nz Number of boxes along z
       */


      function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
        Broadphase.apply(this);
        this.nx = nx || 10;
        this.ny = ny || 10;
        this.nz = nz || 10;
        this.aabbMin = aabbMin || new Vec3(100, 100, 100);
        this.aabbMax = aabbMax || new Vec3(-100, -100, -100);
        var nbins = this.nx * this.ny * this.nz;

        if (nbins <= 0) {
          throw "GridBroadphase: Each dimension's n must be >0";
        }

        this.bins = [];
        this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

        this.bins.length = nbins;
        this.binLengths.length = nbins;

        for (var i = 0; i < nbins; i++) {
          this.bins[i] = [];
          this.binLengths[i] = 0;
        }
      }

      GridBroadphase.prototype = new Broadphase();
      GridBroadphase.prototype.constructor = GridBroadphase;
      /**
       * Get all the collision pairs in the physics world
       * @method collisionPairs
       * @param {World} world
       * @param {Array} pairs1
       * @param {Array} pairs2
       */

      var GridBroadphase_collisionPairs_d = new Vec3();
      var GridBroadphase_collisionPairs_binPos = new Vec3();

      GridBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
        var N = world.numObjects(),
            bodies = world.bodies;
        var max = this.aabbMax,
            min = this.aabbMin,
            nx = this.nx,
            ny = this.ny,
            nz = this.nz;
        var xstep = ny * nz;
        var ystep = nz;
        var zstep = 1;
        var xmax = max.x,
            ymax = max.y,
            zmax = max.z,
            xmin = min.x,
            ymin = min.y,
            zmin = min.z;
        var xmult = nx / (xmax - xmin),
            ymult = ny / (ymax - ymin),
            zmult = nz / (zmax - zmin);
        var binsizeX = (xmax - xmin) / nx,
            binsizeY = (ymax - ymin) / ny,
            binsizeZ = (zmax - zmin) / nz;
        var binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
        var types = Shape.types;
        var SPHERE = types.SPHERE,
            PLANE = types.PLANE,
            BOX = types.BOX,
            COMPOUND = types.COMPOUND,
            CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;
        var bins = this.bins,
            binLengths = this.binLengths,
            Nbins = this.bins.length; // Reset bins

        for (var i = 0; i !== Nbins; i++) {
          binLengths[i] = 0;
        }

        var ceil = Math.ceil;
        var min = Math.min;
        var max = Math.max;

        function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
          var xoff0 = (x0 - xmin) * xmult | 0,
              yoff0 = (y0 - ymin) * ymult | 0,
              zoff0 = (z0 - zmin) * zmult | 0,
              xoff1 = ceil((x1 - xmin) * xmult),
              yoff1 = ceil((y1 - ymin) * ymult),
              zoff1 = ceil((z1 - zmin) * zmult);

          if (xoff0 < 0) {
            xoff0 = 0;
          } else if (xoff0 >= nx) {
            xoff0 = nx - 1;
          }

          if (yoff0 < 0) {
            yoff0 = 0;
          } else if (yoff0 >= ny) {
            yoff0 = ny - 1;
          }

          if (zoff0 < 0) {
            zoff0 = 0;
          } else if (zoff0 >= nz) {
            zoff0 = nz - 1;
          }

          if (xoff1 < 0) {
            xoff1 = 0;
          } else if (xoff1 >= nx) {
            xoff1 = nx - 1;
          }

          if (yoff1 < 0) {
            yoff1 = 0;
          } else if (yoff1 >= ny) {
            yoff1 = ny - 1;
          }

          if (zoff1 < 0) {
            zoff1 = 0;
          } else if (zoff1 >= nz) {
            zoff1 = nz - 1;
          }

          xoff0 *= xstep;
          yoff0 *= ystep;
          zoff0 *= zstep;
          xoff1 *= xstep;
          yoff1 *= ystep;
          zoff1 *= zstep;

          for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
            for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
              for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                var idx = xoff + yoff + zoff;
                bins[idx][binLengths[idx]++] = bi;
              }
            }
          }
        } // Put all bodies into the bins


        for (var i = 0; i !== N; i++) {
          var bi = bodies[i];
          var si = bi.shape;

          switch (si.type) {
            case SPHERE:
              // Put in bin
              // check if overlap with other bins
              var x = bi.position.x,
                  y = bi.position.y,
                  z = bi.position.z;
              var r = si.radius;
              addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
              break;

            case PLANE:
              if (si.worldNormalNeedsUpdate) {
                si.computeWorldNormal(bi.quaternion);
              }

              var planeNormal = si.worldNormal; //Relative position from origin of plane object to the first bin
              //Incremented as we iterate through the bins

              var xreset = xmin + binsizeX * 0.5 - bi.position.x,
                  yreset = ymin + binsizeY * 0.5 - bi.position.y,
                  zreset = zmin + binsizeZ * 0.5 - bi.position.z;
              var d = GridBroadphase_collisionPairs_d;
              d.set(xreset, yreset, zreset);

              for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
                for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                  for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                    if (d.dot(planeNormal) < binRadius) {
                      var idx = xoff + yoff + zoff;
                      bins[idx][binLengths[idx]++] = bi;
                    }
                  }
                }
              }

              break;

            default:
              if (bi.aabbNeedsUpdate) {
                bi.computeAABB();
              }

              addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
              break;
          }
        } // Check each bin


        for (var i = 0; i !== Nbins; i++) {
          var binLength = binLengths[i]; //Skip bins with no potential collisions

          if (binLength > 1) {
            var bin = bins[i]; // Do N^2 broadphase inside

            for (var xi = 0; xi !== binLength; xi++) {
              var bi = bin[xi];

              for (var yi = 0; yi !== xi; yi++) {
                var bj = bin[yi];

                if (this.needBroadphaseCollision(bi, bj)) {
                  this.intersectionTest(bi, bj, pairs1, pairs2);
                }
              }
            }
          }
        } //	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
        //		console.log("layer "+zi);
        //		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
        //			var row = '';
        //			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
        //				var idx = xoff + yoff + zoff;
        //				row += ' ' + binLengths[idx];
        //			}
        //			console.log(row);
        //		}
        //	}


        this.makePairsUnique(pairs1, pairs2);
      };
    }, {
      "../math/Vec3": 32,
      "../shapes/Shape": 45,
      "./Broadphase": 5
    }],
    7: [function (_dereq_, module, exports) {
      module.exports = NaiveBroadphase;

      var Broadphase = _dereq_('./Broadphase');

      var AABB = _dereq_('./AABB');
      /**
       * Naive broadphase implementation, used in lack of better ones.
       * @class NaiveBroadphase
       * @constructor
       * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
       * @extends Broadphase
       */


      function NaiveBroadphase() {
        Broadphase.apply(this);
      }

      NaiveBroadphase.prototype = new Broadphase();
      NaiveBroadphase.prototype.constructor = NaiveBroadphase;
      /**
       * Get all the collision pairs in the physics world
       * @method collisionPairs
       * @param {World} world
       * @param {Array} pairs1
       * @param {Array} pairs2
       */

      NaiveBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
        var bodies = world.bodies,
            n = bodies.length,
            i,
            j,
            bi,
            bj; // Naive N^2 ftw!

        for (i = 0; i !== n; i++) {
          for (j = 0; j !== i; j++) {
            bi = bodies[i];
            bj = bodies[j];

            if (!this.needBroadphaseCollision(bi, bj)) {
              continue;
            }

            this.intersectionTest(bi, bj, pairs1, pairs2);
          }
        }
      };

      var tmpAABB = new AABB();
      /**
       * Returns all the bodies within an AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param {array} result An array to store resulting bodies in.
       * @return {array}
       */

      NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];

        for (var i = 0; i < world.bodies.length; i++) {
          var b = world.bodies[i];

          if (b.aabbNeedsUpdate) {
            b.computeAABB();
          } // Ugly hack until Body gets aabb


          if (b.aabb.overlaps(aabb)) {
            result.push(b);
          }
        }

        return result;
      };
    }, {
      "./AABB": 3,
      "./Broadphase": 5
    }],
    8: [function (_dereq_, module, exports) {
      module.exports = ObjectCollisionMatrix;
      /**
       * Records what objects are colliding with each other
       * @class ObjectCollisionMatrix
       * @constructor
       */

      function ObjectCollisionMatrix() {
        /**
         * The matrix storage
         * @property matrix
         * @type {Object}
         */
        this.matrix = {};
      }
      /**
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Number}
       */


      ObjectCollisionMatrix.prototype.get = function (i, j) {
        i = i.id;
        j = j.id;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return i + '-' + j in this.matrix;
      };
      /**
       * @method set
       * @param  {Number} i
       * @param  {Number} j
       * @param {Number} value
       */


      ObjectCollisionMatrix.prototype.set = function (i, j, value) {
        i = i.id;
        j = j.id;

        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }

        if (value) {
          this.matrix[i + '-' + j] = true;
        } else {
          delete this.matrix[i + '-' + j];
        }
      };
      /**
       * Empty the matrix
       * @method reset
       */


      ObjectCollisionMatrix.prototype.reset = function () {
        this.matrix = {};
      };
      /**
       * Set max number of objects
       * @method setNumObjects
       * @param {Number} n
       */


      ObjectCollisionMatrix.prototype.setNumObjects = function (n) {};
    }, {}],
    9: [function (_dereq_, module, exports) {
      module.exports = OverlapKeeper;
      /**
       * @class OverlapKeeper
       * @constructor
       */

      function OverlapKeeper() {
        this.current = [];
        this.previous = [];
      }

      OverlapKeeper.prototype.getKey = function (i, j) {
        if (j < i) {
          var temp = j;
          j = i;
          i = temp;
        }

        return i << 16 | j;
      };
      /**
       * @method set
       * @param {Number} i
       * @param {Number} j
       */


      OverlapKeeper.prototype.set = function (i, j) {
        // Insertion sort. This way the diff will have linear complexity.
        var key = this.getKey(i, j);
        var current = this.current;
        var index = 0;

        while (key > current[index]) {
          index++;
        }

        if (key === current[index]) {
          return; // Pair was already added
        }

        for (var j = current.length - 1; j >= index; j--) {
          current[j + 1] = current[j];
        }

        current[index] = key;
      };
      /**
       * @method tick
       */


      OverlapKeeper.prototype.tick = function () {
        var tmp = this.current;
        this.current = this.previous;
        this.previous = tmp;
        this.current.length = 0;
      };

      function unpackAndPush(array, key) {
        array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);
      }
      /**
       * @method getDiff
       * @param  {array} additions
       * @param  {array} removals
       */


      OverlapKeeper.prototype.getDiff = function (additions, removals) {
        var a = this.current;
        var b = this.previous;
        var al = a.length;
        var bl = b.length;
        var j = 0;

        for (var i = 0; i < al; i++) {
          var found = false;
          var keyA = a[i];

          while (keyA > b[j]) {
            j++;
          }

          found = keyA === b[j];

          if (!found) {
            unpackAndPush(additions, keyA);
          }
        }

        j = 0;

        for (var i = 0; i < bl; i++) {
          var found = false;
          var keyB = b[i];

          while (keyB > a[j]) {
            j++;
          }

          found = a[j] === keyB;

          if (!found) {
            unpackAndPush(removals, keyB);
          }
        }
      };
    }, {}],
    10: [function (_dereq_, module, exports) {
      module.exports = Ray;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');

      var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');

      var Box = _dereq_('../shapes/Box');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Shape = _dereq_('../shapes/Shape');

      var AABB = _dereq_('../collision/AABB');
      /**
       * A line in 3D space that intersects bodies and return points.
       * @class Ray
       * @constructor
       * @param {Vec3} from
       * @param {Vec3} to
       */


      function Ray(from, to) {
        /**
         * @property {Vec3} from
         */
        this.from = from ? from.clone() : new Vec3();
        /**
         * @property {Vec3} to
         */

        this.to = to ? to.clone() : new Vec3();
        /**
         * @private
         * @property {Vec3} _direction
         */

        this._direction = new Vec3();
        /**
         * The precision of the ray. Used when checking parallelity etc.
         * @property {Number} precision
         */

        this.precision = 0.0001;
        /**
         * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
         * @property {Boolean} checkCollisionResponse
         */

        this.checkCollisionResponse = true;
        /**
         * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
         * @property {Boolean} skipBackfaces
         */

        this.skipBackfaces = false;
        /**
         * @property {number} collisionFilterMask
         * @default -1
         */

        this.collisionFilterMask = -1;
        /**
         * @property {number} collisionFilterGroup
         * @default -1
         */

        this.collisionFilterGroup = -1;
        /**
         * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
         * @property {number} mode
         */

        this.mode = Ray.ANY;
        /**
         * Current result object.
         * @property {RaycastResult} result
         */

        this.result = new RaycastResult();
        /**
         * Will be set to true during intersectWorld() if the ray hit anything.
         * @property {Boolean} hasHit
         */

        this.hasHit = false;
        /**
         * Current, user-provided result callback. Will be used if mode is Ray.ALL.
         * @property {Function} callback
         */

        this.callback = function (result) {};
      }

      Ray.prototype.constructor = Ray;
      Ray.CLOSEST = 1;
      Ray.ANY = 2;
      Ray.ALL = 4;
      var tmpAABB = new AABB();
      var tmpArray = [];
      /**
       * Do itersection against all bodies in the given World.
       * @method intersectWorld
       * @param  {World} world
       * @param  {object} options
       * @return {Boolean} True if the ray hit anything, otherwise false.
       */

      Ray.prototype.intersectWorld = function (world, options) {
        this.mode = options.mode || Ray.ANY;
        this.result = options.result || new RaycastResult();
        this.skipBackfaces = !!options.skipBackfaces;
        this.checkCollisionResponse = !!options.checkCollisionResponse;
        this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
        this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;

        if (options.from) {
          this.from.copy(options.from);
        }

        if (options.to) {
          this.to.copy(options.to);
        }

        this.callback = options.callback || function () {};

        this.hasHit = false;
        this.result.reset();

        this._updateDirection();

        this.getAABB(tmpAABB);
        tmpArray.length = 0;
        world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
        this.intersectBodies(tmpArray);
        return this.hasHit;
      };

      var v1 = new Vec3(),
          v2 = new Vec3();
      /*
       * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
       */

      Ray.pointInTriangle = pointInTriangle;

      function pointInTriangle(p, a, b, c) {
        c.vsub(a, v0);
        b.vsub(a, v1);
        p.vsub(a, v2);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var u, v;
        return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
      }
      /**
       * Shoot a ray at a body, get back information about the hit.
       * @method intersectBody
       * @private
       * @param {Body} body
       * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
       */


      var intersectBody_xi = new Vec3();
      var intersectBody_qi = new Quaternion();

      Ray.prototype.intersectBody = function (body, result) {
        if (result) {
          this.result = result;

          this._updateDirection();
        }

        var checkCollisionResponse = this.checkCollisionResponse;

        if (checkCollisionResponse && !body.collisionResponse) {
          return;
        }

        if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
          return;
        }

        var xi = intersectBody_xi;
        var qi = intersectBody_qi;

        for (var i = 0, N = body.shapes.length; i < N; i++) {
          var shape = body.shapes[i];

          if (checkCollisionResponse && !shape.collisionResponse) {
            continue; // Skip
          }

          body.quaternion.mult(body.shapeOrientations[i], qi);
          body.quaternion.vmult(body.shapeOffsets[i], xi);
          xi.vadd(body.position, xi);
          this.intersectShape(shape, qi, xi, body);

          if (this.result._shouldStop) {
            break;
          }
        }
      };
      /**
       * @method intersectBodies
       * @param {Array} bodies An array of Body objects.
       * @param {RaycastResult} [result] Deprecated
       */


      Ray.prototype.intersectBodies = function (bodies, result) {
        if (result) {
          this.result = result;

          this._updateDirection();
        }

        for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) {
          this.intersectBody(bodies[i]);
        }
      };
      /**
       * Updates the _direction vector.
       * @private
       * @method _updateDirection
       */


      Ray.prototype._updateDirection = function () {
        this.to.vsub(this.from, this._direction);

        this._direction.normalize();
      };
      /**
       * @method intersectShape
       * @private
       * @param {Shape} shape
       * @param {Quaternion} quat
       * @param {Vec3} position
       * @param {Body} body
       */


      Ray.prototype.intersectShape = function (shape, quat, position, body) {
        var from = this.from; // Checking boundingSphere

        var distance = distanceFromIntersection(from, this._direction, position);

        if (distance > shape.boundingSphereRadius) {
          return;
        }

        var intersectMethod = this[shape.type];

        if (intersectMethod) {
          intersectMethod.call(this, shape, quat, position, body, shape);
        }
      };

      var vector = new Vec3();
      var normal = new Vec3();
      var intersectPoint = new Vec3();
      var a = new Vec3();
      var b = new Vec3();
      var c = new Vec3();
      var d = new Vec3();
      var tmpRaycastResult = new RaycastResult();
      /**
       * @method intersectBox
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectBox = function (shape, quat, position, body, reportedShape) {
        return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
      };

      Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;
      /**
       * @method intersectPlane
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectPlane = function (shape, quat, position, body, reportedShape) {
        var from = this.from;
        var to = this.to;
        var direction = this._direction; // Get plane normal

        var worldNormal = new Vec3(0, 0, 1);
        quat.vmult(worldNormal, worldNormal);
        var len = new Vec3();
        from.vsub(position, len);
        var planeToFrom = len.dot(worldNormal);
        to.vsub(position, len);
        var planeToTo = len.dot(worldNormal);

        if (planeToFrom * planeToTo > 0) {
          // "from" and "to" are on the same side of the plane... bail out
          return;
        }

        if (from.distanceTo(to) < planeToFrom) {
          return;
        }

        var n_dot_dir = worldNormal.dot(direction);

        if (Math.abs(n_dot_dir) < this.precision) {
          // No intersection
          return;
        }

        var planePointToFrom = new Vec3();
        var dir_scaled_with_t = new Vec3();
        var hitPointWorld = new Vec3();
        from.vsub(position, planePointToFrom);
        var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
        direction.scale(t, dir_scaled_with_t);
        from.vadd(dir_scaled_with_t, hitPointWorld);
        this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
      };

      Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;
      /**
       * Get the world AABB of the ray.
       * @method getAABB
       * @param  {AABB} aabb
       */

      Ray.prototype.getAABB = function (result) {
        var to = this.to;
        var from = this.from;
        result.lowerBound.x = Math.min(to.x, from.x);
        result.lowerBound.y = Math.min(to.y, from.y);
        result.lowerBound.z = Math.min(to.z, from.z);
        result.upperBound.x = Math.max(to.x, from.x);
        result.upperBound.y = Math.max(to.y, from.y);
        result.upperBound.z = Math.max(to.z, from.z);
      };

      var intersectConvexOptions = {
        faceList: [0]
      };
      var worldPillarOffset = new Vec3();
      var intersectHeightfield_localRay = new Ray();
      var intersectHeightfield_index = [];
      var intersectHeightfield_minMax = [];
      /**
       * @method intersectHeightfield
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectHeightfield = function (shape, quat, position, body, reportedShape) {
        var data = shape.data,
            w = shape.elementSize; // Convert the ray to local heightfield coordinates

        var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

        localRay.from.copy(this.from);
        localRay.to.copy(this.to);
        Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
        Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

        localRay._updateDirection(); // Get the index of the data points to test against


        var index = intersectHeightfield_index;
        var iMinX, iMinY, iMaxX, iMaxY; // Set to max

        iMinX = iMinY = 0;
        iMaxX = iMaxY = shape.data.length - 1;
        var aabb = new AABB();
        localRay.getAABB(aabb);
        shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
        iMinX = Math.max(iMinX, index[0]);
        iMinY = Math.max(iMinY, index[1]);
        shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
        iMaxX = Math.min(iMaxX, index[0] + 1);
        iMaxY = Math.min(iMaxY, index[1] + 1);

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            if (this.result._shouldStop) {
              return;
            }

            shape.getAabbAtIndex(i, j, aabb);

            if (!aabb.overlapsRay(localRay)) {
              continue;
            } // Lower triangle


            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

            if (this.result._shouldStop) {
              return;
            } // Upper triangle


            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
          }
        }
      };

      Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;
      var Ray_intersectSphere_intersectionPoint = new Vec3();
      var Ray_intersectSphere_normal = new Vec3();
      /**
       * @method intersectSphere
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       */

      Ray.prototype.intersectSphere = function (shape, quat, position, body, reportedShape) {
        var from = this.from,
            to = this.to,
            r = shape.radius;
        var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
        var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
        var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;
        var intersectionPoint = Ray_intersectSphere_intersectionPoint;
        var normal = Ray_intersectSphere_normal;

        if (delta < 0) {
          // No intersection
          return;
        } else if (delta === 0) {
          // single intersection point
          from.lerp(to, delta, intersectionPoint);
          intersectionPoint.vsub(position, normal);
          normal.normalize();
          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        } else {
          var d1 = (-b - Math.sqrt(delta)) / (2 * a);
          var d2 = (-b + Math.sqrt(delta)) / (2 * a);

          if (d1 >= 0 && d1 <= 1) {
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
          }

          if (this.result._shouldStop) {
            return;
          }

          if (d2 >= 0 && d2 <= 1) {
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
          }
        }
      };

      Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;
      var intersectConvex_normal = new Vec3();
      var intersectConvex_minDistNormal = new Vec3();
      var intersectConvex_minDistIntersect = new Vec3();
      var intersectConvex_vector = new Vec3();
      /**
       * @method intersectConvex
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       * @param {object} [options]
       * @param {array} [options.faceList]
       */

      Ray.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, reportedShape, options) {
        var minDistNormal = intersectConvex_minDistNormal;
        var normal = intersectConvex_normal;
        var vector = intersectConvex_vector;
        var minDistIntersect = intersectConvex_minDistIntersect;
        var faceList = options && options.faceList || null; // Checking faces

        var faces = shape.faces,
            vertices = shape.vertices,
            normals = shape.faceNormals;
        var direction = this._direction;
        var from = this.from;
        var to = this.to;
        var fromToDistance = from.distanceTo(to);
        var minDist = -1;
        var Nfaces = faceList ? faceList.length : faces.length;
        var result = this.result;

        for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
          var fi = faceList ? faceList[j] : j;
          var face = faces[fi];
          var faceNormal = normals[fi];
          var q = quat;
          var x = position; // determine if ray intersects the plane of the face
          // note: this works regardless of the direction of the face normal
          // Get plane point in world coordinates...

          vector.copy(vertices[face[0]]);
          q.vmult(vector, vector);
          vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

          vector.vsub(from, vector); // Get plane normal

          q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

          var dot = direction.dot(normal); // Bail out if ray and plane are parallel

          if (Math.abs(dot) < this.precision) {
            continue;
          } // calc distance to plane


          var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

          if (scalar < 0) {
            continue;
          } // if (dot < 0) {
          // Intersection point is from + direction * scalar


          direction.mult(scalar, intersectPoint);
          intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

          a.copy(vertices[face[0]]);
          q.vmult(a, a);
          x.vadd(a, a);

          for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i + 1]]);
            q.vmult(b, b);
            q.vmult(c, c);
            x.vadd(b, b);
            x.vadd(c, c);
            var distance = intersectPoint.distanceTo(from);

            if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
              continue;
            }

            this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
          } // }

        }
      };

      Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;
      var intersectTrimesh_normal = new Vec3();
      var intersectTrimesh_localDirection = new Vec3();
      var intersectTrimesh_localFrom = new Vec3();
      var intersectTrimesh_localTo = new Vec3();
      var intersectTrimesh_worldNormal = new Vec3();
      var intersectTrimesh_worldIntersectPoint = new Vec3();
      var intersectTrimesh_localAABB = new AABB();
      var intersectTrimesh_triangles = [];
      var intersectTrimesh_treeTransform = new Transform();
      /**
       * @method intersectTrimesh
       * @private
       * @param  {Shape} shape
       * @param  {Quaternion} quat
       * @param  {Vec3} position
       * @param  {Body} body
       * @param {object} [options]
       * @todo Optimize by transforming the world to local space first.
       * @todo Use Octree lookup
       */

      Ray.prototype.intersectTrimesh = function intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
        var normal = intersectTrimesh_normal;
        var triangles = intersectTrimesh_triangles;
        var treeTransform = intersectTrimesh_treeTransform;
        var minDistNormal = intersectConvex_minDistNormal;
        var vector = intersectConvex_vector;
        var minDistIntersect = intersectConvex_minDistIntersect;
        var localAABB = intersectTrimesh_localAABB;
        var localDirection = intersectTrimesh_localDirection;
        var localFrom = intersectTrimesh_localFrom;
        var localTo = intersectTrimesh_localTo;
        var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
        var worldNormal = intersectTrimesh_worldNormal;
        var faceList = options && options.faceList || null; // Checking faces

        var indices = mesh.indices,
            vertices = mesh.vertices,
            normals = mesh.faceNormals;
        var from = this.from;
        var to = this.to;
        var direction = this._direction;
        var minDist = -1;
        treeTransform.position.copy(position);
        treeTransform.quaternion.copy(quat); // Transform ray to local space!

        Transform.vectorToLocalFrame(position, quat, direction, localDirection);
        Transform.pointToLocalFrame(position, quat, from, localFrom);
        Transform.pointToLocalFrame(position, quat, to, localTo);
        localTo.x *= mesh.scale.x;
        localTo.y *= mesh.scale.y;
        localTo.z *= mesh.scale.z;
        localFrom.x *= mesh.scale.x;
        localFrom.y *= mesh.scale.y;
        localFrom.z *= mesh.scale.z;
        localTo.vsub(localFrom, localDirection);
        localDirection.normalize();
        var fromToDistanceSquared = localFrom.distanceSquared(localTo);
        mesh.tree.rayQuery(this, treeTransform, triangles);

        for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
          var trianglesIndex = triangles[i];
          mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
          // note: this works regardless of the direction of the face normal
          // Get plane point in world coordinates...

          mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

          a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

          var dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
          // if (Math.abs( dot ) < this.precision){
          //     continue;
          // }
          // calc distance to plane

          var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

          if (scalar < 0) {
            continue;
          } // Intersection point is from + direction * scalar


          localDirection.scale(scalar, intersectPoint);
          intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

          mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
          mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
          var squaredDistance = intersectPoint.distanceSquared(localFrom);

          if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
            continue;
          } // transform intersectpoint and normal to world


          Transform.vectorToWorldFrame(quat, normal, worldNormal);
          Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
          this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
        }

        triangles.length = 0;
      };

      Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;
      /**
       * @method reportIntersection
       * @private
       * @param  {Vec3} normal
       * @param  {Vec3} hitPointWorld
       * @param  {Shape} shape
       * @param  {Body} body
       * @return {boolean} True if the intersections should continue
       */

      Ray.prototype.reportIntersection = function (normal, hitPointWorld, shape, body, hitFaceIndex) {
        var from = this.from;
        var to = this.to;
        var distance = from.distanceTo(hitPointWorld);
        var result = this.result; // Skip back faces?

        if (this.skipBackfaces && normal.dot(this._direction) > 0) {
          return;
        }

        result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

        switch (this.mode) {
          case Ray.ALL:
            this.hasHit = true;
            result.set(from, to, normal, hitPointWorld, shape, body, distance);
            result.hasHit = true;
            this.callback(result);
            break;

          case Ray.CLOSEST:
            // Store if closer than current closest
            if (distance < result.distance || !result.hasHit) {
              this.hasHit = true;
              result.hasHit = true;
              result.set(from, to, normal, hitPointWorld, shape, body, distance);
            }

            break;

          case Ray.ANY:
            // Report and stop.
            this.hasHit = true;
            result.hasHit = true;
            result.set(from, to, normal, hitPointWorld, shape, body, distance);
            result._shouldStop = true;
            break;
        }
      };

      var v0 = new Vec3(),
          intersect = new Vec3();

      function distanceFromIntersection(from, direction, position) {
        // v0 is vector from from to position
        position.vsub(from, v0);
        var dot = v0.dot(direction); // intersect = direction*dot + from

        direction.mult(dot, intersect);
        intersect.vadd(from, intersect);
        var distance = position.distanceTo(intersect);
        return distance;
      }
    }, {
      "../collision/AABB": 3,
      "../collision/RaycastResult": 11,
      "../math/Quaternion": 30,
      "../math/Transform": 31,
      "../math/Vec3": 32,
      "../shapes/Box": 39,
      "../shapes/ConvexPolyhedron": 40,
      "../shapes/Shape": 45
    }],
    11: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      module.exports = RaycastResult;
      /**
       * Storage for Ray casting data.
       * @class RaycastResult
       * @constructor
       */

      function RaycastResult() {
        /**
         * @property {Vec3} rayFromWorld
         */
        this.rayFromWorld = new Vec3();
        /**
         * @property {Vec3} rayToWorld
         */

        this.rayToWorld = new Vec3();
        /**
         * @property {Vec3} hitNormalWorld
         */

        this.hitNormalWorld = new Vec3();
        /**
         * @property {Vec3} hitPointWorld
         */

        this.hitPointWorld = new Vec3();
        /**
         * @property {boolean} hasHit
         */

        this.hasHit = false;
        /**
         * The hit shape, or null.
         * @property {Shape} shape
         */

        this.shape = null;
        /**
         * The hit body, or null.
         * @property {Body} body
         */

        this.body = null;
        /**
         * The index of the hit triangle, if the hit shape was a trimesh.
         * @property {number} hitFaceIndex
         * @default -1
         */

        this.hitFaceIndex = -1;
        /**
         * Distance to the hit. Will be set to -1 if there was no hit.
         * @property {number} distance
         * @default -1
         */

        this.distance = -1;
        /**
         * If the ray should stop traversing the bodies.
         * @private
         * @property {Boolean} _shouldStop
         * @default false
         */

        this._shouldStop = false;
      }
      /**
       * Reset all result data.
       * @method reset
       */


      RaycastResult.prototype.reset = function () {
        this.rayFromWorld.setZero();
        this.rayToWorld.setZero();
        this.hitNormalWorld.setZero();
        this.hitPointWorld.setZero();
        this.hasHit = false;
        this.shape = null;
        this.body = null;
        this.hitFaceIndex = -1;
        this.distance = -1;
        this._shouldStop = false;
      };
      /**
       * @method abort
       */


      RaycastResult.prototype.abort = function () {
        this._shouldStop = true;
      };
      /**
       * @method set
       * @param {Vec3} rayFromWorld
       * @param {Vec3} rayToWorld
       * @param {Vec3} hitNormalWorld
       * @param {Vec3} hitPointWorld
       * @param {Shape} shape
       * @param {Body} body
       * @param {number} distance
       */


      RaycastResult.prototype.set = function (rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
        this.rayFromWorld.copy(rayFromWorld);
        this.rayToWorld.copy(rayToWorld);
        this.hitNormalWorld.copy(hitNormalWorld);
        this.hitPointWorld.copy(hitPointWorld);
        this.shape = shape;
        this.body = body;
        this.distance = distance;
      };
    }, {
      "../math/Vec3": 32
    }],
    12: [function (_dereq_, module, exports) {
      var Shape = _dereq_('../shapes/Shape');

      var Broadphase = _dereq_('../collision/Broadphase');

      module.exports = SAPBroadphase;
      /**
       * Sweep and prune broadphase along one axis.
       *
       * @class SAPBroadphase
       * @constructor
       * @param {World} [world]
       * @extends Broadphase
       */

      function SAPBroadphase(world) {
        Broadphase.apply(this);
        /**
         * List of bodies currently in the broadphase.
         * @property axisList
         * @type {Array}
         */

        this.axisList = [];
        /**
         * The world to search in.
         * @property world
         * @type {World}
         */

        this.world = null;
        /**
         * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
         * @property axisIndex
         * @type {Number}
         */

        this.axisIndex = 0;
        var axisList = this.axisList;

        this._addBodyHandler = function (e) {
          axisList.push(e.body);
        };

        this._removeBodyHandler = function (e) {
          var idx = axisList.indexOf(e.body);

          if (idx !== -1) {
            axisList.splice(idx, 1);
          }
        };

        if (world) {
          this.setWorld(world);
        }
      }

      SAPBroadphase.prototype = new Broadphase();
      /**
       * Change the world
       * @method setWorld
       * @param  {World} world
       */

      SAPBroadphase.prototype.setWorld = function (world) {
        // Clear the old axis array
        this.axisList.length = 0; // Add all bodies from the new world

        for (var i = 0; i < world.bodies.length; i++) {
          this.axisList.push(world.bodies[i]);
        } // Remove old handlers, if any


        world.removeEventListener("addBody", this._addBodyHandler);
        world.removeEventListener("removeBody", this._removeBodyHandler); // Add handlers to update the list of bodies.

        world.addEventListener("addBody", this._addBodyHandler);
        world.addEventListener("removeBody", this._removeBodyHandler);
        this.world = world;
        this.dirty = true;
      };
      /**
       * @static
       * @method insertionSortX
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortX = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * @static
       * @method insertionSortY
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortY = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * @static
       * @method insertionSortZ
       * @param  {Array} a
       * @return {Array}
       */


      SAPBroadphase.insertionSortZ = function (a) {
        for (var i = 1, l = a.length; i < l; i++) {
          var v = a[i];

          for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
              break;
            }

            a[j + 1] = a[j];
          }

          a[j + 1] = v;
        }

        return a;
      };
      /**
       * Collect all collision pairs
       * @method collisionPairs
       * @param  {World} world
       * @param  {Array} p1
       * @param  {Array} p2
       */


      SAPBroadphase.prototype.collisionPairs = function (world, p1, p2) {
        var bodies = this.axisList,
            N = bodies.length,
            axisIndex = this.axisIndex,
            i,
            j;

        if (this.dirty) {
          this.sortList();
          this.dirty = false;
        } // Look through the list


        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          for (j = i + 1; j < N; j++) {
            var bj = bodies[j];

            if (!this.needBroadphaseCollision(bi, bj)) {
              continue;
            }

            if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
              break;
            }

            this.intersectionTest(bi, bj, p1, p2);
          }
        }
      };

      SAPBroadphase.prototype.sortList = function () {
        var axisList = this.axisList;
        var axisIndex = this.axisIndex;
        var N = axisList.length; // Update AABBs

        for (var i = 0; i !== N; i++) {
          var bi = axisList[i];

          if (bi.aabbNeedsUpdate) {
            bi.computeAABB();
          }
        } // Sort the list


        if (axisIndex === 0) {
          SAPBroadphase.insertionSortX(axisList);
        } else if (axisIndex === 1) {
          SAPBroadphase.insertionSortY(axisList);
        } else if (axisIndex === 2) {
          SAPBroadphase.insertionSortZ(axisList);
        }
      };
      /**
       * Check if the bounds of two bodies overlap, along the given SAP axis.
       * @static
       * @method checkBounds
       * @param  {Body} bi
       * @param  {Body} bj
       * @param  {Number} axisIndex
       * @return {Boolean}
       */


      SAPBroadphase.checkBounds = function (bi, bj, axisIndex) {
        var biPos;
        var bjPos;

        if (axisIndex === 0) {
          biPos = bi.position.x;
          bjPos = bj.position.x;
        } else if (axisIndex === 1) {
          biPos = bi.position.y;
          bjPos = bj.position.y;
        } else if (axisIndex === 2) {
          biPos = bi.position.z;
          bjPos = bj.position.z;
        }

        var ri = bi.boundingRadius,
            rj = bj.boundingRadius,
            boundA1 = biPos - ri,
            boundA2 = biPos + ri,
            boundB1 = bjPos - rj,
            boundB2 = bjPos + rj;
        return boundB1 < boundA2;
      };
      /**
       * Computes the variance of the body positions and estimates the best
       * axis to use. Will automatically set property .axisIndex.
       * @method autoDetectAxis
       */


      SAPBroadphase.prototype.autoDetectAxis = function () {
        var sumX = 0,
            sumX2 = 0,
            sumY = 0,
            sumY2 = 0,
            sumZ = 0,
            sumZ2 = 0,
            bodies = this.axisList,
            N = bodies.length,
            invN = 1 / N;

        for (var i = 0; i !== N; i++) {
          var b = bodies[i];
          var centerX = b.position.x;
          sumX += centerX;
          sumX2 += centerX * centerX;
          var centerY = b.position.y;
          sumY += centerY;
          sumY2 += centerY * centerY;
          var centerZ = b.position.z;
          sumZ += centerZ;
          sumZ2 += centerZ * centerZ;
        }

        var varianceX = sumX2 - sumX * sumX * invN,
            varianceY = sumY2 - sumY * sumY * invN,
            varianceZ = sumZ2 - sumZ * sumZ * invN;

        if (varianceX > varianceY) {
          if (varianceX > varianceZ) {
            this.axisIndex = 0;
          } else {
            this.axisIndex = 2;
          }
        } else if (varianceY > varianceZ) {
          this.axisIndex = 1;
        } else {
          this.axisIndex = 2;
        }
      };
      /**
       * Returns all the bodies within an AABB.
       * @method aabbQuery
       * @param  {World} world
       * @param  {AABB} aabb
       * @param {array} result An array to store resulting bodies in.
       * @return {array}
       */


      SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];

        if (this.dirty) {
          this.sortList();
          this.dirty = false;
        }

        var axisIndex = this.axisIndex,
            axis = 'x';

        if (axisIndex === 1) {
          axis = 'y';
        }

        if (axisIndex === 2) {
          axis = 'z';
        }

        var axisList = this.axisList;
        var lower = aabb.lowerBound[axis];
        var upper = aabb.upperBound[axis];

        for (var i = 0; i < axisList.length; i++) {
          var b = axisList[i];

          if (b.aabbNeedsUpdate) {
            b.computeAABB();
          }

          if (b.aabb.overlaps(aabb)) {
            result.push(b);
          }
        }

        return result;
      };
    }, {
      "../collision/Broadphase": 5,
      "../shapes/Shape": 45
    }],
    13: [function (_dereq_, module, exports) {
      module.exports = ConeTwistConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var ConeEquation = _dereq_('../equations/ConeEquation');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * @class ConeTwistConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Vec3} [options.pivotA]
       * @param {Vec3} [options.pivotB]
       * @param {Vec3} [options.axisA]
       * @param {Vec3} [options.axisB]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function ConeTwistConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

        var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
        var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
        this.collideConnected = !!options.collideConnected;
        this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
        /**
         * @property {ConeEquation} coneEquation
         */

        var c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} twistEquation
         */

        var t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
        this.twistAngle = typeof options.twistAngle !== 'undefined' ? options.twistAngle : 0; // Make the cone equation push the bodies toward the cone axis, not outward

        c.maxForce = 0;
        c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

        t.maxForce = 0;
        t.minForce = -maxForce;
        this.equations.push(c, t);
      }

      ConeTwistConstraint.prototype = new PointToPointConstraint();
      ConeTwistConstraint.constructor = ConeTwistConstraint;
      var ConeTwistConstraint_update_tmpVec1 = new Vec3();
      var ConeTwistConstraint_update_tmpVec2 = new Vec3();

      ConeTwistConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            cone = this.coneEquation,
            twist = this.twistEquation;
        PointToPointConstraint.prototype.update.call(this); // Update the axes to the cone constraint

        bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
        bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

        this.axisA.tangents(twist.axisA, twist.axisA);
        bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
        this.axisB.tangents(twist.axisB, twist.axisB);
        bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
        cone.angle = this.angle;
        twist.maxAngle = this.twistAngle;
      };
    }, {
      "../equations/ConeEquation": 19,
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../math/Vec3": 32,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    14: [function (_dereq_, module, exports) {
      module.exports = Constraint;

      var Utils = _dereq_('../utils/Utils');
      /**
       * Constraint base class
       * @class Constraint
       * @author schteppe
       * @constructor
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {boolean} [options.collideConnected=true]
       * @param {boolean} [options.wakeUpBodies=true]
       */


      function Constraint(bodyA, bodyB, options) {
        options = Utils.defaults(options, {
          collideConnected: true,
          wakeUpBodies: true
        });
        /**
         * Equations to be solved in this constraint
         * @property equations
         * @type {Array}
         */

        this.equations = [];
        /**
         * @property {Body} bodyA
         */

        this.bodyA = bodyA;
        /**
         * @property {Body} bodyB
         */

        this.bodyB = bodyB;
        /**
         * @property {Number} id
         */

        this.id = Constraint.idCounter++;
        /**
         * Set to true if you want the bodies to collide when they are connected.
         * @property collideConnected
         * @type {boolean}
         */

        this.collideConnected = options.collideConnected;

        if (options.wakeUpBodies) {
          if (bodyA) {
            bodyA.wakeUp();
          }

          if (bodyB) {
            bodyB.wakeUp();
          }
        }
      }
      /**
       * Update all the equations with data.
       * @method update
       */


      Constraint.prototype.update = function () {
        throw new Error("method update() not implmemented in this Constraint subclass!");
      };
      /**
       * Enables all equations in the constraint.
       * @method enable
       */


      Constraint.prototype.enable = function () {
        var eqs = this.equations;

        for (var i = 0; i < eqs.length; i++) {
          eqs[i].enabled = true;
        }
      };
      /**
       * Disables all equations in the constraint.
       * @method disable
       */


      Constraint.prototype.disable = function () {
        var eqs = this.equations;

        for (var i = 0; i < eqs.length; i++) {
          eqs[i].enabled = false;
        }
      };

      Constraint.idCounter = 0;
    }, {
      "../utils/Utils": 55
    }],
    15: [function (_dereq_, module, exports) {
      module.exports = DistanceConstraint;

      var Constraint = _dereq_('./Constraint');

      var ContactEquation = _dereq_('../equations/ContactEquation');
      /**
       * Constrains two bodies to be at a constant distance from each others center of mass.
       * @class DistanceConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
       * @param {Number} [maxForce=1e6]
       * @extends Constraint
       */


      function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
        Constraint.call(this, bodyA, bodyB);

        if (typeof distance === "undefined") {
          distance = bodyA.position.distanceTo(bodyB.position);
        }

        if (typeof maxForce === "undefined") {
          maxForce = 1e6;
        }
        /**
         * @property {number} distance
         */


        this.distance = distance;
        /**
         * @property {ContactEquation} distanceEquation
         */

        var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
        this.equations.push(eq); // Make it bidirectional

        eq.minForce = -maxForce;
        eq.maxForce = maxForce;
      }

      DistanceConstraint.prototype = new Constraint();

      DistanceConstraint.prototype.update = function () {
        var bodyA = this.bodyA;
        var bodyB = this.bodyB;
        var eq = this.distanceEquation;
        var halfDist = this.distance * 0.5;
        var normal = eq.ni;
        bodyB.position.vsub(bodyA.position, normal);
        normal.normalize();
        normal.mult(halfDist, eq.ri);
        normal.mult(-halfDist, eq.rj);
      };
    }, {
      "../equations/ContactEquation": 20,
      "./Constraint": 14
    }],
    16: [function (_dereq_, module, exports) {
      module.exports = HingeConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
       * @class HingeConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
       * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
       * @param {Vec3} [options.pivotB]
       * @param {Vec3} [options.axisB]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function HingeConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
        var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
        /**
         * Rotation axis, defined locally in bodyA.
         * @property {Vec3} axisA
         */

        var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        axisA.normalize();
        /**
         * Rotation axis, defined locally in bodyB.
         * @property {Vec3} axisB
         */

        var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
        axisB.normalize();
        /**
         * @property {RotationalEquation} rotationalEquation1
         */

        var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation2
         */

        var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalMotorEquation} motorEquation
         */

        var motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
        motor.enabled = false; // Not enabled by default
        // Equations to be fed to the solver

        this.equations.push(r1, // rotational1
        r2, // rotational2
        motor);
      }

      HingeConstraint.prototype = new PointToPointConstraint();
      HingeConstraint.constructor = HingeConstraint;
      /**
       * @method enableMotor
       */

      HingeConstraint.prototype.enableMotor = function () {
        this.motorEquation.enabled = true;
      };
      /**
       * @method disableMotor
       */


      HingeConstraint.prototype.disableMotor = function () {
        this.motorEquation.enabled = false;
      };
      /**
       * @method setMotorSpeed
       * @param {number} speed
       */


      HingeConstraint.prototype.setMotorSpeed = function (speed) {
        this.motorEquation.targetVelocity = speed;
      };
      /**
       * @method setMotorMaxForce
       * @param {number} maxForce
       */


      HingeConstraint.prototype.setMotorMaxForce = function (maxForce) {
        this.motorEquation.maxForce = maxForce;
        this.motorEquation.minForce = -maxForce;
      };

      var HingeConstraint_update_tmpVec1 = new Vec3();
      var HingeConstraint_update_tmpVec2 = new Vec3();

      HingeConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            motor = this.motorEquation,
            r1 = this.rotationalEquation1,
            r2 = this.rotationalEquation2,
            worldAxisA = HingeConstraint_update_tmpVec1,
            worldAxisB = HingeConstraint_update_tmpVec2;
        var axisA = this.axisA;
        var axisB = this.axisB;
        PointToPointConstraint.prototype.update.call(this); // Get world axes

        bodyA.quaternion.vmult(axisA, worldAxisA);
        bodyB.quaternion.vmult(axisB, worldAxisB);
        worldAxisA.tangents(r1.axisA, r2.axisA);
        r1.axisB.copy(worldAxisB);
        r2.axisB.copy(worldAxisB);

        if (this.motorEquation.enabled) {
          bodyA.quaternion.vmult(this.axisA, motor.axisA);
          bodyB.quaternion.vmult(this.axisB, motor.axisB);
        }
      };
    }, {
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../equations/RotationalMotorEquation": 24,
      "../math/Vec3": 32,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    17: [function (_dereq_, module, exports) {
      module.exports = LockConstraint;

      var Constraint = _dereq_('./Constraint');

      var PointToPointConstraint = _dereq_('./PointToPointConstraint');

      var RotationalEquation = _dereq_('../equations/RotationalEquation');

      var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Lock constraint. Will remove all degrees of freedom between the bodies.
       * @class LockConstraint
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {object} [options]
       * @param {Number} [options.maxForce=1e6]
       * @extends PointToPointConstraint
       */


      function LockConstraint(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

        var pivotA = new Vec3();
        var pivotB = new Vec3();
        var halfWay = new Vec3();
        bodyA.position.vadd(bodyB.position, halfWay);
        halfWay.scale(0.5, halfWay);
        bodyB.pointToLocalFrame(halfWay, pivotB);
        bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

        PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

        this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
        this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
        this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
        this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
        this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
        this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

        /**
         * @property {RotationalEquation} rotationalEquation1
         */

        var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation2
         */

        var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
        /**
         * @property {RotationalEquation} rotationalEquation3
         */

        var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
        this.equations.push(r1, r2, r3);
      }

      LockConstraint.prototype = new PointToPointConstraint();
      LockConstraint.constructor = LockConstraint;
      var LockConstraint_update_tmpVec1 = new Vec3();
      var LockConstraint_update_tmpVec2 = new Vec3();

      LockConstraint.prototype.update = function () {
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            motor = this.motorEquation,
            r1 = this.rotationalEquation1,
            r2 = this.rotationalEquation2,
            r3 = this.rotationalEquation3,
            worldAxisA = LockConstraint_update_tmpVec1,
            worldAxisB = LockConstraint_update_tmpVec2;
        PointToPointConstraint.prototype.update.call(this); // These vector pairs must be orthogonal

        bodyA.vectorToWorldFrame(this.xA, r1.axisA);
        bodyB.vectorToWorldFrame(this.yB, r1.axisB);
        bodyA.vectorToWorldFrame(this.yA, r2.axisA);
        bodyB.vectorToWorldFrame(this.zB, r2.axisB);
        bodyA.vectorToWorldFrame(this.zA, r3.axisA);
        bodyB.vectorToWorldFrame(this.xB, r3.axisB);
      };
    }, {
      "../equations/ContactEquation": 20,
      "../equations/RotationalEquation": 23,
      "../equations/RotationalMotorEquation": 24,
      "../math/Vec3": 32,
      "./Constraint": 14,
      "./PointToPointConstraint": 18
    }],
    18: [function (_dereq_, module, exports) {
      module.exports = PointToPointConstraint;

      var Constraint = _dereq_('./Constraint');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Connects two bodies at given offset points.
       * @class PointToPointConstraint
       * @extends Constraint
       * @constructor
       * @param {Body} bodyA
       * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
       * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
       * @param {Vec3} pivotB See pivotA.
       * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
       *
       * @example
       *     var bodyA = new Body({ mass: 1 });
       *     var bodyB = new Body({ mass: 1 });
       *     bodyA.position.set(-1, 0, 0);
       *     bodyB.position.set(1, 0, 0);
       *     bodyA.addShape(shapeA);
       *     bodyB.addShape(shapeB);
       *     world.addBody(bodyA);
       *     world.addBody(bodyB);
       *     var localPivotA = new Vec3(1, 0, 0);
       *     var localPivotB = new Vec3(-1, 0, 0);
       *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
       *     world.addConstraint(constraint);
       */


      function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
        Constraint.call(this, bodyA, bodyB);
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        /**
         * Pivot, defined locally in bodyA.
         * @property {Vec3} pivotA
         */

        this.pivotA = pivotA ? pivotA.clone() : new Vec3();
        /**
         * Pivot, defined locally in bodyB.
         * @property {Vec3} pivotB
         */

        this.pivotB = pivotB ? pivotB.clone() : new Vec3();
        /**
         * @property {ContactEquation} equationX
         */

        var x = this.equationX = new ContactEquation(bodyA, bodyB);
        /**
         * @property {ContactEquation} equationY
         */

        var y = this.equationY = new ContactEquation(bodyA, bodyB);
        /**
         * @property {ContactEquation} equationZ
         */

        var z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver

        this.equations.push(x, y, z); // Make the equations bidirectional

        x.minForce = y.minForce = z.minForce = -maxForce;
        x.maxForce = y.maxForce = z.maxForce = maxForce;
        x.ni.set(1, 0, 0);
        y.ni.set(0, 1, 0);
        z.ni.set(0, 0, 1);
      }

      PointToPointConstraint.prototype = new Constraint();

      PointToPointConstraint.prototype.update = function () {
        var bodyA = this.bodyA;
        var bodyB = this.bodyB;
        var x = this.equationX;
        var y = this.equationY;
        var z = this.equationZ; // Rotate the pivots to world space

        bodyA.quaternion.vmult(this.pivotA, x.ri);
        bodyB.quaternion.vmult(this.pivotB, x.rj);
        y.ri.copy(x.ri);
        y.rj.copy(x.rj);
        z.ri.copy(x.ri);
        z.rj.copy(x.rj);
      };
    }, {
      "../equations/ContactEquation": 20,
      "../math/Vec3": 32,
      "./Constraint": 14
    }],
    19: [function (_dereq_, module, exports) {
      module.exports = ConeEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');

      var CMath = _dereq_('../math/CMath');
      /**
       * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
       * @class ConeEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Vec3} [options.axisA] Local axis in A
       * @param {Vec3} [options.axisB] Local axis in B
       * @param {Vec3} [options.angle] The "cone angle" to keep
       * @param {number} [options.maxForce=1e6]
       * @extends Equation
       */


      function ConeEquation(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
        /**
         * The cone angle to keep
         * @property {number} angle
         */

        this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
      }

      ConeEquation.prototype = new Equation();
      ConeEquation.prototype.constructor = ConeEquation;
      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();

      ConeEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            ni = this.axisA,
            nj = this.axisB,
            nixnj = tmpVec1,
            njxni = tmpVec2,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // Caluclate cross products

        ni.cross(nj, nixnj);
        nj.cross(ni, njxni); // The angle between two vector is:
        // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
        // g = a * b
        // gdot = (b x a) * wi + (a x b) * wj
        // G = [0 bxa 0 axb]
        // W = [vi wi vj wj]

        GA.rotational.copy(njxni);
        GB.rotational.copy(nixnj);
        var g = CMath.cos(this.angle) - ni.dot(nj),
            GW = this.computeGW(),
            GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/CMath": 27,
      "../math/Mat3": 29,
      "../math/Vec3": 32,
      "./Equation": 21
    }],
    20: [function (_dereq_, module, exports) {
      module.exports = ContactEquation;

      var Equation = _dereq_('./Equation');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');
      /**
       * Contact/non-penetration constraint equation
       * @class ContactEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @extends Equation
       */


      function ContactEquation(bodyA, bodyB, maxForce) {
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, 0, maxForce);
        /**
         * @property si
         * @type {Shape}
         */

        this.si = null;
        /**
         * @property sj
         * @type {Shape}
         */

        this.sj = null;
        /**
         * @property restitution
         * @type {Number}
         */

        this.restitution = 0.0; // "bounciness": u1 = -e*u0

        /**
         * World-oriented vector that goes from the center of bi to the contact point.
         * @property {Vec3} ri
         */

        this.ri = new Vec3();
        /**
         * World-oriented vector that starts in body j position and goes to the contact point.
         * @property {Vec3} rj
         */

        this.rj = new Vec3();
        /**
         * Contact normal, pointing out of body i.
         * @property {Vec3} ni
         */

        this.ni = new Vec3();
      }

      ContactEquation.prototype = new Equation();
      ContactEquation.prototype.constructor = ContactEquation;
      var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

      var ContactEquation_computeB_temp2 = new Vec3();
      var ContactEquation_computeB_temp3 = new Vec3();

      ContactEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            ri = this.ri,
            rj = this.rj,
            rixn = ContactEquation_computeB_temp1,
            rjxn = ContactEquation_computeB_temp2,
            vi = bi.velocity,
            wi = bi.angularVelocity,
            fi = bi.force,
            taui = bi.torque,
            vj = bj.velocity,
            wj = bj.angularVelocity,
            fj = bj.force,
            tauj = bj.torque,
            penetrationVec = ContactEquation_computeB_temp3,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            n = this.ni; // Caluclate cross products

        ri.cross(n, rixn);
        rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
        // G = [ -ni  -rixn  ni  rjxn ]

        n.negate(GA.spatial);
        rixn.negate(GA.rotational);
        GB.spatial.copy(n);
        GB.rotational.copy(rjxn); // Calculate the penetration vector

        penetrationVec.copy(bj.position);
        penetrationVec.vadd(rj, penetrationVec);
        penetrationVec.vsub(bi.position, penetrationVec);
        penetrationVec.vsub(ri, penetrationVec);
        var g = n.dot(penetrationVec); // Compute iteration

        var ePlusOne = this.restitution + 1;
        var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
        var GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };

      var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
      var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
      /**
       * Get the current relative velocity in the contact point.
       * @method getImpactVelocityAlongNormal
       * @return {number}
       */

      ContactEquation.prototype.getImpactVelocityAlongNormal = function () {
        var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
        var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
        var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
        var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
        var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
        this.bi.position.vadd(this.ri, xi);
        this.bj.position.vadd(this.rj, xj);
        this.bi.getVelocityAtWorldPoint(xi, vi);
        this.bj.getVelocityAtWorldPoint(xj, vj);
        vi.vsub(vj, relVel);
        return this.ni.dot(relVel);
      };
    }, {
      "../math/Mat3": 29,
      "../math/Vec3": 32,
      "./Equation": 21
    }],
    21: [function (_dereq_, module, exports) {
      module.exports = Equation;

      var JacobianElement = _dereq_('../math/JacobianElement'),
          Vec3 = _dereq_('../math/Vec3');
      /**
       * Equation base class
       * @class Equation
       * @constructor
       * @author schteppe
       * @param {Body} bi
       * @param {Body} bj
       * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
       * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
       */


      function Equation(bi, bj, minForce, maxForce) {
        this.id = Equation.id++;
        /**
         * @property {number} minForce
         */

        this.minForce = typeof minForce === "undefined" ? -1e6 : minForce;
        /**
         * @property {number} maxForce
         */

        this.maxForce = typeof maxForce === "undefined" ? 1e6 : maxForce;
        /**
         * @property bi
         * @type {Body}
         */

        this.bi = bi;
        /**
         * @property bj
         * @type {Body}
         */

        this.bj = bj;
        /**
         * SPOOK parameter
         * @property {number} a
         */

        this.a = 0.0;
        /**
         * SPOOK parameter
         * @property {number} b
         */

        this.b = 0.0;
        /**
         * SPOOK parameter
         * @property {number} eps
         */

        this.eps = 0.0;
        /**
         * @property {JacobianElement} jacobianElementA
         */

        this.jacobianElementA = new JacobianElement();
        /**
         * @property {JacobianElement} jacobianElementB
         */

        this.jacobianElementB = new JacobianElement();
        /**
         * @property {boolean} enabled
         * @default true
         */

        this.enabled = true;
        /**
         * A number, proportional to the force added to the bodies.
         * @property {number} multiplier
         * @readonly
         */

        this.multiplier = 0; // Set typical spook params

        this.setSpookParams(1e7, 4, 1 / 60);
      }

      Equation.prototype.constructor = Equation;
      Equation.id = 0;
      /**
       * Recalculates a,b,eps.
       * @method setSpookParams
       */

      Equation.prototype.setSpookParams = function (stiffness, relaxation, timeStep) {
        var d = relaxation,
            k = stiffness,
            h = timeStep;
        this.a = 4.0 / (h * (1 + 4 * d));
        this.b = 4.0 * d / (1 + 4 * d);
        this.eps = 4.0 / (h * h * k * (1 + 4 * d));
      };
      /**
       * Computes the RHS of the SPOOK equation
       * @method computeB
       * @return {Number}
       */


      Equation.prototype.computeB = function (a, b, h) {
        var GW = this.computeGW(),
            Gq = this.computeGq(),
            GiMf = this.computeGiMf();
        return -Gq * a - GW * b - GiMf * h;
      };
      /**
       * Computes G*q, where q are the generalized body coordinates
       * @method computeGq
       * @return {Number}
       */


      Equation.prototype.computeGq = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            xi = bi.position,
            xj = bj.position;
        return GA.spatial.dot(xi) + GB.spatial.dot(xj);
      };

      var zero = new Vec3();
      /**
       * Computes G*W, where W are the body velocities
       * @method computeGW
       * @return {Number}
       */

      Equation.prototype.computeGW = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
      };
      /**
       * Computes G*Wlambda, where W are the body velocities
       * @method computeGWlambda
       * @return {Number}
       */


      Equation.prototype.computeGWlambda = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            vi = bi.vlambda,
            vj = bj.vlambda,
            wi = bi.wlambda,
            wj = bj.wlambda;
        return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
      };
      /**
       * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
       * @method computeGiMf
       * @return {Number}
       */


      var iMfi = new Vec3(),
          iMfj = new Vec3(),
          invIi_vmult_taui = new Vec3(),
          invIj_vmult_tauj = new Vec3();

      Equation.prototype.computeGiMf = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            fi = bi.force,
            ti = bi.torque,
            fj = bj.force,
            tj = bj.torque,
            invMassi = bi.invMassSolve,
            invMassj = bj.invMassSolve;
        fi.scale(invMassi, iMfi);
        fj.scale(invMassj, iMfj);
        bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
        bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
        return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
      };
      /**
       * Computes G*inv(M)*G'
       * @method computeGiMGt
       * @return {Number}
       */


      var tmp = new Vec3();

      Equation.prototype.computeGiMGt = function () {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            invMassi = bi.invMassSolve,
            invMassj = bj.invMassSolve,
            invIi = bi.invInertiaWorldSolve,
            invIj = bj.invInertiaWorldSolve,
            result = invMassi + invMassj;
        invIi.vmult(GA.rotational, tmp);
        result += tmp.dot(GA.rotational);
        invIj.vmult(GB.rotational, tmp);
        result += tmp.dot(GB.rotational);
        return result;
      };

      var addToWlambda_temp = new Vec3(),
          addToWlambda_Gi = new Vec3(),
          addToWlambda_Gj = new Vec3(),
          addToWlambda_ri = new Vec3(),
          addToWlambda_rj = new Vec3(),
          addToWlambda_Mdiag = new Vec3();
      /**
       * Add constraint velocity to the bodies.
       * @method addToWlambda
       * @param {Number} deltalambda
       */

      Equation.prototype.addToWlambda = function (deltalambda) {
        var GA = this.jacobianElementA,
            GB = this.jacobianElementB,
            bi = this.bi,
            bj = this.bj,
            temp = addToWlambda_temp; // Add to linear velocity
        // v_lambda += inv(M) * delta_lamba * G

        bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
        bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

        bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
        bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
        bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
        bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
      };
      /**
       * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
       * @method computeInvC
       * @param  {Number} eps
       * @return {Number}
       */


      Equation.prototype.computeC = function () {
        return this.computeGiMGt() + this.eps;
      };
    }, {
      "../math/JacobianElement": 28,
      "../math/Vec3": 32
    }],
    22: [function (_dereq_, module, exports) {
      module.exports = FrictionEquation;

      var Equation = _dereq_('./Equation');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');
      /**
       * Constrains the slipping in a contact along a tangent
       * @class FrictionEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
       * @extends Equation
       */


      function FrictionEquation(bodyA, bodyB, slipForce) {
        Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
        this.ri = new Vec3();
        this.rj = new Vec3();
        this.t = new Vec3(); // tangent
      }

      FrictionEquation.prototype = new Equation();
      FrictionEquation.prototype.constructor = FrictionEquation;
      var FrictionEquation_computeB_temp1 = new Vec3();
      var FrictionEquation_computeB_temp2 = new Vec3();

      FrictionEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            ri = this.ri,
            rj = this.rj,
            rixt = FrictionEquation_computeB_temp1,
            rjxt = FrictionEquation_computeB_temp2,
            t = this.t; // Caluclate cross products

        ri.cross(t, rixt);
        rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
        // And remember, this is a pure velocity constraint, g is always zero!

        var GA = this.jacobianElementA,
            GB = this.jacobianElementB;
        t.negate(GA.spatial);
        rixt.negate(GA.rotational);
        GB.spatial.copy(t);
        GB.rotational.copy(rjxt);
        var GW = this.computeGW();
        var GiMf = this.computeGiMf();
        var B = -GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 29,
      "../math/Vec3": 32,
      "./Equation": 21
    }],
    23: [function (_dereq_, module, exports) {
      module.exports = RotationalEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');

      var CMath = _dereq_('../math/CMath');
      /**
       * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
       * @class RotationalEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Vec3} [options.axisA]
       * @param {Vec3} [options.axisB]
       * @param {number} [options.maxForce]
       * @extends Equation
       */


      function RotationalEquation(bodyA, bodyB, options) {
        options = options || {};
        var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
        this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
        this.maxAngle = Math.PI / 2;
      }

      RotationalEquation.prototype = new Equation();
      RotationalEquation.prototype.constructor = RotationalEquation;
      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();

      RotationalEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            ni = this.axisA,
            nj = this.axisB,
            nixnj = tmpVec1,
            njxni = tmpVec2,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // Caluclate cross products

        ni.cross(nj, nixnj);
        nj.cross(ni, njxni); // g = ni * nj
        // gdot = (nj x ni) * wi + (ni x nj) * wj
        // G = [0 njxni 0 nixnj]
        // W = [vi wi vj wj]

        GA.rotational.copy(njxni);
        GB.rotational.copy(nixnj);
        var g = CMath.cos(this.maxAngle) - ni.dot(nj),
            GW = this.computeGW(),
            GiMf = this.computeGiMf();
        var B = -g * a - GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/CMath": 27,
      "../math/Mat3": 29,
      "../math/Vec3": 32,
      "./Equation": 21
    }],
    24: [function (_dereq_, module, exports) {
      module.exports = RotationalMotorEquation;

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Equation = _dereq_('./Equation');
      /**
       * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
       * @class RotationalMotorEquation
       * @constructor
       * @author schteppe
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Number} maxForce
       * @extends Equation
       */


      function RotationalMotorEquation(bodyA, bodyB, maxForce) {
        maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;
        Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
        /**
         * World oriented rotational axis
         * @property {Vec3} axisA
         */

        this.axisA = new Vec3();
        /**
         * World oriented rotational axis
         * @property {Vec3} axisB
         */

        this.axisB = new Vec3(); // World oriented rotational axis

        /**
         * Motor velocity
         * @property {Number} targetVelocity
         */

        this.targetVelocity = 0;
      }

      RotationalMotorEquation.prototype = new Equation();
      RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

      RotationalMotorEquation.prototype.computeB = function (h) {
        var a = this.a,
            b = this.b,
            bi = this.bi,
            bj = this.bj,
            axisA = this.axisA,
            axisB = this.axisB,
            GA = this.jacobianElementA,
            GB = this.jacobianElementB; // g = 0
        // gdot = axisA * wi - axisB * wj
        // gdot = G * W = G * [vi wi vj wj]
        // =>
        // G = [0 axisA 0 -axisB]

        GA.rotational.copy(axisA);
        axisB.negate(GB.rotational);
        var GW = this.computeGW() - this.targetVelocity,
            GiMf = this.computeGiMf();
        var B = -GW * b - h * GiMf;
        return B;
      };
    }, {
      "../math/Mat3": 29,
      "../math/Vec3": 32,
      "./Equation": 21
    }],
    25: [function (_dereq_, module, exports) {
      var Utils = _dereq_('../utils/Utils');

      module.exports = ContactMaterial;
      /**
       * Defines what happens when two materials meet.
       * @class ContactMaterial
       * @constructor
       * @param {Material} m1
       * @param {Material} m2
       * @param {object} [options]
       * @param {Number} [options.friction=0.3]
       * @param {Number} [options.restitution=0.3]
       * @param {number} [options.contactEquationStiffness=1e7]
       * @param {number} [options.contactEquationRelaxation=3]
       * @param {number} [options.frictionEquationStiffness=1e7]
       * @param {Number} [options.frictionEquationRelaxation=3]
       */

      function ContactMaterial(m1, m2, options) {
        options = Utils.defaults(options, {
          friction: 0.3,
          restitution: 0.3,
          contactEquationStiffness: 1e7,
          contactEquationRelaxation: 3,
          frictionEquationStiffness: 1e7,
          frictionEquationRelaxation: 3
        });
        /**
         * Identifier of this material
         * @property {Number} id
         */

        this.id = ContactMaterial.idCounter++;
        /**
         * Participating materials
         * @property {Array} materials
         * @todo  Should be .materialA and .materialB instead
         */

        this.materials = [m1, m2];
        /**
         * Friction coefficient
         * @property {Number} friction
         */

        this.friction = options.friction;
        /**
         * Restitution coefficient
         * @property {Number} restitution
         */

        this.restitution = options.restitution;
        /**
         * Stiffness of the produced contact equations
         * @property {Number} contactEquationStiffness
         */

        this.contactEquationStiffness = options.contactEquationStiffness;
        /**
         * Relaxation time of the produced contact equations
         * @property {Number} contactEquationRelaxation
         */

        this.contactEquationRelaxation = options.contactEquationRelaxation;
        /**
         * Stiffness of the produced friction equations
         * @property {Number} frictionEquationStiffness
         */

        this.frictionEquationStiffness = options.frictionEquationStiffness;
        /**
         * Relaxation time of the produced friction equations
         * @property {Number} frictionEquationRelaxation
         */

        this.frictionEquationRelaxation = options.frictionEquationRelaxation;
      }

      ContactMaterial.idCounter = 0;
    }, {
      "../utils/Utils": 55
    }],
    26: [function (_dereq_, module, exports) {
      module.exports = Material;
      /**
       * Defines a physics material.
       * @class Material
       * @constructor
       * @param {object} [options]
       * @author schteppe
       */

      function Material(options) {
        var name = '';
        options = options || {}; // Backwards compatibility fix

        if (typeof options === 'string') {
          name = options;
          options = {};
        } else if (typeof options === 'object') {
          name = '';
        }
        /**
         * @property name
         * @type {String}
         */


        this.name = name;
        /**
         * material id.
         * @property id
         * @type {number}
         */

        this.id = Material.idCounter++;
        /**
         * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
         * @property {number} friction
         */

        this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
        /**
         * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
         * @property {number} restitution
         */

        this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
      }

      Material.idCounter = 0;
    }, {}],
    27: [function (_dereq_, module, exports) {
      var rad2ang = 180 / Math.PI;

      function radian2angle(rad) {
        return rad * rad2ang;
      }

      var sinArr = {};

      function calculateSinByDigit(digit) {
        if (sinArr.digit == digit) return;
        var step = 1 / Math.pow(10, digit);

        for (var i = 0; i <= 90; i += step) {
          sinArr[i.toFixed(digit)] = Math.sin(i / rad2ang);
        }

        sinArr.digit = digit;
      }

      function sin360(angle, digit) {
        if (angle <= 90) {
          return sinArr[angle.toFixed(digit)];
        } else if (angle <= 180) {
          angle = 180 - angle;
          return sinArr[angle.toFixed(digit)];
        } else if (angle <= 270) {
          angle = angle - 180;
          return -sinArr[angle.toFixed(digit)];
        } else {
          angle = 360 - angle;
          return -sinArr[angle.toFixed(digit)];
        }
      }

      function sin(rad) {
        var angle = radian2angle(rad) % 360;

        if (angle < 0) {
          angle += 360;
        }

        return sin360(angle, CMath._digit);
      }

      function cos(rad) {
        var angle = (radian2angle(rad) + 90) % 360;

        if (angle < 0) {
          angle += 360;
        }

        return sin360(angle, CMath._digit);
      }

      function sinNative(rad) {
        return Math.sin(rad).toFixed(CMath.digit);
      }

      function cosNative(rad) {
        return Math.cos(rad).toFixed(CMath.digit);
      }

      var CMath = {
        sin: Math.sin,
        cos: Math.cos,
        atan2: Math.atan2
      };
      CMath._sin = sin;
      CMath._cos = cos;
      CMath._sinArr = sinArr;
      CMath._sin360 = sin360;
      CMath._sinNative = sinNative;
      CMath._cosNative = cosNative;
      CMath._radian2angle = radian2angle;
      CMath._calculateSinByDigit = calculateSinByDigit;
      CMath._digit = 1;
      Object.defineProperty(CMath, 'digit', {
        'get': function get() {
          return this._digit;
        },
        'set': function set(v) {
          this._digit = v;
          if (this._mode == 1) calculateSinByDigit(v);
        }
      });
      CMath._mode = 0;
      Object.defineProperty(CMath, 'mode', {
        'get': function get() {
          return this._mode;
        },
        'set': function set(v) {
          if (this._mode != v) {
            this._mode = v;

            if (v == 0) {
              CMath.sin = Math.sin;
              CMath.cos = Math.cos;
            } else if (v == 1) {
              CMath.digit = CMath._digit;
              CMath.sin = sin;
              CMath.cos = cos;
            } else if (v == 2) {
              CMath.sin = sinNative;
              CMath.cos = cosNative;
            }
          }
        }
      });
      module.exports = CMath;
    }, {}],
    28: [function (_dereq_, module, exports) {
      module.exports = JacobianElement;

      var Vec3 = _dereq_('./Vec3');
      /**
       * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
       * @class JacobianElement
       * @constructor
       */


      function JacobianElement() {
        /**
         * @property {Vec3} spatial
         */
        this.spatial = new Vec3();
        /**
         * @property {Vec3} rotational
         */

        this.rotational = new Vec3();
      }
      /**
       * Multiply with other JacobianElement
       * @method multiplyElement
       * @param  {JacobianElement} element
       * @return {Number}
       */


      JacobianElement.prototype.multiplyElement = function (element) {
        return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
      };
      /**
       * Multiply with two vectors
       * @method multiplyVectors
       * @param  {Vec3} spatial
       * @param  {Vec3} rotational
       * @return {Number}
       */


      JacobianElement.prototype.multiplyVectors = function (spatial, rotational) {
        return spatial.dot(this.spatial) + rotational.dot(this.rotational);
      };
    }, {
      "./Vec3": 32
    }],
    29: [function (_dereq_, module, exports) {
      module.exports = Mat3;

      var Vec3 = _dereq_('./Vec3');
      /**
       * A 3x3 matrix.
       * @class Mat3
       * @constructor
       * @param array elements Array of nine elements. Optional.
       * @author schteppe / http://github.com/schteppe
       */


      function Mat3(elements) {
        /**
         * A vector of length 9, containing all matrix elements
         * @property {Array} elements
         */
        if (elements) {
          this.elements = elements;
        } else {
          this.elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
      }
      /**
       * Sets the matrix to identity
       * @method identity
       * @todo Should perhaps be renamed to setIdentity() to be more clear.
       * @todo Create another function that immediately creates an identity matrix eg. eye()
       */


      Mat3.prototype.identity = function () {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
      };
      /**
       * Set all elements to zero
       * @method setZero
       */


      Mat3.prototype.setZero = function () {
        var e = this.elements;
        e[0] = 0;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
      };
      /**
       * Sets the matrix diagonal elements from a Vec3
       * @method setTrace
       * @param {Vec3} vec3
       */


      Mat3.prototype.setTrace = function (vec3) {
        var e = this.elements;
        e[0] = vec3.x;
        e[4] = vec3.y;
        e[8] = vec3.z;
      };
      /**
       * Gets the matrix diagonal elements
       * @method getTrace
       * @return {Vec3}
       */


      Mat3.prototype.getTrace = function (target) {
        var target = target || new Vec3();
        var e = this.elements;
        target.x = e[0];
        target.y = e[4];
        target.z = e[8];
      };
      /**
       * Matrix-Vector multiplication
       * @method vmult
       * @param {Vec3} v The vector to multiply with
       * @param {Vec3} target Optional, target to save the result in.
       */


      Mat3.prototype.vmult = function (v, target) {
        target = target || new Vec3();
        var e = this.elements,
            x = v.x,
            y = v.y,
            z = v.z;
        target.x = e[0] * x + e[1] * y + e[2] * z;
        target.y = e[3] * x + e[4] * y + e[5] * z;
        target.z = e[6] * x + e[7] * y + e[8] * z;
        return target;
      };
      /**
       * Matrix-scalar multiplication
       * @method smult
       * @param {Number} s
       */


      Mat3.prototype.smult = function (s) {
        for (var i = 0; i < this.elements.length; i++) {
          this.elements[i] *= s;
        }
      };
      /**
       * Matrix multiplication
       * @method mmult
       * @param {Mat3} m Matrix to multiply with from left side.
       * @return {Mat3} The result.
       */


      Mat3.prototype.mmult = function (m, target) {
        var r = target || new Mat3();

        for (var i = 0; i < 3; i++) {
          for (var j = 0; j < 3; j++) {
            var sum = 0.0;

            for (var k = 0; k < 3; k++) {
              sum += m.elements[i + k * 3] * this.elements[k + j * 3];
            }

            r.elements[i + j * 3] = sum;
          }
        }

        return r;
      };
      /**
       * Scale each column of the matrix
       * @method scale
       * @param {Vec3} v
       * @return {Mat3} The result.
       */


      Mat3.prototype.scale = function (v, target) {
        target = target || new Mat3();
        var e = this.elements,
            t = target.elements;

        for (var i = 0; i !== 3; i++) {
          t[3 * i + 0] = v.x * e[3 * i + 0];
          t[3 * i + 1] = v.y * e[3 * i + 1];
          t[3 * i + 2] = v.z * e[3 * i + 2];
        }

        return target;
      };
      /**
       * Solve Ax=b
       * @method solve
       * @param {Vec3} b The right hand side
       * @param {Vec3} target Optional. Target vector to save in.
       * @return {Vec3} The solution x
       * @todo should reuse arrays
       */


      Mat3.prototype.solve = function (b, target) {
        target = target || new Vec3(); // Construct equations

        var nr = 3; // num rows

        var nc = 4; // num cols

        var eqns = [];

        for (var i = 0; i < nr * nc; i++) {
          eqns.push(0);
        }

        var i, j;

        for (i = 0; i < 3; i++) {
          for (j = 0; j < 3; j++) {
            eqns[i + nc * j] = this.elements[i + 3 * j];
          }
        }

        eqns[3 + 4 * 0] = b.x;
        eqns[3 + 4 * 1] = b.y;
        eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

        var n = 3,
            k = n,
            np;
        var kp = 4; // num rows

        var p, els;

        do {
          i = k - n;

          if (eqns[i + nc * i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
              if (eqns[i + nc * j] !== 0) {
                np = kp;

                do {
                  // do ligne( i ) = ligne( i ) + ligne( k )
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);

                break;
              }
            }
          }

          if (eqns[i + nc * i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
              np = kp;

              do {
                // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                p = kp - np;
                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
              } while (--np);
            }
          }
        } while (--n); // Get the solution


        target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
        target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
        target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

        if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
          throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
        }

        return target;
      };
      /**
       * Get an element in the matrix by index. Index starts at 0, not 1!!!
       * @method e
       * @param {Number} row
       * @param {Number} column
       * @param {Number} value Optional. If provided, the matrix element will be set to this value.
       * @return {Number}
       */


      Mat3.prototype.e = function (row, column, value) {
        if (value === undefined) {
          return this.elements[column + 3 * row];
        } else {
          // Set value
          this.elements[column + 3 * row] = value;
        }
      };
      /**
       * Copy another matrix into this matrix object.
       * @method copy
       * @param {Mat3} source
       * @return {Mat3} this
       */


      Mat3.prototype.copy = function (source) {
        for (var i = 0; i < source.elements.length; i++) {
          this.elements[i] = source.elements[i];
        }

        return this;
      };
      /**
       * Returns a string representation of the matrix.
       * @method toString
       * @return string
       */


      Mat3.prototype.toString = function () {
        var r = "";
        var sep = ",";

        for (var i = 0; i < 9; i++) {
          r += this.elements[i] + sep;
        }

        return r;
      };
      /**
       * reverse the matrix
       * @method reverse
       * @param {Mat3} target Optional. Target matrix to save in.
       * @return {Mat3} The solution x
       */


      Mat3.prototype.reverse = function (target) {
        target = target || new Mat3(); // Construct equations

        var nr = 3; // num rows

        var nc = 6; // num cols

        var eqns = [];

        for (var i = 0; i < nr * nc; i++) {
          eqns.push(0);
        }

        var i, j;

        for (i = 0; i < 3; i++) {
          for (j = 0; j < 3; j++) {
            eqns[i + nc * j] = this.elements[i + 3 * j];
          }
        }

        eqns[3 + 6 * 0] = 1;
        eqns[3 + 6 * 1] = 0;
        eqns[3 + 6 * 2] = 0;
        eqns[4 + 6 * 0] = 0;
        eqns[4 + 6 * 1] = 1;
        eqns[4 + 6 * 2] = 0;
        eqns[5 + 6 * 0] = 0;
        eqns[5 + 6 * 1] = 0;
        eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

        var n = 3,
            k = n,
            np;
        var kp = nc; // num rows

        var p;

        do {
          i = k - n;

          if (eqns[i + nc * i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
              if (eqns[i + nc * j] !== 0) {
                np = kp;

                do {
                  // do line( i ) = line( i ) + line( k )
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);

                break;
              }
            }
          }

          if (eqns[i + nc * i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
              np = kp;

              do {
                // do line( k ) = line( k ) - multiplier * line( i )
                p = kp - np;
                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
              } while (--np);
            }
          }
        } while (--n); // eliminate the upper left triangle of the matrix


        i = 2;

        do {
          j = i - 1;

          do {
            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
            np = nc;

            do {
              p = nc - np;
              eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
            } while (--np);
          } while (j--);
        } while (--i); // operations on the diagonal


        i = 2;

        do {
          var multiplier = 1 / eqns[i + nc * i];
          np = nc;

          do {
            p = nc - np;
            eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
          } while (--np);
        } while (i--);

        i = 2;

        do {
          j = 2;

          do {
            p = eqns[nr + j + nc * i];

            if (isNaN(p) || p === Infinity) {
              throw "Could not reverse! A=[" + this.toString() + "]";
            }

            target.e(i, j, p);
          } while (j--);
        } while (i--);

        return target;
      };
      /**
       * Set the matrix from a quaterion
       * @method setRotationFromQuaternion
       * @param {Quaternion} q
       */


      Mat3.prototype.setRotationFromQuaternion = function (q) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w,
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,
            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2,
            e = this.elements;
        e[3 * 0 + 0] = 1 - (yy + zz);
        e[3 * 0 + 1] = xy - wz;
        e[3 * 0 + 2] = xz + wy;
        e[3 * 1 + 0] = xy + wz;
        e[3 * 1 + 1] = 1 - (xx + zz);
        e[3 * 1 + 2] = yz - wx;
        e[3 * 2 + 0] = xz - wy;
        e[3 * 2 + 1] = yz + wx;
        e[3 * 2 + 2] = 1 - (xx + yy);
        return this;
      };
      /**
       * Transpose the matrix
       * @method transpose
       * @param  {Mat3} target Where to store the result.
       * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
       */


      Mat3.prototype.transpose = function (target) {
        target = target || new Mat3();
        var Mt = target.elements,
            M = this.elements;

        for (var i = 0; i !== 3; i++) {
          for (var j = 0; j !== 3; j++) {
            Mt[3 * i + j] = M[3 * j + i];
          }
        }

        return target;
      };
    }, {
      "./Vec3": 32
    }],
    30: [function (_dereq_, module, exports) {
      module.exports = Quaternion;

      var Vec3 = _dereq_('./Vec3');

      var CMath = _dereq_('./CMath');
      /**
       * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
       * @class Quaternion
       * @constructor
       * @param {Number} x Multiplier of the imaginary basis vector i.
       * @param {Number} y Multiplier of the imaginary basis vector j.
       * @param {Number} z Multiplier of the imaginary basis vector k.
       * @param {Number} w Multiplier of the real part.
       * @see http://en.wikipedia.org/wiki/Quaternion
       */


      function Quaternion(x, y, z, w) {
        /**
         * @property {Number} x
         */
        this.x = x !== undefined ? x : 0;
        /**
         * @property {Number} y
         */

        this.y = y !== undefined ? y : 0;
        /**
         * @property {Number} z
         */

        this.z = z !== undefined ? z : 0;
        /**
         * The multiplier of the real quaternion basis vector.
         * @property {Number} w
         */

        this.w = w !== undefined ? w : 1;
      }
      /**
       * Set the value of the quaternion.
       * @method set
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @param {Number} w
       */


      Quaternion.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      };
      /**
       * Convert to a readable format
       * @method toString
       * @return string
       */


      Quaternion.prototype.toString = function () {
        return this.x + "," + this.y + "," + this.z + "," + this.w;
      };
      /**
       * Convert to an Array
       * @method toArray
       * @return Array
       */


      Quaternion.prototype.toArray = function () {
        return [this.x, this.y, this.z, this.w];
      };
      /**
       * Set the quaternion components given an axis and an angle.
       * @method setFromAxisAngle
       * @param {Vec3} axis
       * @param {Number} angle in radians
       */


      Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
        var s = CMath.sin(angle * 0.5);
        this.x = axis.x * s;
        this.y = axis.y * s;
        this.z = axis.z * s;
        this.w = CMath.cos(angle * 0.5);
        return this;
      };
      /**
       * Converts the quaternion to axis/angle representation.
       * @method toAxisAngle
       * @param {Vec3} [targetAxis] A vector object to reuse for storing the axis.
       * @return {Array} An array, first elemnt is the axis and the second is the angle in radians.
       */


      Quaternion.prototype.toAxisAngle = function (targetAxis) {
        targetAxis = targetAxis || new Vec3();
        this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

        var angle = 2 * Math.acos(this.w);
        var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

        if (s < 0.001) {
          // test to avoid divide by zero, s is always positive due to sqrt
          // if s close to zero then direction of axis not important
          targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

          targetAxis.y = this.y;
          targetAxis.z = this.z;
        } else {
          targetAxis.x = this.x / s; // normalise axis

          targetAxis.y = this.y / s;
          targetAxis.z = this.z / s;
        }

        return [targetAxis, angle];
      };

      var sfv_t1 = new Vec3(),
          sfv_t2 = new Vec3();
      /**
       * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
       * @method setFromVectors
       * @param {Vec3} u
       * @param {Vec3} v
       */

      Quaternion.prototype.setFromVectors = function (u, v) {
        if (u.isAntiparallelTo(v)) {
          var t1 = sfv_t1;
          var t2 = sfv_t2;
          u.tangents(t1, t2);
          this.setFromAxisAngle(t1, Math.PI);
        } else {
          var a = u.cross(v);
          this.x = a.x;
          this.y = a.y;
          this.z = a.z;
          this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v);
          this.normalize();
        }

        return this;
      };
      /**
       * Quaternion multiplication
       * @method mult
       * @param {Quaternion} q
       * @param {Quaternion} target Optional.
       * @return {Quaternion}
       */


      var Quaternion_mult_va = new Vec3();
      var Quaternion_mult_vb = new Vec3();
      var Quaternion_mult_vaxvb = new Vec3();

      Quaternion.prototype.mult = function (q, target) {
        target = target || new Quaternion();
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = q.x,
            by = q.y,
            bz = q.z,
            bw = q.w;
        target.x = ax * bw + aw * bx + ay * bz - az * by;
        target.y = ay * bw + aw * by + az * bx - ax * bz;
        target.z = az * bw + aw * bz + ax * by - ay * bx;
        target.w = aw * bw - ax * bx - ay * by - az * bz;
        return target;
      };
      /**
       * Get the inverse quaternion rotation.
       * @method inverse
       * @param {Quaternion} target
       * @return {Quaternion}
       */


      Quaternion.prototype.inverse = function (target) {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        target = target || new Quaternion();
        this.conjugate(target);
        var inorm2 = 1 / (x * x + y * y + z * z + w * w);
        target.x *= inorm2;
        target.y *= inorm2;
        target.z *= inorm2;
        target.w *= inorm2;
        return target;
      };
      /**
       * Get the quaternion conjugate
       * @method conjugate
       * @param {Quaternion} target
       * @return {Quaternion}
       */


      Quaternion.prototype.conjugate = function (target) {
        target = target || new Quaternion();
        target.x = -this.x;
        target.y = -this.y;
        target.z = -this.z;
        target.w = this.w;
        return target;
      };
      /**
       * Normalize the quaternion. Note that this changes the values of the quaternion.
       * @method normalize
       */


      Quaternion.prototype.normalize = function () {
        var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

        if (l === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        } else {
          l = 1 / l;
          this.x *= l;
          this.y *= l;
          this.z *= l;
          this.w *= l;
        }

        return this;
      };
      /**
       * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
       * @method normalizeFast
       * @see http://jsperf.com/fast-quaternion-normalization
       * @author unphased, https://github.com/unphased
       */


      Quaternion.prototype.normalizeFast = function () {
        var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

        if (f === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        } else {
          this.x *= f;
          this.y *= f;
          this.z *= f;
          this.w *= f;
        }

        return this;
      };
      /**
       * Multiply the quaternion by a vector
       * @method vmult
       * @param {Vec3} v
       * @param {Vec3} target Optional
       * @return {Vec3}
       */


      Quaternion.prototype.vmult = function (v, target) {
        target = target || new Vec3();
        var x = v.x,
            y = v.y,
            z = v.z;
        var qx = this.x,
            qy = this.y,
            qz = this.z,
            qw = this.w; // q*v

        var ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;
        target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return target;
      };
      /**
       * Copies value of source to this quaternion.
       * @method copy
       * @param {Quaternion} source
       * @return {Quaternion} this
       */


      Quaternion.prototype.copy = function (source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        this.w = source.w;
        return this;
      };
      /**
       * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
       * @method toEuler
       * @param {Vec3} target
       * @param string order Three-character string e.g. "YZX", which also is default.
       */


      Quaternion.prototype.toEuler = function (target, order) {
        order = order || "YZX";
        var heading, attitude, bank;
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;

        switch (order) {
          case "YZX":
            var test = x * y + z * w;

            if (test > 0.499) {
              // singularity at north pole
              heading = 2 * CMath.atan2(x, w);
              attitude = Math.PI / 2;
              bank = 0;
            }

            if (test < -0.499) {
              // singularity at south pole
              heading = -2 * CMath.atan2(x, w);
              attitude = -Math.PI / 2;
              bank = 0;
            }

            if (isNaN(heading)) {
              var sqx = x * x;
              var sqy = y * y;
              var sqz = z * z;
              heading = CMath.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

              attitude = Math.asin(2 * test); // attitude

              bank = CMath.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
            }

            break;

          default:
            throw new Error("Euler order " + order + " not supported yet.");
        }

        target.y = heading;
        target.z = attitude;
        target.x = bank;
      };
      /**
       * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
       * @method setFromEuler
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
       */


      Quaternion.prototype.setFromEuler = function (x, y, z, order) {
        order = order || "XYZ";
        var c1 = CMath.cos(x / 2);
        var c2 = CMath.cos(y / 2);
        var c3 = CMath.cos(z / 2);
        var s1 = CMath.sin(x / 2);
        var s2 = CMath.sin(y / 2);
        var s3 = CMath.sin(z / 2);

        if (order === 'XYZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        }

        return this;
      };
      /**
       * @method clone
       * @return {Quaternion}
       */


      Quaternion.prototype.clone = function () {
        return new Quaternion(this.x, this.y, this.z, this.w);
      };
      /**
       * Performs a spherical linear interpolation between two quat
       *
       * @method slerp
       * @param {Quaternion} toQuat second operand
       * @param {Number} t interpolation amount between the self quaternion and toQuat
       * @param {Quaternion} [target] A quaternion to store the result in. If not provided, a new one will be created.
       * @returns {Quaternion} The "target" object
       */


      Quaternion.prototype.slerp = function (toQuat, t, target) {
        target = target || new Quaternion();
        var ax = this.x,
            ay = this.y,
            az = this.z,
            aw = this.w,
            bx = toQuat.x,
            by = toQuat.y,
            bz = toQuat.z,
            bw = toQuat.w;
        var omega, cosom, sinom, scale0, scale1; // calc cosine

        cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

        if (cosom < 0.0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        } // calculate coefficients


        if (1.0 - cosom > 0.000001) {
          // standard case (slerp)
          omega = Math.acos(cosom);
          sinom = CMath.sin(omega);
          scale0 = CMath.sin((1.0 - t) * omega) / sinom;
          scale1 = CMath.sin(t * omega) / sinom;
        } else {
          // "from" and "to" quaternions are very close
          //  ... so we can do a linear interpolation
          scale0 = 1.0 - t;
          scale1 = t;
        } // calculate final values


        target.x = scale0 * ax + scale1 * bx;
        target.y = scale0 * ay + scale1 * by;
        target.z = scale0 * az + scale1 * bz;
        target.w = scale0 * aw + scale1 * bw;
        return target;
      };
      /**
       * Rotate an absolute orientation quaternion given an angular velocity and a time step.
       * @param  {Vec3} angularVelocity
       * @param  {number} dt
       * @param  {Vec3} angularFactor
       * @param  {Quaternion} target
       * @return {Quaternion} The "target" object
       */


      Quaternion.prototype.integrate = function (angularVelocity, dt, angularFactor, target) {
        target = target || new Quaternion();
        var ax = angularVelocity.x * angularFactor.x,
            ay = angularVelocity.y * angularFactor.y,
            az = angularVelocity.z * angularFactor.z,
            bx = this.x,
            by = this.y,
            bz = this.z,
            bw = this.w;
        var half_dt = dt * 0.5;
        target.x += half_dt * (ax * bw + ay * bz - az * by);
        target.y += half_dt * (ay * bw + az * bx - ax * bz);
        target.z += half_dt * (az * bw + ax * by - ay * bx);
        target.w += half_dt * (-ax * bx - ay * by - az * bz);
        return target;
      };
    }, {
      "./CMath": 27,
      "./Vec3": 32
    }],
    31: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('./Vec3');

      var Quaternion = _dereq_('./Quaternion');

      module.exports = Transform;
      /**
       * @class Transform
       * @constructor
       */

      function Transform(options) {
        options = options || {};
        /**
         * @property {Vec3} position
         */

        this.position = new Vec3();

        if (options.position) {
          this.position.copy(options.position);
        }
        /**
         * @property {Quaternion} quaternion
         */


        this.quaternion = new Quaternion();

        if (options.quaternion) {
          this.quaternion.copy(options.quaternion);
        }
      }

      var tmpQuat = new Quaternion();
      /**
       * @static
       * @method pointToLocaFrame
       * @param {Vec3} position
       * @param {Quaternion} quaternion
       * @param {Vec3} worldPoint
       * @param {Vec3} result
       */

      Transform.pointToLocalFrame = function (position, quaternion, worldPoint, result) {
        var result = result || new Vec3();
        worldPoint.vsub(position, result);
        quaternion.conjugate(tmpQuat);
        tmpQuat.vmult(result, result);
        return result;
      };
      /**
       * Get a global point in local transform coordinates.
       * @method pointToLocal
       * @param  {Vec3} point
       * @param  {Vec3} result
       * @return {Vec3} The "result" vector object
       */


      Transform.prototype.pointToLocal = function (worldPoint, result) {
        return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
      };
      /**
       * @static
       * @method pointToWorldFrame
       * @param {Vec3} position
       * @param {Vec3} quaternion
       * @param {Vec3} localPoint
       * @param {Vec3} result
       */


      Transform.pointToWorldFrame = function (position, quaternion, localPoint, result) {
        var result = result || new Vec3();
        quaternion.vmult(localPoint, result);
        result.vadd(position, result);
        return result;
      };
      /**
       * Get a local point in global transform coordinates.
       * @method pointToWorld
       * @param  {Vec3} point
       * @param  {Vec3} result
       * @return {Vec3} The "result" vector object
       */


      Transform.prototype.pointToWorld = function (localPoint, result) {
        return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
      };

      Transform.prototype.vectorToWorldFrame = function (localVector, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localVector, result);
        return result;
      };

      Transform.vectorToWorldFrame = function (quaternion, localVector, result) {
        quaternion.vmult(localVector, result);
        return result;
      };

      Transform.vectorToLocalFrame = function (position, quaternion, worldVector, result) {
        var result = result || new Vec3();
        quaternion.w *= -1;
        quaternion.vmult(worldVector, result);
        quaternion.w *= -1;
        return result;
      };
    }, {
      "./Quaternion": 30,
      "./Vec3": 32
    }],
    32: [function (_dereq_, module, exports) {
      module.exports = Vec3;

      var Mat3 = _dereq_('./Mat3');
      /**
       * 3-dimensional vector
       * @class Vec3
       * @constructor
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @author schteppe
       * @example
       *     var v = new Vec3(1, 2, 3);
       *     console.log('x=' + v.x); // x=1
       */


      function Vec3(x, y, z) {
        /**
         * @property x
         * @type {Number}
         */
        this.x = x || 0.0;
        /**
         * @property y
         * @type {Number}
         */

        this.y = y || 0.0;
        /**
         * @property z
         * @type {Number}
         */

        this.z = z || 0.0;
      }
      /**
       * @static
       * @property {Vec3} ZERO
       */


      Vec3.ZERO = new Vec3(0, 0, 0);
      /**
       * @static
       * @property {Vec3} UNIT_X
       */

      Vec3.UNIT_X = new Vec3(1, 0, 0);
      /**
       * @static
       * @property {Vec3} UNIT_Y
       */

      Vec3.UNIT_Y = new Vec3(0, 1, 0);
      /**
       * @static
       * @property {Vec3} UNIT_Z
       */

      Vec3.UNIT_Z = new Vec3(0, 0, 1);
      /**
       * Vector cross product
       * @method cross
       * @param {Vec3} v
       * @param {Vec3} target Optional. Target to save in.
       * @return {Vec3}
       */

      Vec3.prototype.cross = function (v, target) {
        var vx = v.x,
            vy = v.y,
            vz = v.z,
            x = this.x,
            y = this.y,
            z = this.z;
        target = target || new Vec3();
        target.x = y * vz - z * vy;
        target.y = z * vx - x * vz;
        target.z = x * vy - y * vx;
        return target;
      };
      /**
       * Set the vectors' 3 elements
       * @method set
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @return Vec3
       */


      Vec3.prototype.set = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };
      /**
       * Set all components of the vector to zero.
       * @method setZero
       */


      Vec3.prototype.setZero = function () {
        this.x = this.y = this.z = 0;
      };
      /**
       * Vector addition
       * @method vadd
       * @param {Vec3} v
       * @param {Vec3} target Optional.
       * @return {Vec3}
       */


      Vec3.prototype.vadd = function (v, target) {
        if (target) {
          target.x = v.x + this.x;
          target.y = v.y + this.y;
          target.z = v.z + this.z;
        } else {
          return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
        }
      };
      /**
       * Vector subtraction
       * @method vsub
       * @param {Vec3} v
       * @param {Vec3} target Optional. Target to save in.
       * @return {Vec3}
       */


      Vec3.prototype.vsub = function (v, target) {
        if (target) {
          target.x = this.x - v.x;
          target.y = this.y - v.y;
          target.z = this.z - v.z;
        } else {
          return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
        }
      };
      /**
       * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
       * @method crossmat
       * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
       * @return {Mat3}
       */


      Vec3.prototype.crossmat = function () {
        return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
      };
      /**
       * Normalize the vector. Note that this changes the values in the vector.
       * @method normalize
       * @return {Number} Returns the norm of the vector
       */


      Vec3.prototype.normalize = function () {
        var x = this.x,
            y = this.y,
            z = this.z;
        var n = Math.sqrt(x * x + y * y + z * z);

        if (n > 0.0) {
          var invN = 1 / n;
          this.x *= invN;
          this.y *= invN;
          this.z *= invN;
        } else {
          // Make something up
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }

        return n;
      };
      /**
       * Get the version of this vector that is of length 1.
       * @method unit
       * @param {Vec3} target Optional target to save in
       * @return {Vec3} Returns the unit vector
       */


      Vec3.prototype.unit = function (target) {
        target = target || new Vec3();
        var x = this.x,
            y = this.y,
            z = this.z;
        var ninv = Math.sqrt(x * x + y * y + z * z);

        if (ninv > 0.0) {
          ninv = 1.0 / ninv;
          target.x = x * ninv;
          target.y = y * ninv;
          target.z = z * ninv;
        } else {
          target.x = 1;
          target.y = 0;
          target.z = 0;
        }

        return target;
      };
      /**
       * Get the length of the vector
       * @method norm
       * @return {Number}
       * @deprecated Use .length() instead
       */


      Vec3.prototype.norm = function () {
        var x = this.x,
            y = this.y,
            z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      };
      /**
       * Get the length of the vector
       * @method length
       * @return {Number}
       */


      Vec3.prototype.length = Vec3.prototype.norm;
      /**
       * Get the squared length of the vector
       * @method norm2
       * @return {Number}
       * @deprecated Use .lengthSquared() instead.
       */

      Vec3.prototype.norm2 = function () {
        return this.dot(this);
      };
      /**
       * Get the squared length of the vector.
       * @method lengthSquared
       * @return {Number}
       */


      Vec3.prototype.lengthSquared = Vec3.prototype.norm2;
      /**
       * Get distance from this point to another point
       * @method distanceTo
       * @param  {Vec3} p
       * @return {Number}
       */

      Vec3.prototype.distanceTo = function (p) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var px = p.x,
            py = p.y,
            pz = p.z;
        return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
      };
      /**
       * Get squared distance from this point to another point
       * @method distanceSquared
       * @param  {Vec3} p
       * @return {Number}
       */


      Vec3.prototype.distanceSquared = function (p) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var px = p.x,
            py = p.y,
            pz = p.z;
        return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
      };
      /**
       * Multiply all the components of the vector with a scalar.
       * @deprecated Use .scale instead
       * @method mult
       * @param {Number} scalar
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       * @deprecated Use .scale() instead
       */


      Vec3.prototype.mult = function (scalar, target) {
        target = target || new Vec3();
        var x = this.x,
            y = this.y,
            z = this.z;
        target.x = scalar * x;
        target.y = scalar * y;
        target.z = scalar * z;
        return target;
      };
      /**
       * Multiply the vector with an other vector, component-wise.
       * @method mult
       * @param {Number} vector
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       */


      Vec3.prototype.vmul = function (vector, target) {
        target = target || new Vec3();
        target.x = vector.x * this.x;
        target.y = vector.y * this.y;
        target.z = vector.z * this.z;
        return target;
      };
      /**
       * Multiply the vector with a scalar.
       * @method scale
       * @param {Number} scalar
       * @param {Vec3} target
       * @return {Vec3}
       */


      Vec3.prototype.scale = Vec3.prototype.mult;
      /**
       * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
       * @method addScaledVector
       * @param {Number} scalar
       * @param {Vec3} vector
       * @param {Vec3} target The vector to save the result in.
       * @return {Vec3}
       */

      Vec3.prototype.addScaledVector = function (scalar, vector, target) {
        target = target || new Vec3();
        target.x = this.x + scalar * vector.x;
        target.y = this.y + scalar * vector.y;
        target.z = this.z + scalar * vector.z;
        return target;
      };
      /**
       * Calculate dot product
       * @method dot
       * @param {Vec3} v
       * @return {Number}
       */


      Vec3.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };
      /**
       * @method isZero
       * @return bool
       */


      Vec3.prototype.isZero = function () {
        return this.x === 0 && this.y === 0 && this.z === 0;
      };
      /**
       * Make the vector point in the opposite direction.
       * @method negate
       * @param {Vec3} target Optional target to save in
       * @return {Vec3}
       */


      Vec3.prototype.negate = function (target) {
        target = target || new Vec3();
        target.x = -this.x;
        target.y = -this.y;
        target.z = -this.z;
        return target;
      };
      /**
       * Compute two artificial tangents to the vector
       * @method tangents
       * @param {Vec3} t1 Vector object to save the first tangent in
       * @param {Vec3} t2 Vector object to save the second tangent in
       */


      var Vec3_tangents_n = new Vec3();
      var Vec3_tangents_randVec = new Vec3();

      Vec3.prototype.tangents = function (t1, t2) {
        var norm = this.norm();

        if (norm > 0.0) {
          var n = Vec3_tangents_n;
          var inorm = 1 / norm;
          n.set(this.x * inorm, this.y * inorm, this.z * inorm);
          var randVec = Vec3_tangents_randVec;

          if (Math.abs(n.x) < 0.9) {
            randVec.set(1, 0, 0);
            n.cross(randVec, t1);
          } else {
            randVec.set(0, 1, 0);
            n.cross(randVec, t1);
          }

          n.cross(t1, t2);
        } else {
          // The normal length is zero, make something up
          t1.set(1, 0, 0);
          t2.set(0, 1, 0);
        }
      };
      /**
       * Converts to a more readable format
       * @method toString
       * @return string
       */


      Vec3.prototype.toString = function () {
        return this.x + "," + this.y + "," + this.z;
      };
      /**
       * Converts to an array
       * @method toArray
       * @return Array
       */


      Vec3.prototype.toArray = function () {
        return [this.x, this.y, this.z];
      };
      /**
       * Copies value of source to this vector.
       * @method copy
       * @param {Vec3} source
       * @return {Vec3} this
       */


      Vec3.prototype.copy = function (source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        return this;
      };
      /**
       * Do a linear interpolation between two vectors
       * @method lerp
       * @param {Vec3} v
       * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
       * @param {Vec3} target
       */


      Vec3.prototype.lerp = function (v, t, target) {
        var x = this.x,
            y = this.y,
            z = this.z;
        target.x = x + (v.x - x) * t;
        target.y = y + (v.y - y) * t;
        target.z = z + (v.z - z) * t;
      };
      /**
       * Check if a vector equals is almost equal to another one.
       * @method almostEquals
       * @param {Vec3} v
       * @param {Number} precision
       * @return bool
       */


      Vec3.prototype.almostEquals = function (v, precision) {
        if (precision === undefined) {
          precision = 1e-6;
        }

        if (Math.abs(this.x - v.x) > precision || Math.abs(this.y - v.y) > precision || Math.abs(this.z - v.z) > precision) {
          return false;
        }

        return true;
      };
      /**
       * Check if a vector is almost zero
       * @method almostZero
       * @param {Number} precision
       */


      Vec3.prototype.almostZero = function (precision) {
        if (precision === undefined) {
          precision = 1e-6;
        }

        if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
          return false;
        }

        return true;
      };

      var antip_neg = new Vec3();
      /**
       * Check if the vector is anti-parallel to another vector.
       * @method isAntiparallelTo
       * @param  {Vec3}  v
       * @param  {Number}  precision Set to zero for exact comparisons
       * @return {Boolean}
       */

      Vec3.prototype.isAntiparallelTo = function (v, precision) {
        this.negate(antip_neg);
        return antip_neg.almostEquals(v, precision);
      };
      /**
       * Clone the vector
       * @method clone
       * @return {Vec3}
       */


      Vec3.prototype.clone = function () {
        return new Vec3(this.x, this.y, this.z);
      };
    }, {
      "./Mat3": 29
    }],
    33: [function (_dereq_, module, exports) {
      module.exports = Body;

      var EventTarget = _dereq_('../utils/EventTarget');

      var Shape = _dereq_('../shapes/Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Mat3 = _dereq_('../math/Mat3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Material = _dereq_('../material/Material');

      var AABB = _dereq_('../collision/AABB');

      var Box = _dereq_('../shapes/Box');

      var World = _dereq_('../world/World');
      /**
       * Base class for all body types.
       * @class Body
       * @constructor
       * @extends EventTarget
       * @param {object} [options]
       * @param {Vec3} [options.position]
       * @param {Vec3} [options.velocity]
       * @param {Vec3} [options.angularVelocity]
       * @param {Quaternion} [options.quaternion]
       * @param {number} [options.mass]
       * @param {Material} [options.material]
       * @param {number} [options.type]
       * @param {number} [options.linearDamping=0.01]
       * @param {number} [options.angularDamping=0.01]
       * @param {boolean} [options.allowSleep=true]
       * @param {number} [options.sleepSpeedLimit=0.1]
       * @param {number} [options.sleepTimeLimit=1]
       * @param {number} [options.collisionFilterGroup=1]
       * @param {number} [options.collisionFilterMask=-1]
       * @param {boolean} [options.fixedRotation=false]
       * @param {Vec3} [options.linearFactor]
       * @param {Vec3} [options.angularFactor]
       * @param {Shape} [options.shape]
       * @example
       *     var body = new Body({
       *         mass: 1
       *     });
       *     var shape = new Sphere(1);
       *     body.addShape(shape);
       *     world.addBody(body);
       */


      function Body(options) {
        options = options || {};
        EventTarget.apply(this);
        this.id = Body.idCounter++;
        /**
         * Reference to the world the body is living in
         * @property world
         * @type {World}
         */

        this.world = null;
        /**
         * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
         * @property preStep
         * @type {Function}
         * @deprecated Use World events instead
         */

        this.preStep = null;
        /**
         * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
         * @property postStep
         * @type {Function}
         * @deprecated Use World events instead
         */

        this.postStep = null;
        this.vlambda = new Vec3();
        /**
         * @property {Number} collisionFilterGroup
         */

        this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
        /**
         * @property {Number} collisionFilterMask
         */

        this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
         * @property {Number} collisionResponse
         */

        this.collisionResponse = true;
        /**
         * World space position of the body.
         * @property position
         * @type {Vec3}
         */

        this.position = new Vec3();
        /**
         * @property {Vec3} previousPosition
         */

        this.previousPosition = new Vec3();
        /**
         * Interpolated position of the body.
         * @property {Vec3} interpolatedPosition
         */

        this.interpolatedPosition = new Vec3();
        /**
         * Initial position of the body
         * @property initPosition
         * @type {Vec3}
         */

        this.initPosition = new Vec3();

        if (options.position) {
          this.position.copy(options.position);
          this.previousPosition.copy(options.position);
          this.interpolatedPosition.copy(options.position);
          this.initPosition.copy(options.position);
        }
        /**
         * World space velocity of the body.
         * @property velocity
         * @type {Vec3}
         */


        this.velocity = new Vec3();

        if (options.velocity) {
          this.velocity.copy(options.velocity);
        }
        /**
         * @property initVelocity
         * @type {Vec3}
         */


        this.initVelocity = new Vec3();
        /**
         * Linear force on the body in world space.
         * @property force
         * @type {Vec3}
         */

        this.force = new Vec3();
        var mass = typeof options.mass === 'number' ? options.mass : 0;
        /**
         * @property mass
         * @type {Number}
         * @default 0
         */

        this.mass = mass;
        /**
         * @property invMass
         * @type {Number}
         */

        this.invMass = mass > 0 ? 1.0 / mass : 0;
        /**
         * @property material
         * @type {Material}
         */

        this.material = options.material || null;
        /**
         * @property linearDamping
         * @type {Number}
         */

        this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
        /**
         * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
         * @property type
         * @type {Number}
         */

        this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

        if (typeof options.type === typeof Body.STATIC) {
          this.type = options.type;
        }
        /**
         * If true, the body will automatically fall to sleep.
         * @property allowSleep
         * @type {Boolean}
         * @default true
         */


        this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
        /**
         * Current sleep state.
         * @property sleepState
         * @type {Number}
         */

        this.sleepState = 0;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @property sleepSpeedLimit
         * @type {Number}
         * @default 0.1
         */

        this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @property sleepTimeLimit
         * @type {Number}
         * @default 1
         */

        this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
        this.timeLastSleepy = 0;
        this._wakeUpAfterNarrowphase = false;
        /**
         * World space rotational force on the body, around center of mass.
         * @property {Vec3} torque
         */

        this.torque = new Vec3();
        /**
         * World space orientation of the body.
         * @property quaternion
         * @type {Quaternion}
         */

        this.quaternion = new Quaternion();
        /**
         * @property initQuaternion
         * @type {Quaternion}
         */

        this.initQuaternion = new Quaternion();
        /**
         * @property {Quaternion} previousQuaternion
         */

        this.previousQuaternion = new Quaternion();
        /**
         * Interpolated orientation of the body.
         * @property {Quaternion} interpolatedQuaternion
         */

        this.interpolatedQuaternion = new Quaternion();

        if (options.quaternion) {
          this.quaternion.copy(options.quaternion);
          this.initQuaternion.copy(options.quaternion);
          this.previousQuaternion.copy(options.quaternion);
          this.interpolatedQuaternion.copy(options.quaternion);
        }
        /**
         * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
         * @property angularVelocity
         * @type {Vec3}
         */


        this.angularVelocity = new Vec3();

        if (options.angularVelocity) {
          this.angularVelocity.copy(options.angularVelocity);
        }
        /**
         * @property initAngularVelocity
         * @type {Vec3}
         */


        this.initAngularVelocity = new Vec3();
        /**
         * @property shapes
         * @type {array}
         */

        this.shapes = [];
        /**
         * Position of each Shape in the body, given in local Body space.
         * @property shapeOffsets
         * @type {array}
         */

        this.shapeOffsets = [];
        /**
         * Orientation of each Shape, given in local Body space.
         * @property shapeOrientations
         * @type {array}
         */

        this.shapeOrientations = [];
        /**
         * @property inertia
         * @type {Vec3}
         */

        this.inertia = new Vec3();
        /**
         * @property {Vec3} invInertia
         */

        this.invInertia = new Vec3();
        /**
         * @property {Mat3} invInertiaWorld
         */

        this.invInertiaWorld = new Mat3();
        this.invMassSolve = 0;
        /**
         * @property {Vec3} invInertiaSolve
         */

        this.invInertiaSolve = new Vec3();
        /**
         * @property {Mat3} invInertiaWorldSolve
         */

        this.invInertiaWorldSolve = new Mat3();
        /**
         * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
         * @property {Boolean} fixedRotation
         * @default false
         */

        this.fixedRotation = typeof options.fixedRotation !== "undefined" ? options.fixedRotation : false;
        /**
         * use gravity ?
         * @property {Boolean} useGravity
         * @default true
         */

        this.useGravity = true;
        /**
         * @property {Number} angularDamping
         */

        this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
        /**
         * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
         * @property {Vec3} linearFactor
         */

        this.linearFactor = new Vec3(1, 1, 1);

        if (options.linearFactor) {
          this.linearFactor.copy(options.linearFactor);
        }
        /**
         * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
         * @property {Vec3} angularFactor
         */


        this.angularFactor = new Vec3(1, 1, 1);

        if (options.angularFactor) {
          this.angularFactor.copy(options.angularFactor);
        }
        /**
         * World space bounding box of the body and its shapes.
         * @property aabb
         * @type {AABB}
         */


        this.aabb = new AABB();
        /**
         * Indicates if the AABB needs to be updated before use.
         * @property aabbNeedsUpdate
         * @type {Boolean}
         */

        this.aabbNeedsUpdate = true;
        /**
         * Total bounding radius of the Body including its shapes, relative to body.position.
         * @property boundingRadius
         * @type {Number}
         */

        this.boundingRadius = 0;
        this.wlambda = new Vec3();

        if (options.shape) {
          this.addShape(options.shape);
        }
        /**
         * has trigger?
         */


        this.hasTrigger = true;
        this.updateMassProperties();
      }

      Body.prototype = new EventTarget();
      Body.prototype.constructor = Body;
      /**
       * Dispatched after two bodies collide. This event is dispatched on each
       * of the two bodies involved in the collision.
       * @event collide
       * @param {Body} body The body that was involved in the collision.
       * @param {ContactEquation} contact The details of the collision.
       */

      Body.COLLIDE_EVENT_NAME = "collide";
      /**
       * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
       * @static
       * @property DYNAMIC
       * @type {Number}
       */

      Body.DYNAMIC = 1;
      /**
       * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
       * @static
       * @property STATIC
       * @type {Number}
       */

      Body.STATIC = 2;
      /**
       * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
       * @static
       * @property KINEMATIC
       * @type {Number}
       */

      Body.KINEMATIC = 4;
      /**
       * @static
       * @property AWAKE
       * @type {number}
       */

      Body.AWAKE = 0;
      /**
       * @static
       * @property SLEEPY
       * @type {number}
       */

      Body.SLEEPY = 1;
      /**
       * @static
       * @property SLEEPING
       * @type {number}
       */

      Body.SLEEPING = 2;
      Body.idCounter = 0;
      /**
       * Dispatched after a sleeping body has woken up.
       * @event wakeup
       */

      Body.wakeupEvent = {
        type: "wakeup"
      };
      /**
       * Wake the body up.
       * @method wakeUp
       */

      Body.prototype.wakeUp = function () {
        World.SLEEPING = false;
        var s = this.sleepState;
        this.sleepState = 0;
        this._wakeUpAfterNarrowphase = false;

        if (s === Body.SLEEPING) {
          this.dispatchEvent(Body.wakeupEvent);
        }
      };
      /**
       * Force body sleep
       * @method sleep
       */


      Body.prototype.sleep = function () {
        this.sleepState = Body.SLEEPING;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
        this._wakeUpAfterNarrowphase = false;
      };
      /**
       * Dispatched after a body has gone in to the sleepy state.
       * @event sleepy
       */


      Body.sleepyEvent = {
        type: "sleepy"
      };
      /**
       * Dispatched after a body has fallen asleep.
       * @event sleep
       */

      Body.sleepEvent = {
        type: "sleep"
      };
      /**
       * Called every timestep to update internal sleep timer and change sleep state if needed.
       * @method sleepTick
       * @param {Number} time The world time in seconds
       */

      Body.prototype.sleepTick = function (time) {
        if (this.allowSleep) {
          var sleepState = this.sleepState;
          var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
          var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);

          if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
            this.sleepState = Body.SLEEPY; // Sleepy

            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
          } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
            this.wakeUp(); // Wake up
          } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
            this.sleep(); // Sleeping

            this.dispatchEvent(Body.sleepEvent);
          }
        }
      };
      /**
       * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
       * @method updateSolveMassProperties
       */


      Body.prototype.updateSolveMassProperties = function () {
        if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
          this.invMassSolve = 0;
          this.invInertiaSolve.setZero();
          this.invInertiaWorldSolve.setZero();
        } else {
          this.invMassSolve = this.invMass;
          this.invInertiaSolve.copy(this.invInertia);
          this.invInertiaWorldSolve.copy(this.invInertiaWorld);
        }
      };
      /**
       * Convert a world point to local body frame.
       * @method pointToLocalFrame
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.pointToLocalFrame = function (worldPoint, result) {
        var result = result || new Vec3();
        worldPoint.vsub(this.position, result);
        this.quaternion.conjugate().vmult(result, result);
        return result;
      };
      /**
       * Convert a world vector to local body frame.
       * @method vectorToLocalFrame
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.vectorToLocalFrame = function (worldVector, result) {
        var result = result || new Vec3();
        this.quaternion.conjugate().vmult(worldVector, result);
        return result;
      };
      /**
       * Convert a local body point to world frame.
       * @method pointToWorldFrame
       * @param  {Vec3} localPoint
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.pointToWorldFrame = function (localPoint, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localPoint, result);
        result.vadd(this.position, result);
        return result;
      };
      /**
       * Convert a local body point to world frame.
       * @method vectorToWorldFrame
       * @param  {Vec3} localVector
       * @param  {Vec3} result
       * @return {Vec3}
       */


      Body.prototype.vectorToWorldFrame = function (localVector, result) {
        var result = result || new Vec3();
        this.quaternion.vmult(localVector, result);
        return result;
      };

      var tmpVec = new Vec3();
      var tmpQuat = new Quaternion();
      /**
       * Add a shape to the body with a local offset and orientation.
       * @method addShape
       * @param {Shape} shape
       * @param {Vec3} [_offset]
       * @param {Quaternion} [_orientation]
       * @return {Body} The body object, for chainability.
       */

      Body.prototype.addShape = function (shape, _offset, _orientation) {
        var offset = new Vec3();
        var orientation = new Quaternion();

        if (_offset) {
          offset.copy(_offset);
        }

        if (_orientation) {
          orientation.copy(_orientation);
        }

        this.shapes.push(shape);
        this.shapeOffsets.push(offset);
        this.shapeOrientations.push(orientation);
        this.aabbNeedsUpdate = true;
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.updateHasTrigger();
        World.idToShapeMap[shape.id] = shape;
        shape.body = this;
        return this;
      };
      /**
       * Remove a shape from the body
       */


      Body.prototype.removeShape = function (shape) {
        var idx = this.shapes.indexOf(shape);

        if (idx === -1) {
          return;
        } // shape.body = null;  needed ?
        // delete World.idToShapeMap[shape.id];  needed ?


        this.shapes.splice(idx, 1);
        this.shapeOffsets.splice(idx, 1);
        this.shapeOrientations.splice(idx, 1);
        this.aabbNeedsUpdate = true;
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.updateHasTrigger();
      };
      /**
       * Update the bounding radius of the body. Should be done if any of the shapes are changed.
       * @method updateBoundingRadius
       */


      Body.prototype.updateBoundingRadius = function () {
        var shapes = this.shapes,
            shapeOffsets = this.shapeOffsets,
            N = shapes.length,
            radius = 0;

        for (var i = 0; i !== N; i++) {
          var shape = shapes[i];
          shape.updateBoundingSphereRadius();
          var offset = shapeOffsets[i].norm(),
              r = shape.boundingSphereRadius;

          if (offset + r > radius) {
            radius = offset + r;
          }
        }

        this.boundingRadius = radius;
      };

      var computeAABB_shapeAABB = new AABB();
      /**
       * Updates the .aabb
       * @method computeAABB
       * @todo rename to updateAABB()
       */

      Body.prototype.computeAABB = function () {
        var shapes = this.shapes,
            shapeOffsets = this.shapeOffsets,
            shapeOrientations = this.shapeOrientations,
            N = shapes.length,
            offset = tmpVec,
            orientation = tmpQuat,
            bodyQuat = this.quaternion,
            aabb = this.aabb,
            shapeAABB = computeAABB_shapeAABB;

        for (var i = 0; i !== N; i++) {
          var shape = shapes[i]; // Get shape world position

          bodyQuat.vmult(shapeOffsets[i], offset);
          offset.vadd(this.position, offset); // Get shape world quaternion

          shapeOrientations[i].mult(bodyQuat, orientation); // Get shape AABB

          shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

          if (i === 0) {
            aabb.copy(shapeAABB);
          } else {
            aabb.extend(shapeAABB);
          }
        }

        this.aabbNeedsUpdate = false;
      };

      var uiw_m1 = new Mat3(),
          uiw_m2 = new Mat3(),
          uiw_m3 = new Mat3();
      /**
       * Update .inertiaWorld and .invInertiaWorld
       * @method updateInertiaWorld
       */

      Body.prototype.updateInertiaWorld = function (force) {
        var I = this.invInertia;

        if (I.x === I.y && I.y === I.z && !force) {// If inertia M = s*I, where I is identity and s a scalar, then
          //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
          // where R is the rotation matrix.
          // In other words, we don't have to transform the inertia if all
          // inertia diagonal entries are equal.
        } else {
          var m1 = uiw_m1,
              m2 = uiw_m2,
              m3 = uiw_m3;
          m1.setRotationFromQuaternion(this.quaternion);
          m1.transpose(m2);
          m1.scale(I, m1);
          m1.mmult(m2, this.invInertiaWorld);
        }
      };
      /**
       * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
       * @method applyForce
       * @param  {Vec3} force The amount of force to add.
       * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
       */


      var Body_applyForce_r = new Vec3();
      var Body_applyForce_rotForce = new Vec3();

      Body.prototype.applyForce = function (force, relativePoint) {
        if (this.type !== Body.DYNAMIC) {
          // Needed?
          return;
        } // Compute produced rotational force


        var rotForce = Body_applyForce_rotForce;
        relativePoint.cross(force, rotForce); // Add linear force

        this.force.vadd(force, this.force); // Add rotational force

        this.torque.vadd(rotForce, this.torque);
      };
      /**
       * Apply force to a local point in the body.
       * @method applyLocalForce
       * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
       * @param  {Vec3} localPoint A local point in the body to apply the force on.
       */


      var Body_applyLocalForce_worldForce = new Vec3();
      var Body_applyLocalForce_relativePointWorld = new Vec3();

      Body.prototype.applyLocalForce = function (localForce, localPoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        }

        var worldForce = Body_applyLocalForce_worldForce;
        var relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

        this.vectorToWorldFrame(localForce, worldForce);
        this.vectorToWorldFrame(localPoint, relativePointWorld);
        this.applyForce(worldForce, relativePointWorld);
      };
      /**
       * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
       * @method applyImpulse
       * @param  {Vec3} impulse The amount of impulse to add.
       * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
       */


      var Body_applyImpulse_r = new Vec3();
      var Body_applyImpulse_velo = new Vec3();
      var Body_applyImpulse_rotVelo = new Vec3();

      Body.prototype.applyImpulse = function (impulse, relativePoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        } // Compute point position relative to the body center


        var r = relativePoint; // Compute produced central impulse velocity

        var velo = Body_applyImpulse_velo;
        velo.copy(impulse);
        velo.mult(this.invMass, velo); // Add linear impulse

        this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

        var rotVelo = Body_applyImpulse_rotVelo;
        r.cross(impulse, rotVelo);
        /*
        rotVelo.x *= this.invInertia.x;
        rotVelo.y *= this.invInertia.y;
        rotVelo.z *= this.invInertia.z;
        */

        this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

        this.angularVelocity.vadd(rotVelo, this.angularVelocity);
      };
      /**
       * Apply locally-defined impulse to a local point in the body.
       * @method applyLocalImpulse
       * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
       * @param  {Vec3} localPoint A local point in the body to apply the force on.
       */


      var Body_applyLocalImpulse_worldImpulse = new Vec3();
      var Body_applyLocalImpulse_relativePoint = new Vec3();

      Body.prototype.applyLocalImpulse = function (localImpulse, localPoint) {
        if (this.type !== Body.DYNAMIC) {
          return;
        }

        var worldImpulse = Body_applyLocalImpulse_worldImpulse;
        var relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

        this.vectorToWorldFrame(localImpulse, worldImpulse);
        this.vectorToWorldFrame(localPoint, relativePointWorld);
        this.applyImpulse(worldImpulse, relativePointWorld);
      };

      var Body_updateMassProperties_halfExtents = new Vec3();
      /**
       * Should be called whenever you change the body shape or mass.
       * @method updateMassProperties
       */

      Body.prototype.updateMassProperties = function () {
        var halfExtents = Body_updateMassProperties_halfExtents;
        this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
        var I = this.inertia;
        var fixed = this.fixedRotation; // Approximate with AABB box

        this.computeAABB();
        halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
        Box.calculateInertia(halfExtents, this.mass, I);
        this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
        this.updateInertiaWorld(true);
      };
      /**
       * Get world velocity of a point in the body.
       * @method getVelocityAtWorldPoint
       * @param  {Vec3} worldPoint
       * @param  {Vec3} result
       * @return {Vec3} The result vector.
       */


      Body.prototype.getVelocityAtWorldPoint = function (worldPoint, result) {
        var r = new Vec3();
        worldPoint.vsub(this.position, r);
        this.angularVelocity.cross(r, result);
        this.velocity.vadd(result, result);
        return result;
      };

      var torque = new Vec3();
      var invI_tau_dt = new Vec3();
      var w = new Quaternion();
      var wq = new Quaternion();
      /**
       * Move the body forward in time.
       * @param {number} dt Time step
       * @param {boolean} quatNormalize Set to true to normalize the body quaternion
       * @param {boolean} quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
       */

      Body.prototype.integrate = function (dt, quatNormalize, quatNormalizeFast) {
        // Save previous position
        this.previousPosition.copy(this.position);
        this.previousQuaternion.copy(this.quaternion);

        if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
          // Only for dynamic
          return;
        }

        var velo = this.velocity,
            angularVelo = this.angularVelocity,
            pos = this.position,
            force = this.force,
            torque = this.torque,
            quat = this.quaternion,
            invMass = this.invMass,
            invInertia = this.invInertiaWorld,
            linearFactor = this.linearFactor;
        var iMdt = invMass * dt;
        velo.x += force.x * iMdt * linearFactor.x;
        velo.y += force.y * iMdt * linearFactor.y;
        velo.z += force.z * iMdt * linearFactor.z;
        var e = invInertia.elements;
        var angularFactor = this.angularFactor;
        var tx = torque.x * angularFactor.x;
        var ty = torque.y * angularFactor.y;
        var tz = torque.z * angularFactor.z;
        angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
        angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
        angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

        pos.x += velo.x * dt;
        pos.y += velo.y * dt;
        pos.z += velo.z * dt;
        quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

        if (quatNormalize) {
          if (quatNormalizeFast) {
            quat.normalizeFast();
          } else {
            quat.normalize();
          }
        }

        this.aabbNeedsUpdate = true; // Update world inertia

        this.updateInertiaWorld();
      };
      /**
       * Is Sleeping
       */


      Body.prototype.isSleeping = function () {
        return this.sleepState === Body.SLEEPING;
      };
      /**
       * Is Sleepy
       */


      Body.prototype.isSleepy = function () {
        return this.sleepState === Body.SLEEPY;
      };
      /**
       * Is Awake
       */


      Body.prototype.isAwake = function () {
        return this.sleepState === Body.AWAKE;
      };
      /**
       * Update hasTrigger
       */


      Body.prototype.updateHasTrigger = function () {
        for (var i = this.shapes.length; i--;) {
          this.hasTrigger = !this.shapes[i].collisionResponse;
          if (this.hasTrigger) break;
        }
      };
    }, {
      "../collision/AABB": 3,
      "../material/Material": 26,
      "../math/Mat3": 29,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../shapes/Box": 39,
      "../shapes/Shape": 45,
      "../utils/EventTarget": 51,
      "../world/World": 58
    }],
    34: [function (_dereq_, module, exports) {
      var Body = _dereq_('./Body');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Ray = _dereq_('../collision/Ray');

      var WheelInfo = _dereq_('../objects/WheelInfo');

      module.exports = RaycastVehicle;
      /**
       * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
       * @class RaycastVehicle
       * @constructor
       * @param {object} [options]
       * @param {Body} [options.chassisBody] The car chassis body.
       * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
       * @param {integer} [options.indexLeftAxis]
       * @param {integer} [options.indexUpAxis]
       */

      function RaycastVehicle(options) {
        /**
         * @property {Body} chassisBody
         */
        this.chassisBody = options.chassisBody;
        /**
         * An array of WheelInfo objects.
         * @property {array} wheelInfos
         */

        this.wheelInfos = [];
        /**
         * Will be set to true if the car is sliding.
         * @property {boolean} sliding
         */

        this.sliding = false;
        /**
         * @property {World} world
         */

        this.world = null;
        /**
         * Index of the right axis, 0=x, 1=y, 2=z
         * @property {integer} indexRightAxis
         * @default 1
         */

        this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 1;
        /**
         * Index of the forward axis, 0=x, 1=y, 2=z
         * @property {integer} indexForwardAxis
         * @default 0
         */

        this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;
        /**
         * Index of the up axis, 0=x, 1=y, 2=z
         * @property {integer} indexUpAxis
         * @default 2
         */

        this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 2;
      }

      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();
      var tmpVec3 = new Vec3();
      var tmpVec4 = new Vec3();
      var tmpVec5 = new Vec3();
      var tmpVec6 = new Vec3();
      var tmpRay = new Ray();
      /**
       * Add a wheel. For information about the options, see WheelInfo.
       * @method addWheel
       * @param {object} [options]
       */

      RaycastVehicle.prototype.addWheel = function (options) {
        options = options || {};
        var info = new WheelInfo(options);
        var index = this.wheelInfos.length;
        this.wheelInfos.push(info);
        return index;
      };
      /**
       * Set the steering value of a wheel.
       * @method setSteeringValue
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RaycastVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
        var wheel = this.wheelInfos[wheelIndex];
        wheel.steering = value;
      };

      var torque = new Vec3();
      /**
       * Set the wheel force to apply on one of the wheels each time step
       * @method applyEngineForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */

      RaycastVehicle.prototype.applyEngineForce = function (value, wheelIndex) {
        this.wheelInfos[wheelIndex].engineForce = value;
      };
      /**
       * Set the braking force of a wheel
       * @method setBrake
       * @param {number} brake
       * @param {integer} wheelIndex
       */


      RaycastVehicle.prototype.setBrake = function (brake, wheelIndex) {
        this.wheelInfos[wheelIndex].brake = brake;
      };
      /**
       * Add the vehicle including its constraints to the world.
       * @method addToWorld
       * @param {World} world
       */


      RaycastVehicle.prototype.addToWorld = function (world) {
        var constraints = this.constraints;
        world.addBody(this.chassisBody);
        var that = this;

        this.preStepCallback = function () {
          that.updateVehicle(world.dt);
        };

        world.addEventListener('preStep', this.preStepCallback);
        this.world = world;
      };
      /**
       * Get one of the wheel axles, world-oriented.
       * @private
       * @method getVehicleAxisWorld
       * @param  {integer} axisIndex
       * @param  {Vec3} result
       */


      RaycastVehicle.prototype.getVehicleAxisWorld = function (axisIndex, result) {
        result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
        this.chassisBody.vectorToWorldFrame(result, result);
      };

      RaycastVehicle.prototype.updateVehicle = function (timeStep) {
        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;
        var chassisBody = this.chassisBody;

        for (var i = 0; i < numWheels; i++) {
          this.updateWheelTransform(i);
        }

        this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
        var forwardWorld = new Vec3();
        this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

        if (forwardWorld.dot(chassisBody.velocity) < 0) {
          this.currentVehicleSpeedKmHour *= -1;
        } // simulate suspension


        for (var i = 0; i < numWheels; i++) {
          this.castRay(wheelInfos[i]);
        }

        this.updateSuspension(timeStep);
        var impulse = new Vec3();
        var relpos = new Vec3();

        for (var i = 0; i < numWheels; i++) {
          //apply suspension force
          var wheel = wheelInfos[i];
          var suspensionForce = wheel.suspensionForce;

          if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
          }

          wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
          wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
          chassisBody.applyImpulse(impulse, relpos);
        }

        this.updateFriction(timeStep);
        var hitNormalWorldScaledWithProj = new Vec3();
        var fwd = new Vec3();
        var vel = new Vec3();

        for (i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i]; //var relpos = new Vec3();
          //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

          chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction

          var m = 1;

          switch (this.indexUpAxis) {
            case 1:
              m = -1;
              break;
          }

          if (wheel.isInContact) {
            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
            fwd.vsub(hitNormalWorldScaledWithProj, fwd);
            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
          }

          if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
          } // Lock wheels


          if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
            wheel.deltaRotation = 0;
          }

          wheel.rotation += wheel.deltaRotation; // Use the old value

          wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
        }
      };

      RaycastVehicle.prototype.updateSuspension = function (deltaTime) {
        var chassisBody = this.chassisBody;
        var chassisMass = chassisBody.mass;
        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;

        for (var w_it = 0; w_it < numWheels; w_it++) {
          var wheel = wheelInfos[w_it];

          if (wheel.isInContact) {
            var force; // Spring

            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = susp_length - current_length;
            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper

            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;

            if (projected_rel_vel < 0) {
              susp_damping = wheel.dampingCompression;
            } else {
              susp_damping = wheel.dampingRelaxation;
            }

            force -= susp_damping * projected_rel_vel;
            wheel.suspensionForce = force * chassisMass;

            if (wheel.suspensionForce < 0) {
              wheel.suspensionForce = 0;
            }
          } else {
            wheel.suspensionForce = 0;
          }
        }
      };
      /**
       * Remove the vehicle including its constraints from the world.
       * @method removeFromWorld
       * @param {World} world
       */


      RaycastVehicle.prototype.removeFromWorld = function (world) {
        var constraints = this.constraints;
        world.remove(this.chassisBody);
        world.removeEventListener('preStep', this.preStepCallback);
        this.world = null;
      };

      var castRay_rayvector = new Vec3();
      var castRay_target = new Vec3();

      RaycastVehicle.prototype.castRay = function (wheel) {
        var rayvector = castRay_rayvector;
        var target = castRay_target;
        this.updateWheelTransformWorld(wheel);
        var chassisBody = this.chassisBody;
        var depth = -1;
        var raylen = wheel.suspensionRestLength + wheel.radius;
        wheel.directionWorld.scale(raylen, rayvector);
        var source = wheel.chassisConnectionPointWorld;
        source.vadd(rayvector, target);
        var raycastResult = wheel.raycastResult;
        var param = 0;
        raycastResult.reset(); // Turn off ray collision with the chassis temporarily

        var oldState = chassisBody.collisionResponse;
        chassisBody.collisionResponse = false; // Cast ray against world

        this.world.rayTest(source, target, raycastResult);
        chassisBody.collisionResponse = oldState;
        var object = raycastResult.body;
        wheel.raycastResult.groundObject = 0;

        if (object) {
          depth = raycastResult.distance;
          wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
          wheel.isInContact = true;
          var hitDistance = raycastResult.distance;
          wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

          var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
          var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;

          if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
          }

          if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
          }

          var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
          var chassis_velocity_at_contactPoint = new Vec3();
          chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
          var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

          if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
          } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
          }
        } else {
          //put wheel info as in rest position
          wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
          wheel.suspensionRelativeVelocity = 0.0;
          wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
          wheel.clippedInvContactDotSuspension = 1.0;
        }

        return depth;
      };

      RaycastVehicle.prototype.updateWheelTransformWorld = function (wheel) {
        wheel.isInContact = false;
        var chassisBody = this.chassisBody;
        chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
        chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
        chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
      };
      /**
       * Update one of the wheel transform.
       * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
       * @method updateWheelTransform
       * @param {integer} wheelIndex The wheel index to update.
       */


      RaycastVehicle.prototype.updateWheelTransform = function (wheelIndex) {
        var up = tmpVec4;
        var right = tmpVec5;
        var fwd = tmpVec6;
        var wheel = this.wheelInfos[wheelIndex];
        this.updateWheelTransformWorld(wheel);
        wheel.directionLocal.scale(-1, up);
        right.copy(wheel.axleLocal);
        up.cross(right, fwd);
        fwd.normalize();
        right.normalize(); // Rotate around steering over the wheelAxle

        var steering = wheel.steering;
        var steeringOrn = new Quaternion();
        steeringOrn.setFromAxisAngle(up, steering);
        var rotatingOrn = new Quaternion();
        rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

        var q = wheel.worldTransform.quaternion;
        this.chassisBody.quaternion.mult(steeringOrn, q);
        q.mult(rotatingOrn, q);
        q.normalize(); // world position of the wheel

        var p = wheel.worldTransform.position;
        p.copy(wheel.directionWorld);
        p.scale(wheel.suspensionLength, p);
        p.vadd(wheel.chassisConnectionPointWorld, p);
      };

      var directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
      /**
       * Get the world transform of one of the wheels
       * @method getWheelTransformWorld
       * @param  {integer} wheelIndex
       * @return {Transform}
       */

      RaycastVehicle.prototype.getWheelTransformWorld = function (wheelIndex) {
        return this.wheelInfos[wheelIndex].worldTransform;
      };

      var updateFriction_surfNormalWS_scaled_proj = new Vec3();
      var updateFriction_axle = [];
      var updateFriction_forwardWS = [];
      var sideFrictionStiffness2 = 1;

      RaycastVehicle.prototype.updateFriction = function (timeStep) {
        var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

        var wheelInfos = this.wheelInfos;
        var numWheels = wheelInfos.length;
        var chassisBody = this.chassisBody;
        var forwardWS = updateFriction_forwardWS;
        var axle = updateFriction_axle;
        var numWheelsOnGround = 0;

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;

          if (groundObject) {
            numWheelsOnGround++;
          }

          wheel.sideImpulse = 0;
          wheel.forwardImpulse = 0;

          if (!forwardWS[i]) {
            forwardWS[i] = new Vec3();
          }

          if (!axle[i]) {
            axle[i] = new Vec3();
          }
        }

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;

          if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this.getWheelTransformWorld(i); // Get world axle

            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();
            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();
            wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
            wheel.sideImpulse *= sideFrictionStiffness2;
          }
        }

        var sideFactor = 1;
        var fwdFactor = 0.5;
        this.sliding = false;

        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var groundObject = wheel.raycastResult.body;
          var rollingFriction = 0;
          wheel.slipInfo = 1;

          if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);

            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
            rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
          } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)


          wheel.forwardImpulse = 0;
          wheel.skidInfo = 1;

          if (groundObject) {
            wheel.skidInfo = 1;
            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;
            var maximpSquared = maximp * maximpSide;
            wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;
            var impulseSquared = x * x + y * y;
            wheel.sliding = false;

            if (impulseSquared > maximpSquared) {
              this.sliding = true;
              wheel.sliding = true;
              var factor = maximp / Math.sqrt(impulseSquared);
              wheel.skidInfo *= factor;
            }
          }
        }

        if (this.sliding) {
          for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];

            if (wheel.sideImpulse !== 0) {
              if (wheel.skidInfo < 1) {
                wheel.forwardImpulse *= wheel.skidInfo;
                wheel.sideImpulse *= wheel.skidInfo;
              }
            }
          }
        } // apply the impulses


        for (var i = 0; i < numWheels; i++) {
          var wheel = wheelInfos[i];
          var rel_pos = new Vec3();
          wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position
          //rel_pos.copy(wheel.raycastResult.hitPointWorld);

          if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
          }

          if (wheel.sideImpulse !== 0) {
            var groundObject = wheel.raycastResult.body;
            var rel_pos2 = new Vec3();
            wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

            chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
          }
        }
      };

      var calcRollingFriction_vel1 = new Vec3();
      var calcRollingFriction_vel2 = new Vec3();
      var calcRollingFriction_vel = new Vec3();

      function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
        var j1 = 0;
        var contactPosWorld = frictionPosWorld; // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();

        var vel1 = calcRollingFriction_vel1;
        var vel2 = calcRollingFriction_vel2;
        var vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
        // contactPosWorld.vsub(body1.position, rel_pos2);

        body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
        body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
        vel1.vsub(vel2, vel);
        var vrel = frictionDirectionWorld.dot(vel);
        var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
        var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
        var relaxation = 1;
        var jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

        j1 = -vrel * jacDiagABInv;

        if (maxImpulse < j1) {
          j1 = maxImpulse;
        }

        if (j1 < -maxImpulse) {
          j1 = -maxImpulse;
        }

        return j1;
      }

      var computeImpulseDenominator_r0 = new Vec3();
      var computeImpulseDenominator_c0 = new Vec3();
      var computeImpulseDenominator_vec = new Vec3();
      var computeImpulseDenominator_m = new Vec3();

      function computeImpulseDenominator(body, pos, normal) {
        var r0 = computeImpulseDenominator_r0;
        var c0 = computeImpulseDenominator_c0;
        var vec = computeImpulseDenominator_vec;
        var m = computeImpulseDenominator_m;
        pos.vsub(body.position, r0);
        r0.cross(normal, c0);
        body.invInertiaWorld.vmult(c0, m);
        m.cross(r0, vec);
        return body.invMass + normal.dot(vec);
      }

      var resolveSingleBilateral_vel1 = new Vec3();
      var resolveSingleBilateral_vel2 = new Vec3();
      var resolveSingleBilateral_vel = new Vec3(); //bilateral constraint between two dynamic objects

      function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {
        var normalLenSqr = normal.norm2();

        if (normalLenSqr > 1.1) {
          return 0; // no impulse
        } // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();
        // pos1.vsub(body1.position, rel_pos1);
        // pos2.vsub(body2.position, rel_pos2);


        var vel1 = resolveSingleBilateral_vel1;
        var vel2 = resolveSingleBilateral_vel2;
        var vel = resolveSingleBilateral_vel;
        body1.getVelocityAtWorldPoint(pos1, vel1);
        body2.getVelocityAtWorldPoint(pos2, vel2);
        vel1.vsub(vel2, vel);
        var rel_vel = normal.dot(vel);
        var contactDamping = 0.2;
        var massTerm = 1 / (body1.invMass + body2.invMass);
        var impulse = -contactDamping * rel_vel * massTerm;
        return impulse;
      }
    }, {
      "../collision/Ray": 10,
      "../collision/RaycastResult": 11,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../objects/WheelInfo": 38,
      "./Body": 33
    }],
    35: [function (_dereq_, module, exports) {
      var Body = _dereq_('./Body');

      var Sphere = _dereq_('../shapes/Sphere');

      var Box = _dereq_('../shapes/Box');

      var Vec3 = _dereq_('../math/Vec3');

      var HingeConstraint = _dereq_('../constraints/HingeConstraint');

      var CMath = _dereq_('../math/CMath');

      module.exports = RigidVehicle;
      /**
       * Simple vehicle helper class with spherical rigid body wheels.
       * @class RigidVehicle
       * @constructor
       * @param {Body} [options.chassisBody]
       */

      function RigidVehicle(options) {
        this.wheelBodies = [];
        /**
         * @property coordinateSystem
         * @type {Vec3}
         */

        this.coordinateSystem = typeof options.coordinateSystem === 'undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();
        /**
         * @property {Body} chassisBody
         */

        this.chassisBody = options.chassisBody;

        if (!this.chassisBody) {
          // No chassis body given. Create it!
          var chassisShape = new Box(new Vec3(5, 2, 0.5));
          this.chassisBody = new Body(1, chassisShape);
        }
        /**
         * @property constraints
         * @type {Array}
         */


        this.constraints = [];
        this.wheelAxes = [];
        this.wheelForces = [];
      }
      /**
       * Add a wheel
       * @method addWheel
       * @param {object} options
       * @param {boolean} [options.isFrontWheel]
       * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
       * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
       * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
       * @param {Body} [options.body] The wheel body.
       */


      RigidVehicle.prototype.addWheel = function (options) {
        options = options || {};
        var wheelBody = options.body;

        if (!wheelBody) {
          wheelBody = new Body(1, new Sphere(1.2));
        }

        this.wheelBodies.push(wheelBody);
        this.wheelForces.push(0); // Position constrain wheels

        var zero = new Vec3();
        var position = typeof options.position !== 'undefined' ? options.position.clone() : new Vec3(); // Set position locally to the chassis

        var worldPosition = new Vec3();
        this.chassisBody.pointToWorldFrame(position, worldPosition);
        wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z); // Constrain wheel

        var axis = typeof options.axis !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
        this.wheelAxes.push(axis);
        var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
          pivotA: position,
          axisA: axis,
          pivotB: Vec3.ZERO,
          axisB: axis,
          collideConnected: false
        });
        this.constraints.push(hingeConstraint);
        return this.wheelBodies.length - 1;
      };
      /**
       * Set the steering value of a wheel.
       * @method setSteeringValue
       * @param {number} value
       * @param {integer} wheelIndex
       * @todo check coordinateSystem
       */


      RigidVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
        // Set angle of the hinge axis
        var axis = this.wheelAxes[wheelIndex];
        var c = CMath.cos(value),
            s = CMath.sin(value),
            x = axis.x,
            y = axis.y;
        this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
      };
      /**
       * Set the target rotational speed of the hinge constraint.
       * @method setMotorSpeed
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RigidVehicle.prototype.setMotorSpeed = function (value, wheelIndex) {
        var hingeConstraint = this.constraints[wheelIndex];
        hingeConstraint.enableMotor();
        hingeConstraint.motorTargetVelocity = value;
      };
      /**
       * Set the target rotational speed of the hinge constraint.
       * @method disableMotor
       * @param {number} value
       * @param {integer} wheelIndex
       */


      RigidVehicle.prototype.disableMotor = function (wheelIndex) {
        var hingeConstraint = this.constraints[wheelIndex];
        hingeConstraint.disableMotor();
      };

      var torque = new Vec3();
      /**
       * Set the wheel force to apply on one of the wheels each time step
       * @method setWheelForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */

      RigidVehicle.prototype.setWheelForce = function (value, wheelIndex) {
        this.wheelForces[wheelIndex] = value;
      };
      /**
       * Apply a torque on one of the wheels.
       * @method applyWheelForce
       * @param  {number} value
       * @param  {integer} wheelIndex
       */


      RigidVehicle.prototype.applyWheelForce = function (value, wheelIndex) {
        var axis = this.wheelAxes[wheelIndex];
        var wheelBody = this.wheelBodies[wheelIndex];
        var bodyTorque = wheelBody.torque;
        axis.scale(value, torque);
        wheelBody.vectorToWorldFrame(torque, torque);
        bodyTorque.vadd(torque, bodyTorque);
      };
      /**
       * Add the vehicle including its constraints to the world.
       * @method addToWorld
       * @param {World} world
       */


      RigidVehicle.prototype.addToWorld = function (world) {
        var constraints = this.constraints;
        var bodies = this.wheelBodies.concat([this.chassisBody]);

        for (var i = 0; i < bodies.length; i++) {
          world.addBody(bodies[i]);
        }

        for (var i = 0; i < constraints.length; i++) {
          world.addConstraint(constraints[i]);
        }

        world.addEventListener('preStep', this._update.bind(this));
      };

      RigidVehicle.prototype._update = function () {
        var wheelForces = this.wheelForces;

        for (var i = 0; i < wheelForces.length; i++) {
          this.applyWheelForce(wheelForces[i], i);
        }
      };
      /**
       * Remove the vehicle including its constraints from the world.
       * @method removeFromWorld
       * @param {World} world
       */


      RigidVehicle.prototype.removeFromWorld = function (world) {
        var constraints = this.constraints;
        var bodies = this.wheelBodies.concat([this.chassisBody]);

        for (var i = 0; i < bodies.length; i++) {
          world.remove(bodies[i]);
        }

        for (var i = 0; i < constraints.length; i++) {
          world.removeConstraint(constraints[i]);
        }
      };

      var worldAxis = new Vec3();
      /**
       * Get current rotational velocity of a wheel
       * @method getWheelSpeed
       * @param {integer} wheelIndex
       */

      RigidVehicle.prototype.getWheelSpeed = function (wheelIndex) {
        var axis = this.wheelAxes[wheelIndex];
        var wheelBody = this.wheelBodies[wheelIndex];
        var w = wheelBody.angularVelocity;
        this.chassisBody.vectorToWorldFrame(axis, worldAxis);
        return w.dot(worldAxis);
      };
    }, {
      "../constraints/HingeConstraint": 16,
      "../math/CMath": 27,
      "../math/Vec3": 32,
      "../shapes/Box": 39,
      "../shapes/Sphere": 46,
      "./Body": 33
    }],
    36: [function (_dereq_, module, exports) {
      module.exports = SPHSystem;

      var Shape = _dereq_('../shapes/Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Particle = _dereq_('../shapes/Particle');

      var Body = _dereq_('../objects/Body');

      var Material = _dereq_('../material/Material');
      /**
       * Smoothed-particle hydrodynamics system
       * @class SPHSystem
       * @constructor
       */


      function SPHSystem() {
        this.particles = [];
        /**
         * Density of the system (kg/m3).
         * @property {number} density
         */

        this.density = 1;
        /**
         * Distance below which two particles are considered to be neighbors.
         * It should be adjusted so there are about 15-20 neighbor particles within this radius.
         * @property {number} smoothingRadius
         */

        this.smoothingRadius = 1;
        this.speedOfSound = 1;
        /**
         * Viscosity of the system.
         * @property {number} viscosity
         */

        this.viscosity = 0.01;
        this.eps = 0.000001; // Stuff Computed per particle

        this.pressures = [];
        this.densities = [];
        this.neighbors = [];
      }
      /**
       * Add a particle to the system.
       * @method add
       * @param {Body} particle
       */


      SPHSystem.prototype.add = function (particle) {
        this.particles.push(particle);

        if (this.neighbors.length < this.particles.length) {
          this.neighbors.push([]);
        }
      };
      /**
       * Remove a particle from the system.
       * @method remove
       * @param {Body} particle
       */


      SPHSystem.prototype.remove = function (particle) {
        var idx = this.particles.indexOf(particle);

        if (idx !== -1) {
          this.particles.splice(idx, 1);

          if (this.neighbors.length > this.particles.length) {
            this.neighbors.pop();
          }
        }
      };
      /**
       * Get neighbors within smoothing volume, save in the array neighbors
       * @method getNeighbors
       * @param {Body} particle
       * @param {Array} neighbors
       */


      var SPHSystem_getNeighbors_dist = new Vec3();

      SPHSystem.prototype.getNeighbors = function (particle, neighbors) {
        var N = this.particles.length,
            id = particle.id,
            R2 = this.smoothingRadius * this.smoothingRadius,
            dist = SPHSystem_getNeighbors_dist;

        for (var i = 0; i !== N; i++) {
          var p = this.particles[i];
          p.position.vsub(particle.position, dist);

          if (id !== p.id && dist.norm2() < R2) {
            neighbors.push(p);
          }
        }
      }; // Temp vectors for calculation


      var SPHSystem_update_dist = new Vec3(),
          SPHSystem_update_a_pressure = new Vec3(),
          SPHSystem_update_a_visc = new Vec3(),
          SPHSystem_update_gradW = new Vec3(),
          SPHSystem_update_r_vec = new Vec3(),
          SPHSystem_update_u = new Vec3(); // Relative velocity

      SPHSystem.prototype.update = function () {
        var N = this.particles.length,
            dist = SPHSystem_update_dist,
            cs = this.speedOfSound,
            eps = this.eps;

        for (var i = 0; i !== N; i++) {
          var p = this.particles[i]; // Current particle

          var neighbors = this.neighbors[i]; // Get neighbors

          neighbors.length = 0;
          this.getNeighbors(p, neighbors);
          neighbors.push(this.particles[i]); // Add current too

          var numNeighbors = neighbors.length; // Accumulate density for the particle

          var sum = 0.0;

          for (var j = 0; j !== numNeighbors; j++) {
            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();
            var weight = this.w(len);
            sum += neighbors[j].mass * weight;
          } // Save


          this.densities[i] = sum;
          this.pressures[i] = cs * cs * (this.densities[i] - this.density);
        } // Add forces
        // Sum to these accelerations


        var a_pressure = SPHSystem_update_a_pressure;
        var a_visc = SPHSystem_update_a_visc;
        var gradW = SPHSystem_update_gradW;
        var r_vec = SPHSystem_update_r_vec;
        var u = SPHSystem_update_u;

        for (var i = 0; i !== N; i++) {
          var particle = this.particles[i];
          a_pressure.set(0, 0, 0);
          a_visc.set(0, 0, 0); // Init vars

          var Pij;
          var nabla;
          var Vij; // Sum up for all other neighbors

          var neighbors = this.neighbors[i];
          var numNeighbors = neighbors.length; //printf("Neighbors: ");

          for (var j = 0; j !== numNeighbors; j++) {
            var neighbor = neighbors[j]; //printf("%d ",nj);
            // Get r once for all..

            particle.position.vsub(neighbor.position, r_vec);
            var r = r_vec.norm(); // Pressure contribution

            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
            this.gradw(r_vec, gradW); // Add to pressure acceleration

            gradW.mult(Pij, gradW);
            a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

            neighbor.velocity.vsub(particle.velocity, u);
            u.mult(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
            nabla = this.nablaw(r);
            u.mult(nabla, u); // Add to viscosity acceleration

            a_visc.vadd(u, a_visc);
          } // Calculate force


          a_visc.mult(particle.mass, a_visc);
          a_pressure.mult(particle.mass, a_pressure); // Add force to particles

          particle.force.vadd(a_visc, particle.force);
          particle.force.vadd(a_pressure, particle.force);
        }
      }; // Calculate the weight using the W(r) weightfunction


      SPHSystem.prototype.w = function (r) {
        // 315
        var h = this.smoothingRadius;
        return 315.0 / (64.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
      }; // calculate gradient of the weight function


      SPHSystem.prototype.gradw = function (rVec, resultVec) {
        var r = rVec.norm(),
            h = this.smoothingRadius;
        rVec.mult(945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 2), resultVec);
      }; // Calculate nabla(W)


      SPHSystem.prototype.nablaw = function (r) {
        var h = this.smoothingRadius;
        var nabla = 945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
        return nabla;
      };
    }, {
      "../material/Material": 26,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../objects/Body": 33,
      "../shapes/Particle": 43,
      "../shapes/Shape": 45
    }],
    37: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      module.exports = Spring;
      /**
       * A spring, connecting two bodies.
       *
       * @class Spring
       * @constructor
       * @param {Body} bodyA
       * @param {Body} bodyB
       * @param {Object} [options]
       * @param {number} [options.restLength]   A number > 0. Default: 1
       * @param {number} [options.stiffness]    A number >= 0. Default: 100
       * @param {number} [options.damping]      A number >= 0. Default: 1
       * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
       * @param {Vec3}  [options.worldAnchorB]
       * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
       * @param {Vec3}  [options.localAnchorB]
       */

      function Spring(bodyA, bodyB, options) {
        options = options || {};
        /**
         * Rest length of the spring.
         * @property restLength
         * @type {number}
         */

        this.restLength = typeof options.restLength === "number" ? options.restLength : 1;
        /**
         * Stiffness of the spring.
         * @property stiffness
         * @type {number}
         */

        this.stiffness = options.stiffness || 100;
        /**
         * Damping of the spring.
         * @property damping
         * @type {number}
         */

        this.damping = options.damping || 1;
        /**
         * First connected body.
         * @property bodyA
         * @type {Body}
         */

        this.bodyA = bodyA;
        /**
         * Second connected body.
         * @property bodyB
         * @type {Body}
         */

        this.bodyB = bodyB;
        /**
         * Anchor for bodyA in local bodyA coordinates.
         * @property localAnchorA
         * @type {Vec3}
         */

        this.localAnchorA = new Vec3();
        /**
         * Anchor for bodyB in local bodyB coordinates.
         * @property localAnchorB
         * @type {Vec3}
         */

        this.localAnchorB = new Vec3();

        if (options.localAnchorA) {
          this.localAnchorA.copy(options.localAnchorA);
        }

        if (options.localAnchorB) {
          this.localAnchorB.copy(options.localAnchorB);
        }

        if (options.worldAnchorA) {
          this.setWorldAnchorA(options.worldAnchorA);
        }

        if (options.worldAnchorB) {
          this.setWorldAnchorB(options.worldAnchorB);
        }
      }
      /**
       * Set the anchor point on body A, using world coordinates.
       * @method setWorldAnchorA
       * @param {Vec3} worldAnchorA
       */


      Spring.prototype.setWorldAnchorA = function (worldAnchorA) {
        this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
      };
      /**
       * Set the anchor point on body B, using world coordinates.
       * @method setWorldAnchorB
       * @param {Vec3} worldAnchorB
       */


      Spring.prototype.setWorldAnchorB = function (worldAnchorB) {
        this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
      };
      /**
       * Get the anchor point on body A, in world coordinates.
       * @method getWorldAnchorA
       * @param {Vec3} result The vector to store the result in.
       */


      Spring.prototype.getWorldAnchorA = function (result) {
        this.bodyA.pointToWorldFrame(this.localAnchorA, result);
      };
      /**
       * Get the anchor point on body B, in world coordinates.
       * @method getWorldAnchorB
       * @param {Vec3} result The vector to store the result in.
       */


      Spring.prototype.getWorldAnchorB = function (result) {
        this.bodyB.pointToWorldFrame(this.localAnchorB, result);
      };

      var applyForce_r = new Vec3(),
          applyForce_r_unit = new Vec3(),
          applyForce_u = new Vec3(),
          applyForce_f = new Vec3(),
          applyForce_worldAnchorA = new Vec3(),
          applyForce_worldAnchorB = new Vec3(),
          applyForce_ri = new Vec3(),
          applyForce_rj = new Vec3(),
          applyForce_ri_x_f = new Vec3(),
          applyForce_rj_x_f = new Vec3(),
          applyForce_tmp = new Vec3();
      /**
       * Apply the spring force to the connected bodies.
       * @method applyForce
       */

      Spring.prototype.applyForce = function () {
        var k = this.stiffness,
            d = this.damping,
            l = this.restLength,
            bodyA = this.bodyA,
            bodyB = this.bodyB,
            r = applyForce_r,
            r_unit = applyForce_r_unit,
            u = applyForce_u,
            f = applyForce_f,
            tmp = applyForce_tmp;
        var worldAnchorA = applyForce_worldAnchorA,
            worldAnchorB = applyForce_worldAnchorB,
            ri = applyForce_ri,
            rj = applyForce_rj,
            ri_x_f = applyForce_ri_x_f,
            rj_x_f = applyForce_rj_x_f; // Get world anchors

        this.getWorldAnchorA(worldAnchorA);
        this.getWorldAnchorB(worldAnchorB); // Get offset points

        worldAnchorA.vsub(bodyA.position, ri);
        worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

        worldAnchorB.vsub(worldAnchorA, r);
        var rlen = r.norm();
        r_unit.copy(r);
        r_unit.normalize(); // Compute relative velocity of the anchor points, u

        bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

        bodyB.angularVelocity.cross(rj, tmp);
        u.vadd(tmp, u);
        bodyA.angularVelocity.cross(ri, tmp);
        u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

        r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

        bodyA.force.vsub(f, bodyA.force);
        bodyB.force.vadd(f, bodyB.force); // Angular force

        ri.cross(f, ri_x_f);
        rj.cross(f, rj_x_f);
        bodyA.torque.vsub(ri_x_f, bodyA.torque);
        bodyB.torque.vadd(rj_x_f, bodyB.torque);
      };
    }, {
      "../math/Vec3": 32
    }],
    38: [function (_dereq_, module, exports) {
      var Vec3 = _dereq_('../math/Vec3');

      var Transform = _dereq_('../math/Transform');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var Utils = _dereq_('../utils/Utils');

      module.exports = WheelInfo;
      /**
       * @class WheelInfo
       * @constructor
       * @param {Object} [options]
       *
       * @param {Vec3} [options.chassisConnectionPointLocal]
       * @param {Vec3} [options.chassisConnectionPointWorld]
       * @param {Vec3} [options.directionLocal]
       * @param {Vec3} [options.directionWorld]
       * @param {Vec3} [options.axleLocal]
       * @param {Vec3} [options.axleWorld]
       * @param {number} [options.suspensionRestLength=1]
       * @param {number} [options.suspensionMaxLength=2]
       * @param {number} [options.radius=1]
       * @param {number} [options.suspensionStiffness=100]
       * @param {number} [options.dampingCompression=10]
       * @param {number} [options.dampingRelaxation=10]
       * @param {number} [options.frictionSlip=10000]
       * @param {number} [options.steering=0]
       * @param {number} [options.rotation=0]
       * @param {number} [options.deltaRotation=0]
       * @param {number} [options.rollInfluence=0.01]
       * @param {number} [options.maxSuspensionForce]
       * @param {boolean} [options.isFrontWheel=true]
       * @param {number} [options.clippedInvContactDotSuspension=1]
       * @param {number} [options.suspensionRelativeVelocity=0]
       * @param {number} [options.suspensionForce=0]
       * @param {number} [options.skidInfo=0]
       * @param {number} [options.suspensionLength=0]
       * @param {number} [options.maxSuspensionTravel=1]
       * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
       * @param {number} [options.customSlidingRotationalSpeed=-0.1]
       */

      function WheelInfo(options) {
        options = Utils.defaults(options, {
          chassisConnectionPointLocal: new Vec3(),
          chassisConnectionPointWorld: new Vec3(),
          directionLocal: new Vec3(),
          directionWorld: new Vec3(),
          axleLocal: new Vec3(),
          axleWorld: new Vec3(),
          suspensionRestLength: 1,
          suspensionMaxLength: 2,
          radius: 1,
          suspensionStiffness: 100,
          dampingCompression: 10,
          dampingRelaxation: 10,
          frictionSlip: 10000,
          steering: 0,
          rotation: 0,
          deltaRotation: 0,
          rollInfluence: 0.01,
          maxSuspensionForce: Number.MAX_VALUE,
          isFrontWheel: true,
          clippedInvContactDotSuspension: 1,
          suspensionRelativeVelocity: 0,
          suspensionForce: 0,
          skidInfo: 0,
          suspensionLength: 0,
          maxSuspensionTravel: 1,
          useCustomSlidingRotationalSpeed: false,
          customSlidingRotationalSpeed: -0.1
        });
        /**
         * Max travel distance of the suspension, in meters.
         * @property {number} maxSuspensionTravel
         */

        this.maxSuspensionTravel = options.maxSuspensionTravel;
        /**
         * Speed to apply to the wheel rotation when the wheel is sliding.
         * @property {number} customSlidingRotationalSpeed
         */

        this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
        /**
         * If the customSlidingRotationalSpeed should be used.
         * @property {Boolean} useCustomSlidingRotationalSpeed
         */

        this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
        /**
         * @property {Boolean} sliding
         */

        this.sliding = false;
        /**
         * Connection point, defined locally in the chassis body frame.
         * @property {Vec3} chassisConnectionPointLocal
         */

        this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
        /**
         * @property {Vec3} chassisConnectionPointWorld
         */

        this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
        /**
         * @property {Vec3} directionLocal
         */

        this.directionLocal = options.directionLocal.clone();
        /**
         * @property {Vec3} directionWorld
         */

        this.directionWorld = options.directionWorld.clone();
        /**
         * @property {Vec3} axleLocal
         */

        this.axleLocal = options.axleLocal.clone();
        /**
         * @property {Vec3} axleWorld
         */

        this.axleWorld = options.axleWorld.clone();
        /**
         * @property {number} suspensionRestLength
         */

        this.suspensionRestLength = options.suspensionRestLength;
        /**
         * @property {number} suspensionMaxLength
         */

        this.suspensionMaxLength = options.suspensionMaxLength;
        /**
         * @property {number} radius
         */

        this.radius = options.radius;
        /**
         * @property {number} suspensionStiffness
         */

        this.suspensionStiffness = options.suspensionStiffness;
        /**
         * @property {number} dampingCompression
         */

        this.dampingCompression = options.dampingCompression;
        /**
         * @property {number} dampingRelaxation
         */

        this.dampingRelaxation = options.dampingRelaxation;
        /**
         * @property {number} frictionSlip
         */

        this.frictionSlip = options.frictionSlip;
        /**
         * @property {number} steering
         */

        this.steering = 0;
        /**
         * Rotation value, in radians.
         * @property {number} rotation
         */

        this.rotation = 0;
        /**
         * @property {number} deltaRotation
         */

        this.deltaRotation = 0;
        /**
         * @property {number} rollInfluence
         */

        this.rollInfluence = options.rollInfluence;
        /**
         * @property {number} maxSuspensionForce
         */

        this.maxSuspensionForce = options.maxSuspensionForce;
        /**
         * @property {number} engineForce
         */

        this.engineForce = 0;
        /**
         * @property {number} brake
         */

        this.brake = 0;
        /**
         * @property {number} isFrontWheel
         */

        this.isFrontWheel = options.isFrontWheel;
        /**
         * @property {number} clippedInvContactDotSuspension
         */

        this.clippedInvContactDotSuspension = 1;
        /**
         * @property {number} suspensionRelativeVelocity
         */

        this.suspensionRelativeVelocity = 0;
        /**
         * @property {number} suspensionForce
         */

        this.suspensionForce = 0;
        /**
         * @property {number} skidInfo
         */

        this.skidInfo = 0;
        /**
         * @property {number} suspensionLength
         */

        this.suspensionLength = 0;
        /**
         * @property {number} sideImpulse
         */

        this.sideImpulse = 0;
        /**
         * @property {number} forwardImpulse
         */

        this.forwardImpulse = 0;
        /**
         * The result from raycasting
         * @property {RaycastResult} raycastResult
         */

        this.raycastResult = new RaycastResult();
        /**
         * Wheel world transform
         * @property {Transform} worldTransform
         */

        this.worldTransform = new Transform();
        /**
         * @property {boolean} isInContact
         */

        this.isInContact = false;
      }

      var chassis_velocity_at_contactPoint = new Vec3();
      var relpos = new Vec3();
      var chassis_velocity_at_contactPoint = new Vec3();

      WheelInfo.prototype.updateWheel = function (chassis) {
        var raycastResult = this.raycastResult;

        if (this.isInContact) {
          var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
          raycastResult.hitPointWorld.vsub(chassis.position, relpos);
          chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
          var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

          if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
          } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
          }
        } else {
          // Not in contact : position wheel in a nice (rest length) position
          raycastResult.suspensionLength = this.suspensionRestLength;
          this.suspensionRelativeVelocity = 0.0;
          raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
          this.clippedInvContactDotSuspension = 1.0;
        }
      };
    }, {
      "../collision/RaycastResult": 11,
      "../math/Transform": 31,
      "../math/Vec3": 32,
      "../utils/Utils": 55
    }],
    39: [function (_dereq_, module, exports) {
      module.exports = Box;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
      /**
       * A 3d box shape.
       * @class Box
       * @constructor
       * @param {Vec3} halfExtents
       * @author schteppe
       * @extends Shape
       */


      function Box(halfExtents) {
        Shape.call(this, {
          type: Shape.types.BOX
        });
        /**
         * @property halfExtents
         * @type {Vec3}
         */

        this.halfExtents = halfExtents;
        /**
         * Used by the contact generator to make contacts with other convex polyhedra for example
         * @property convexPolyhedronRepresentation
         * @type {ConvexPolyhedron}
         */

        this.convexPolyhedronRepresentation = null;
        this.updateConvexPolyhedronRepresentation();
        this.updateBoundingSphereRadius();
      }

      Box.prototype = new Shape();
      Box.prototype.constructor = Box;
      /**
       * Updates the local convex polyhedron representation used for some collisions.
       * @method updateConvexPolyhedronRepresentation
       */

      Box.prototype.updateConvexPolyhedronRepresentation = function () {
        var sx = this.halfExtents.x;
        var sy = this.halfExtents.y;
        var sz = this.halfExtents.z;
        var V = Vec3;
        var vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
        var indices = [[3, 2, 1, 0], // -z
        [4, 5, 6, 7], // +z
        [5, 4, 0, 1], // -y
        [2, 3, 7, 6], // +y
        [0, 4, 7, 3], // -x
        [1, 2, 6, 5] // +x
        ];
        var axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
        var h = new ConvexPolyhedron(vertices, indices);
        this.convexPolyhedronRepresentation = h;
        h.material = this.material;
      };
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3}
       */


      Box.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        Box.calculateInertia(this.halfExtents, mass, target);
        return target;
      };

      Box.calculateInertia = function (halfExtents, mass, target) {
        var e = halfExtents;

        if (e.isZero()) {
          target.x = 2.0 / 12.0 * mass;
          target.y = 2.0 / 12.0 * mass;
          target.z = 2.0 / 12.0 * mass;
        } else {
          target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
          target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
          target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
        }
      };
      /**
       * Get the box 6 side normals
       * @method getSideNormals
       * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
       * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
       * @return {array}
       */


      Box.prototype.getSideNormals = function (sixTargetVectors, quat) {
        var sides = sixTargetVectors;
        var ex = this.halfExtents;
        sides[0].set(ex.x, 0, 0);
        sides[1].set(0, ex.y, 0);
        sides[2].set(0, 0, ex.z);
        sides[3].set(-ex.x, 0, 0);
        sides[4].set(0, -ex.y, 0);
        sides[5].set(0, 0, -ex.z);

        if (quat !== undefined) {
          for (var i = 0; i !== sides.length; i++) {
            quat.vmult(sides[i], sides[i]);
          }
        }

        return sides;
      };

      Box.prototype.volume = function () {
        return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
      };

      Box.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = this.halfExtents.norm();
      };

      var worldCornerTempPos = new Vec3();
      var worldCornerTempNeg = new Vec3();

      Box.prototype.forEachWorldCorner = function (pos, quat, callback) {
        var e = this.halfExtents;
        var corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

        for (var i = 0; i < corners.length; i++) {
          worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
          quat.vmult(worldCornerTempPos, worldCornerTempPos);
          pos.vadd(worldCornerTempPos, worldCornerTempPos);
          callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
        }
      };

      var worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

      Box.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var e = this.halfExtents;
        worldCornersTemp[0].set(e.x, e.y, e.z);
        worldCornersTemp[1].set(-e.x, e.y, e.z);
        worldCornersTemp[2].set(-e.x, -e.y, e.z);
        worldCornersTemp[3].set(-e.x, -e.y, -e.z);
        worldCornersTemp[4].set(e.x, -e.y, -e.z);
        worldCornersTemp[5].set(e.x, e.y, -e.z);
        worldCornersTemp[6].set(-e.x, e.y, -e.z);
        worldCornersTemp[7].set(e.x, -e.y, e.z);
        var wc = worldCornersTemp[0];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        max.copy(wc);
        min.copy(wc);

        for (var i = 1; i < 8; i++) {
          var wc = worldCornersTemp[i];
          quat.vmult(wc, wc);
          pos.vadd(wc, wc);
          var x = wc.x;
          var y = wc.y;
          var z = wc.z;

          if (x > max.x) {
            max.x = x;
          }

          if (y > max.y) {
            max.y = y;
          }

          if (z > max.z) {
            max.z = z;
          }

          if (x < min.x) {
            min.x = x;
          }

          if (y < min.y) {
            min.y = y;
          }

          if (z < min.z) {
            min.z = z;
          }
        } // Get each axis max
        // min.set(Infinity,Infinity,Infinity);
        // max.set(-Infinity,-Infinity,-Infinity);
        // this.forEachWorldCorner(pos,quat,function(x,y,z){
        //     if(x > max.x){
        //         max.x = x;
        //     }
        //     if(y > max.y){
        //         max.y = y;
        //     }
        //     if(z > max.z){
        //         max.z = z;
        //     }
        //     if(x < min.x){
        //         min.x = x;
        //     }
        //     if(y < min.y){
        //         min.y = y;
        //     }
        //     if(z < min.z){
        //         min.z = z;
        //     }
        // });

      };
    }, {
      "../math/Vec3": 32,
      "./ConvexPolyhedron": 40,
      "./Shape": 45
    }],
    40: [function (_dereq_, module, exports) {
      module.exports = ConvexPolyhedron;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');
      /**
       * A set of polygons describing a convex shape.
       * @class ConvexPolyhedron
       * @constructor
       * @extends Shape
       * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
       * in the same 3D plane), instead these should be merged into one polygon.
       *
       * @param {array} points An array of Vec3's
       * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
       *
       * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
       * @author schteppe / https://github.com/schteppe
       * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
       * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
       *
       * @todo Move the clipping functions to ContactGenerator?
       * @todo Automatically merge coplanar polygons in constructor.
       */


      function ConvexPolyhedron(points, faces, uniqueAxes) {
        Shape.call(this, {
          type: Shape.types.CONVEXPOLYHEDRON
        });
        /**
         * Array of Vec3
         * @property vertices
         * @type {Array}
         */

        this.vertices = points || [];
        this.worldVertices = []; // World transformed version of .vertices

        this.worldVerticesNeedsUpdate = true;
        /**
         * Array of integer arrays, indicating which vertices each face consists of
         * @property faces
         * @type {Array}
         */

        this.faces = faces || [];
        /**
         * Array of Vec3
         * @property faceNormals
         * @type {Array}
         */

        this.faceNormals = [];
        this.computeNormals();
        this.worldFaceNormalsNeedsUpdate = true;
        this.worldFaceNormals = []; // World transformed version of .faceNormals

        /**
         * Array of Vec3
         * @property uniqueEdges
         * @type {Array}
         */

        this.uniqueEdges = [];
        /**
         * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
         * @property {Array} uniqueAxes
         */

        this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;
        this.computeEdges();
        this.updateBoundingSphereRadius();
      }

      ConvexPolyhedron.prototype = new Shape();
      ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;
      var computeEdges_tmpEdge = new Vec3();
      /**
       * Computes uniqueEdges
       * @method computeEdges
       */

      ConvexPolyhedron.prototype.computeEdges = function () {
        var faces = this.faces;
        var vertices = this.vertices;
        var nv = vertices.length;
        var edges = this.uniqueEdges;
        edges.length = 0;
        var edge = computeEdges_tmpEdge;

        for (var i = 0; i !== faces.length; i++) {
          var face = faces[i];
          var numVertices = face.length;

          for (var j = 0; j !== numVertices; j++) {
            var k = (j + 1) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;

            for (var p = 0; p !== edges.length; p++) {
              if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                found = true;
                break;
              }
            }

            if (!found) {
              edges.push(edge.clone());
            }
          }
        }
      };
      /**
       * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
       * @method computeNormals
       */


      ConvexPolyhedron.prototype.computeNormals = function () {
        this.faceNormals.length = this.faces.length; // Generate normals

        for (var i = 0; i < this.faces.length; i++) {
          // Check so all vertices exists for this face
          for (var j = 0; j < this.faces[i].length; j++) {
            if (!this.vertices[this.faces[i][j]]) {
              throw new Error("Vertex " + this.faces[i][j] + " not found!");
            }
          }

          var n = this.faceNormals[i] || new Vec3();
          this.getFaceNormal(i, n);
          n.negate(n);
          this.faceNormals[i] = n;
          var vertex = this.vertices[this.faces[i][0]];

          if (n.dot(vertex) < 0) {
            console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");

            for (var j = 0; j < this.faces[i].length; j++) {
              console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
            }
          }
        }
      };
      /**
       * Get face normal given 3 vertices
       * @static
       * @method getFaceNormal
       * @param {Vec3} va
       * @param {Vec3} vb
       * @param {Vec3} vc
       * @param {Vec3} target
       */


      var cb = new Vec3();
      var ab = new Vec3();

      ConvexPolyhedron.computeNormal = function (va, vb, vc, target) {
        vb.vsub(va, ab);
        vc.vsub(vb, cb);
        cb.cross(ab, target);

        if (!target.isZero()) {
          target.normalize();
        }
      };
      /**
       * Compute the normal of a face from its vertices
       * @method getFaceNormal
       * @param  {Number} i
       * @param  {Vec3} target
       */


      ConvexPolyhedron.prototype.getFaceNormal = function (i, target) {
        var f = this.faces[i];
        var va = this.vertices[f[0]];
        var vb = this.vertices[f[1]];
        var vc = this.vertices[f[2]];
        return ConvexPolyhedron.computeNormal(va, vb, vc, target);
      };
      /**
       * @method clipAgainstHull
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @param {Vec3} separatingNormal
       * @param {Number} minDist Clamp distance
       * @param {Number} maxDist
       * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
       * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
       */


      var cah_WorldNormal = new Vec3();

      ConvexPolyhedron.prototype.clipAgainstHull = function (posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
        var WorldNormal = cah_WorldNormal;
        var hullA = this;
        var curMaxDist = maxDist;
        var closestFaceB = -1;
        var dmax = -Number.MAX_VALUE;

        for (var face = 0; face < hullB.faces.length; face++) {
          WorldNormal.copy(hullB.faceNormals[face]);
          quatB.vmult(WorldNormal, WorldNormal); //posB.vadd(WorldNormal,WorldNormal);

          var d = WorldNormal.dot(separatingNormal);

          if (d > dmax) {
            dmax = d;
            closestFaceB = face;
          }
        }

        var worldVertsB1 = [];
        var polyB = hullB.faces[closestFaceB];
        var numVertices = polyB.length;

        for (var e0 = 0; e0 < numVertices; e0++) {
          var b = hullB.vertices[polyB[e0]];
          var worldb = new Vec3();
          worldb.copy(b);
          quatB.vmult(worldb, worldb);
          posB.vadd(worldb, worldb);
          worldVertsB1.push(worldb);
        }

        if (closestFaceB >= 0) {
          this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
        }
      };
      /**
       * Find the separating axis between this hull and another
       * @method findSeparatingAxis
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @param {Vec3} target The target vector to save the axis in
       * @return {bool} Returns false if a separation is found, else true
       */


      var fsa_faceANormalWS3 = new Vec3(),
          fsa_Worldnormal1 = new Vec3(),
          fsa_deltaC = new Vec3(),
          fsa_worldEdge0 = new Vec3(),
          fsa_worldEdge1 = new Vec3(),
          fsa_Cross = new Vec3();

      ConvexPolyhedron.prototype.findSeparatingAxis = function (hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
        var faceANormalWS3 = fsa_faceANormalWS3,
            Worldnormal1 = fsa_Worldnormal1,
            deltaC = fsa_deltaC,
            worldEdge0 = fsa_worldEdge0,
            worldEdge1 = fsa_worldEdge1,
            Cross = fsa_Cross;
        var dmin = Number.MAX_VALUE;
        var hullA = this;
        var curPlaneTests = 0;

        if (!hullA.uniqueAxes) {
          var numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

          for (var i = 0; i < numFacesA; i++) {
            var fi = faceListA ? faceListA[i] : i; // Get world face normal

            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3, faceANormalWS3);
            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(faceANormalWS3);
            }
          }
        } else {
          // Test unique axes
          for (var i = 0; i !== hullA.uniqueAxes.length; i++) {
            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(faceANormalWS3);
            }
          }
        }

        if (!hullB.uniqueAxes) {
          // Test face normals from hullB
          var numFacesB = faceListB ? faceListB.length : hullB.faces.length;

          for (var i = 0; i < numFacesB; i++) {
            var fi = faceListB ? faceListB[i] : i;
            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1, Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(Worldnormal1);
            }
          }
        } else {
          // Test unique axes in B
          for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
            quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

            if (d === false) {
              return false;
            }

            if (d < dmin) {
              dmin = d;
              target.copy(Worldnormal1);
            }
          }
        } // Test edges


        for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
          // Get world edge
          quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

          for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1, Cross);

            if (!Cross.almostZero()) {
              Cross.normalize();
              var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

              if (dist === false) {
                return false;
              }

              if (dist < dmin) {
                dmin = dist;
                target.copy(Cross);
              }
            }
          }
        }

        posB.vsub(posA, deltaC);

        if (deltaC.dot(target) > 0.0) {
          target.negate(target);
        }

        return true;
      };

      var maxminA = [],
          maxminB = [];
      /**
       * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
       * @method testSepAxis
       * @param {Vec3} axis
       * @param {ConvexPolyhedron} hullB
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Vec3} posB
       * @param {Quaternion} quatB
       * @return {number} The overlap depth, or FALSE if no penetration.
       */

      ConvexPolyhedron.prototype.testSepAxis = function (axis, hullB, posA, quatA, posB, quatB) {
        var hullA = this;
        ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
        ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
        var maxA = maxminA[0];
        var minA = maxminA[1];
        var maxB = maxminB[0];
        var minB = maxminB[1];

        if (maxA < minB || maxB < minA) {
          return false; // Separated
        }

        var d0 = maxA - minB;
        var d1 = maxB - minA;
        var depth = d0 < d1 ? d0 : d1;
        return depth;
      };

      var cli_aabbmin = new Vec3(),
          cli_aabbmax = new Vec3();
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       */

      ConvexPolyhedron.prototype.calculateLocalInertia = function (mass, target) {
        // Approximate with box inertia
        // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
        this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
        var x = cli_aabbmax.x - cli_aabbmin.x,
            y = cli_aabbmax.y - cli_aabbmin.y,
            z = cli_aabbmax.z - cli_aabbmin.z;
        target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
        target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
        target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
      };
      /**
       * @method getPlaneConstantOfFace
       * @param  {Number} face_i Index of the face
       * @return {Number}
       */


      ConvexPolyhedron.prototype.getPlaneConstantOfFace = function (face_i) {
        var f = this.faces[face_i];
        var n = this.faceNormals[face_i];
        var v = this.vertices[f[0]];
        var c = -n.dot(v);
        return c;
      };
      /**
       * Clip a face against a hull.
       * @method clipFaceAgainstHull
       * @param {Vec3} separatingNormal
       * @param {Vec3} posA
       * @param {Quaternion} quatA
       * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
       * @param {Number} minDist Distance clamping
       * @param {Number} maxDist
       * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
       */


      var cfah_faceANormalWS = new Vec3(),
          cfah_edge0 = new Vec3(),
          cfah_WorldEdge0 = new Vec3(),
          cfah_worldPlaneAnormal1 = new Vec3(),
          cfah_planeNormalWS1 = new Vec3(),
          cfah_worldA1 = new Vec3(),
          cfah_localPlaneNormal = new Vec3(),
          cfah_planeNormalWS = new Vec3();

      ConvexPolyhedron.prototype.clipFaceAgainstHull = function (separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
        var faceANormalWS = cfah_faceANormalWS,
            edge0 = cfah_edge0,
            WorldEdge0 = cfah_WorldEdge0,
            worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
            planeNormalWS1 = cfah_planeNormalWS1,
            worldA1 = cfah_worldA1,
            localPlaneNormal = cfah_localPlaneNormal,
            planeNormalWS = cfah_planeNormalWS;
        var hullA = this;
        var worldVertsB2 = [];
        var pVtxIn = worldVertsB1;
        var pVtxOut = worldVertsB2; // Find the face with normal closest to the separating axis

        var closestFaceA = -1;
        var dmin = Number.MAX_VALUE;

        for (var face = 0; face < hullA.faces.length; face++) {
          faceANormalWS.copy(hullA.faceNormals[face]);
          quatA.vmult(faceANormalWS, faceANormalWS); //posA.vadd(faceANormalWS,faceANormalWS);

          var d = faceANormalWS.dot(separatingNormal);

          if (d < dmin) {
            dmin = d;
            closestFaceA = face;
          }
        }

        if (closestFaceA < 0) {
          // console.log("--- did not find any closest face... ---");
          return;
        } //console.log("closest A: ",closestFaceA);
        // Get the face and construct connected faces


        var polyA = hullA.faces[closestFaceA];
        polyA.connectedFaces = [];

        for (var i = 0; i < hullA.faces.length; i++) {
          for (var j = 0; j < hullA.faces[i].length; j++) {
            if (polyA.indexOf(hullA.faces[i][j]) !== -1
            /* Sharing a vertex*/
            && i !== closestFaceA
            /* Not the one we are looking for connections from */
            && polyA.connectedFaces.indexOf(i) === -1
            /* Not already added */
            ) {
                polyA.connectedFaces.push(i);
              }
          }
        } // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face


        var numContacts = pVtxIn.length;
        var numVerticesA = polyA.length;
        var res = [];

        for (var e0 = 0; e0 < numVerticesA; e0++) {
          var a = hullA.vertices[polyA[e0]];
          var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];
          a.vsub(b, edge0);
          WorldEdge0.copy(edge0);
          quatA.vmult(WorldEdge0, WorldEdge0);
          posA.vadd(WorldEdge0, WorldEdge0);
          worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]); //transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);

          quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
          posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
          WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
          planeNormalWS1.negate(planeNormalWS1);
          worldA1.copy(a);
          quatA.vmult(worldA1, worldA1);
          posA.vadd(worldA1, worldA1);
          var planeEqWS1 = -worldA1.dot(planeNormalWS1);
          var planeEqWS;

          if (true) {
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this.faceNormals[otherFace]);
            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS, planeNormalWS); //posA.vadd(planeNormalWS,planeNormalWS);

            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
          } else {
            planeNormalWS.copy(planeNormalWS1);
            planeEqWS = planeEqWS1;
          } // Clip face against our constructed plane


          this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the reamining until next clip

          while (pVtxIn.length) {
            pVtxIn.shift();
          }

          while (pVtxOut.length) {
            pVtxIn.push(pVtxOut.shift());
          }
        } //console.log("Resulting points after clip:",pVtxIn);
        // only keep contact points that are behind the witness face


        localPlaneNormal.copy(this.faceNormals[closestFaceA]);
        var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
        planeNormalWS.copy(localPlaneNormal);
        quatA.vmult(planeNormalWS, planeNormalWS);
        var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

        for (var i = 0; i < pVtxIn.length; i++) {
          var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???

          /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/

          if (depth <= minDist) {
            // console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
          }

          if (depth <= maxDist) {
            var point = pVtxIn[i];

            if (depth <= 0) {
              /*console.log("Got contact point ",point.toString(),
                ", depth=",depth,
                "contact normal=",separatingNormal.toString(),
                "plane",planeNormalWS.toString(),
                "planeConstant",planeEqWS);*/
              var p = {
                point: point,
                normal: planeNormalWS,
                depth: depth
              };
              result.push(p);
            }
          }
        }
      };
      /**
       * Clip a face in a hull against the back of a plane.
       * @method clipFaceAgainstPlane
       * @param {Array} inVertices
       * @param {Array} outVertices
       * @param {Vec3} planeNormal
       * @param {Number} planeConstant The constant in the mathematical plane equation
       */


      ConvexPolyhedron.prototype.clipFaceAgainstPlane = function (inVertices, outVertices, planeNormal, planeConstant) {
        var n_dot_first, n_dot_last;
        var numVerts = inVertices.length;

        if (numVerts < 2) {
          return outVertices;
        }

        var firstVertex = inVertices[inVertices.length - 1],
            lastVertex = inVertices[0];
        n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

        for (var vi = 0; vi < numVerts; vi++) {
          lastVertex = inVertices[vi];
          n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

          if (n_dot_first < 0) {
            if (n_dot_last < 0) {
              // Start < 0, end < 0, so output lastVertex
              var newv = new Vec3();
              newv.copy(lastVertex);
              outVertices.push(newv);
            } else {
              // Start < 0, end >= 0, so output intersection
              var newv = new Vec3();
              firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
              outVertices.push(newv);
            }
          } else {
            if (n_dot_last < 0) {
              // Start >= 0, end < 0 so output intersection and end
              var newv = new Vec3();
              firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
              outVertices.push(newv);
              outVertices.push(lastVertex);
            }
          }

          firstVertex = lastVertex;
          n_dot_first = n_dot_last;
        }

        return outVertices;
      }; // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.


      ConvexPolyhedron.prototype.computeWorldVertices = function (position, quat) {
        var N = this.vertices.length;

        while (this.worldVertices.length < N) {
          this.worldVertices.push(new Vec3());
        }

        var verts = this.vertices,
            worldVerts = this.worldVertices;

        for (var i = 0; i !== N; i++) {
          quat.vmult(verts[i], worldVerts[i]);
          position.vadd(worldVerts[i], worldVerts[i]);
        }

        this.worldVerticesNeedsUpdate = false;
      };

      var computeLocalAABB_worldVert = new Vec3();

      ConvexPolyhedron.prototype.computeLocalAABB = function (aabbmin, aabbmax) {
        var n = this.vertices.length,
            vertices = this.vertices,
            worldVert = computeLocalAABB_worldVert;
        aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

        for (var i = 0; i < n; i++) {
          var v = vertices[i];

          if (v.x < aabbmin.x) {
            aabbmin.x = v.x;
          } else if (v.x > aabbmax.x) {
            aabbmax.x = v.x;
          }

          if (v.y < aabbmin.y) {
            aabbmin.y = v.y;
          } else if (v.y > aabbmax.y) {
            aabbmax.y = v.y;
          }

          if (v.z < aabbmin.z) {
            aabbmin.z = v.z;
          } else if (v.z > aabbmax.z) {
            aabbmax.z = v.z;
          }
        }
      };
      /**
       * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
       * @method computeWorldFaceNormals
       * @param  {Quaternion} quat
       */


      ConvexPolyhedron.prototype.computeWorldFaceNormals = function (quat) {
        var N = this.faceNormals.length;

        while (this.worldFaceNormals.length < N) {
          this.worldFaceNormals.push(new Vec3());
        }

        var normals = this.faceNormals,
            worldNormals = this.worldFaceNormals;

        for (var i = 0; i !== N; i++) {
          quat.vmult(normals[i], worldNormals[i]);
        }

        this.worldFaceNormalsNeedsUpdate = false;
      };
      /**
       * @method updateBoundingSphereRadius
       */


      ConvexPolyhedron.prototype.updateBoundingSphereRadius = function () {
        // Assume points are distributed with local (0,0,0) as center
        var max2 = 0;
        var verts = this.vertices;

        for (var i = 0, N = verts.length; i !== N; i++) {
          var norm2 = verts[i].norm2();

          if (norm2 > max2) {
            max2 = norm2;
          }
        }

        this.boundingSphereRadius = Math.sqrt(max2);
      };

      var tempWorldVertex = new Vec3();
      /**
       * @method calculateWorldAABB
       * @param {Vec3}        pos
       * @param {Quaternion}  quat
       * @param {Vec3}        min
       * @param {Vec3}        max
       */

      ConvexPolyhedron.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var n = this.vertices.length,
            verts = this.vertices;
        var minx, miny, minz, maxx, maxy, maxz;

        for (var i = 0; i < n; i++) {
          tempWorldVertex.copy(verts[i]);
          quat.vmult(tempWorldVertex, tempWorldVertex);
          pos.vadd(tempWorldVertex, tempWorldVertex);
          var v = tempWorldVertex;

          if (v.x < minx || minx === undefined) {
            minx = v.x;
          }

          if (v.x > maxx || maxx === undefined) {
            maxx = v.x;
          }

          if (v.y < miny || miny === undefined) {
            miny = v.y;
          }

          if (v.y > maxy || maxy === undefined) {
            maxy = v.y;
          }

          if (v.z < minz || minz === undefined) {
            minz = v.z;
          }

          if (v.z > maxz || maxz === undefined) {
            maxz = v.z;
          }
        }

        min.set(minx, miny, minz);
        max.set(maxx, maxy, maxz);
      };
      /**
       * Get approximate convex volume
       * @method volume
       * @return {Number}
       */


      ConvexPolyhedron.prototype.volume = function () {
        return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
      };
      /**
       * Get an average of all the vertices positions
       * @method getAveragePointLocal
       * @param  {Vec3} target
       * @return {Vec3}
       */


      ConvexPolyhedron.prototype.getAveragePointLocal = function (target) {
        target = target || new Vec3();
        var n = this.vertices.length,
            verts = this.vertices;

        for (var i = 0; i < n; i++) {
          target.vadd(verts[i], target);
        }

        target.mult(1 / n, target);
        return target;
      };
      /**
       * Transform all local points. Will change the .vertices
       * @method transformAllPoints
       * @param  {Vec3} offset
       * @param  {Quaternion} quat
       */


      ConvexPolyhedron.prototype.transformAllPoints = function (offset, quat) {
        var n = this.vertices.length,
            verts = this.vertices; // Apply rotation

        if (quat) {
          // Rotate vertices
          for (var i = 0; i < n; i++) {
            var v = verts[i];
            quat.vmult(v, v);
          } // Rotate face normals


          for (var i = 0; i < this.faceNormals.length; i++) {
            var v = this.faceNormals[i];
            quat.vmult(v, v);
          }
          /*
          // Rotate edges
          for(var i=0; i<this.uniqueEdges.length; i++){
              var v = this.uniqueEdges[i];
              quat.vmult(v,v);
          }*/

        } // Apply offset


        if (offset) {
          for (var i = 0; i < n; i++) {
            var v = verts[i];
            v.vadd(offset, v);
          }
        }
      };
      /**
       * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
       * @method pointIsInside
       * @param  {Vec3} p      A point given in local coordinates
       * @return {Boolean}
       */


      var ConvexPolyhedron_pointIsInside = new Vec3();
      var ConvexPolyhedron_vToP = new Vec3();
      var ConvexPolyhedron_vToPointInside = new Vec3();

      ConvexPolyhedron.prototype.pointIsInside = function (p) {
        var n = this.vertices.length,
            verts = this.vertices,
            faces = this.faces,
            normals = this.faceNormals;
        var positiveResult = null;
        var N = this.faces.length;
        var pointInside = ConvexPolyhedron_pointIsInside;
        this.getAveragePointLocal(pointInside);

        for (var i = 0; i < N; i++) {
          var numVertices = this.faces[i].length;
          var n = normals[i];
          var v = verts[faces[i][0]]; // We only need one point in the face
          // This dot product determines which side of the edge the point is

          var vToP = ConvexPolyhedron_vToP;
          p.vsub(v, vToP);
          var r1 = n.dot(vToP);
          var vToPointInside = ConvexPolyhedron_vToPointInside;
          pointInside.vsub(v, vToPointInside);
          var r2 = n.dot(vToPointInside);

          if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
            return false; // Encountered some other sign. Exit.
          } else {}
        } // If we got here, all dot products were of the same sign.


        return positiveResult ? 1 : -1;
      };
      /**
       * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
       * @static
       * @method project
       * @param {ConvexPolyhedron} hull
       * @param {Vec3} axis
       * @param {Vec3} pos
       * @param {Quaternion} quat
       * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
       */


      var project_worldVertex = new Vec3();
      var project_localAxis = new Vec3();
      var project_localOrigin = new Vec3();

      ConvexPolyhedron.project = function (hull, axis, pos, quat, result) {
        var n = hull.vertices.length,
            worldVertex = project_worldVertex,
            localAxis = project_localAxis,
            max = 0,
            min = 0,
            localOrigin = project_localOrigin,
            vs = hull.vertices;
        localOrigin.setZero(); // Transform the axis to local

        Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
        Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
        var add = localOrigin.dot(localAxis);
        min = max = vs[0].dot(localAxis);

        for (var i = 1; i < n; i++) {
          var val = vs[i].dot(localAxis);

          if (val > max) {
            max = val;
          }

          if (val < min) {
            min = val;
          }
        }

        min -= add;
        max -= add;

        if (min > max) {
          // Inconsistent - swap
          var temp = min;
          min = max;
          max = temp;
        } // Output


        result[0] = max;
        result[1] = min;
      };
    }, {
      "../math/Quaternion": 30,
      "../math/Transform": 31,
      "../math/Vec3": 32,
      "./Shape": 45
    }],
    41: [function (_dereq_, module, exports) {
      module.exports = Cylinder;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

      var CMath = _dereq_('../math/CMath');
      /**
       * @class Cylinder
       * @constructor
       * @extends ConvexPolyhedron
       * @author schteppe / https://github.com/schteppe
       * @param {Number} radiusTop
       * @param {Number} radiusBottom
       * @param {Number} height
       * @param {Number} numSegments The number of segments to build the cylinder out of
       */


      function Cylinder(radiusTop, radiusBottom, height, numSegments, isDirY) {
        if (isDirY) {
          var N = numSegments,
              cos = CMath.cos,
              sin = CMath.sin;
          var halfH = height / 2;
          var vertices = [];
          var indices = [];
          var tf = [0];
          var bf = [1];
          var axes = [];
          var theta = Math.PI * 2 / N;

          for (var i = 0; i < N; i++) {
            vertices.push(new Vec3(radiusTop * cos(theta * i), halfH, radiusTop * sin(theta * i)));
            vertices.push(new Vec3(radiusTop * cos(theta * i), -halfH, radiusTop * sin(theta * i)));

            if (i < N - 1) {
              indices.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
              tf.push(2 * i + 2);
              bf.push(2 * i + 3);
            } else {
              indices.push([0, 1, 2 * i + 1, 2 * i]);
            }

            if (N % 2 === 1 || i < N / 2) axes.push(new Vec3(cos(theta * (i + 0.5)), 0, sin(theta * (i + 0.5))));
          }

          indices.push(bf);
          var temp = [];

          for (var i = 0; i < tf.length; i++) {
            temp.push(tf[tf.length - i - 1]);
          }

          indices.push(temp);
          axes.push(new Vec3(0, 1, 0));
          ConvexPolyhedron.call(this, vertices, indices, axes);
          return;
        }

        var N = numSegments,
            verts = [],
            axes = [],
            faces = [],
            bottomface = [],
            topface = [],
            cos = CMath.cos,
            sin = CMath.sin; // First bottom point

        verts.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), -height * 0.5));
        bottomface.push(0); // First top point

        verts.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), height * 0.5));
        topface.push(1);

        for (var i = 0; i < N; i++) {
          var theta = 2 * Math.PI / N * (i + 1);
          var thetaN = 2 * Math.PI / N * (i + 0.5);

          if (i < N - 1) {
            // Bottom
            verts.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), -height * 0.5));
            bottomface.push(2 * i + 2); // Top

            verts.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), height * 0.5));
            topface.push(2 * i + 3); // Face

            faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
          } else {
            faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect
          } // Axis: we can cut off half of them if we have even number of segments


          if (N % 2 === 1 || i < N / 2) {
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
          }
        }

        faces.push(topface);
        axes.push(new Vec3(0, 0, 1)); // Reorder bottom face

        var temp = [];

        for (var i = 0; i < bottomface.length; i++) {
          temp.push(bottomface[bottomface.length - i - 1]);
        }

        faces.push(temp);
        ConvexPolyhedron.call(this, verts, faces, axes);
      }

      Cylinder.prototype = new ConvexPolyhedron();
    }, {
      "../math/CMath": 27,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "./ConvexPolyhedron": 40,
      "./Shape": 45
    }],
    42: [function (_dereq_, module, exports) {
      var Shape = _dereq_('./Shape');

      var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

      var Vec3 = _dereq_('../math/Vec3');

      var Utils = _dereq_('../utils/Utils');

      module.exports = Heightfield;
      /**
       * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
       * @class Heightfield
       * @extends Shape
       * @constructor
       * @param {Array} data An array of Y values that will be used to construct the terrain.
       * @param {object} options
       * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
       * @param {Number} [options.maxValue] Maximum value.
       * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
       * @todo Should be possible to use along all axes, not just y
       * @todo should be possible to scale along all axes
       *
       * @example
       *     // Generate some height data (y-values).
       *     var data = [];
       *     for(var i = 0; i < 1000; i++){
       *         var y = 0.5 * Math.cos(0.2 * i);
       *         data.push(y);
       *     }
       *
       *     // Create the heightfield shape
       *     var heightfieldShape = new Heightfield(data, {
       *         elementSize: 1 // Distance between the data points in X and Y directions
       *     });
       *     var heightfieldBody = new Body();
       *     heightfieldBody.addShape(heightfieldShape);
       *     world.addBody(heightfieldBody);
       */

      function Heightfield(data, options) {
        options = Utils.defaults(options, {
          maxValue: null,
          minValue: null,
          elementSize: 1
        });
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         * @property {array} data
         */

        this.data = data;
        /**
         * Max value of the data
         * @property {number} maxValue
         */

        this.maxValue = options.maxValue;
        /**
         * Max value of the data
         * @property {number} minValue
         */

        this.minValue = options.minValue;
        /**
         * The width of each element
         * @property {number} elementSize
         * @todo elementSizeX and Y
         */

        this.elementSize = options.elementSize;

        if (options.minValue === null) {
          this.updateMinValue();
        }

        if (options.maxValue === null) {
          this.updateMaxValue();
        }

        this.cacheEnabled = true;
        Shape.call(this, {
          type: Shape.types.HEIGHTFIELD
        });
        this.pillarConvex = new ConvexPolyhedron();
        this.pillarOffset = new Vec3();
        this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
        // for example:
        // _cachedPillars["0_2_1"]

        this._cachedPillars = {};
      }

      Heightfield.prototype = new Shape();
      /**
       * Call whenever you change the data array.
       * @method update
       */

      Heightfield.prototype.update = function () {
        this._cachedPillars = {};
      };
      /**
       * Update the .minValue property
       * @method updateMinValue
       */


      Heightfield.prototype.updateMinValue = function () {
        var data = this.data;
        var minValue = data[0][0];

        for (var i = 0; i !== data.length; i++) {
          for (var j = 0; j !== data[i].length; j++) {
            var v = data[i][j];

            if (v < minValue) {
              minValue = v;
            }
          }
        }

        this.minValue = minValue;
      };
      /**
       * Update the .maxValue property
       * @method updateMaxValue
       */


      Heightfield.prototype.updateMaxValue = function () {
        var data = this.data;
        var maxValue = data[0][0];

        for (var i = 0; i !== data.length; i++) {
          for (var j = 0; j !== data[i].length; j++) {
            var v = data[i][j];

            if (v > maxValue) {
              maxValue = v;
            }
          }
        }

        this.maxValue = maxValue;
      };
      /**
       * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
       * @method setHeightValueAtIndex
       * @param {integer} xi
       * @param {integer} yi
       * @param {number} value
       */


      Heightfield.prototype.setHeightValueAtIndex = function (xi, yi, value) {
        var data = this.data;
        data[xi][yi] = value; // Invalidate cache

        this.clearCachedConvexTrianglePillar(xi, yi, false);

        if (xi > 0) {
          this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
          this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
        }

        if (yi > 0) {
          this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
          this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
        }

        if (yi > 0 && xi > 0) {
          this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
        }
      };
      /**
       * Get max/min in a rectangle in the matrix data
       * @method getRectMinMax
       * @param  {integer} iMinX
       * @param  {integer} iMinY
       * @param  {integer} iMaxX
       * @param  {integer} iMaxY
       * @param  {array} [result] An array to store the results in.
       * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
       */


      Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
        result = result || []; // Get max and min of the data

        var data = this.data,
            max = this.minValue; // Set first value

        for (var i = iMinX; i <= iMaxX; i++) {
          for (var j = iMinY; j <= iMaxY; j++) {
            var height = data[i][j];

            if (height > max) {
              max = height;
            }
          }
        }

        result[0] = this.minValue;
        result[1] = max;
      };
      /**
       * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
       * @method getIndexOfPosition
       * @param  {number} x
       * @param  {number} y
       * @param  {array} result Two-element array
       * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
       * @return {boolean}
       */


      Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {
        // Get the index of the data points to test against
        var w = this.elementSize;
        var data = this.data;
        var xi = Math.floor(x / w);
        var yi = Math.floor(y / w);
        result[0] = xi;
        result[1] = yi;

        if (clamp) {
          // Clamp index to edges
          if (xi < 0) {
            xi = 0;
          }

          if (yi < 0) {
            yi = 0;
          }

          if (xi >= data.length - 1) {
            xi = data.length - 1;
          }

          if (yi >= data[0].length - 1) {
            yi = data[0].length - 1;
          }
        } // Bail out if we are out of the terrain


        if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
          return false;
        }

        return true;
      };

      var getHeightAt_idx = [];
      var getHeightAt_weights = new Vec3();
      var getHeightAt_a = new Vec3();
      var getHeightAt_b = new Vec3();
      var getHeightAt_c = new Vec3();

      Heightfield.prototype.getTriangleAt = function (x, y, edgeClamp, a, b, c) {
        var idx = getHeightAt_idx;
        this.getIndexOfPosition(x, y, idx, edgeClamp);
        var xi = idx[0];
        var yi = idx[1];
        var data = this.data;

        if (edgeClamp) {
          xi = Math.min(data.length - 2, Math.max(0, xi));
          yi = Math.min(data[0].length - 2, Math.max(0, yi));
        }

        var elementSize = this.elementSize;
        var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
        var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
        var upper = lowerDist2 > upperDist2;
        this.getTriangle(xi, yi, upper, a, b, c);
        return upper;
      };

      var getNormalAt_a = new Vec3();
      var getNormalAt_b = new Vec3();
      var getNormalAt_c = new Vec3();
      var getNormalAt_e0 = new Vec3();
      var getNormalAt_e1 = new Vec3();

      Heightfield.prototype.getNormalAt = function (x, y, edgeClamp, result) {
        var a = getNormalAt_a;
        var b = getNormalAt_b;
        var c = getNormalAt_c;
        var e0 = getNormalAt_e0;
        var e1 = getNormalAt_e1;
        this.getTriangleAt(x, y, edgeClamp, a, b, c);
        b.vsub(a, e0);
        c.vsub(a, e1);
        e0.cross(e1, result);
        result.normalize();
      };
      /**
       * Get an AABB of a square in the heightfield
       * @param  {number} xi
       * @param  {number} yi
       * @param  {AABB} result
       */


      Heightfield.prototype.getAabbAtIndex = function (xi, yi, result) {
        var data = this.data;
        var elementSize = this.elementSize;
        result.lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
        result.upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
      };
      /**
       * Get the height in the heightfield at a given position
       * @param  {number} x
       * @param  {number} y
       * @param  {boolean} edgeClamp
       * @return {number}
       */


      Heightfield.prototype.getHeightAt = function (x, y, edgeClamp) {
        var data = this.data;
        var a = getHeightAt_a;
        var b = getHeightAt_b;
        var c = getHeightAt_c;
        var idx = getHeightAt_idx;
        this.getIndexOfPosition(x, y, idx, edgeClamp);
        var xi = idx[0];
        var yi = idx[1];

        if (edgeClamp) {
          xi = Math.min(data.length - 2, Math.max(0, xi));
          yi = Math.min(data[0].length - 2, Math.max(0, yi));
        }

        var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
        barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
        var w = getHeightAt_weights;

        if (upper) {
          // Top triangle verts
          return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
        } else {
          // Top triangle verts
          return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
        }
      }; // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system


      function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
        result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.z = 1 - result.x - result.y;
      }

      Heightfield.prototype.getCacheConvexTrianglePillarKey = function (xi, yi, getUpperTriangle) {
        return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
      };

      Heightfield.prototype.getCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
      };

      Heightfield.prototype.setCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle, convex, offset) {
        this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
          convex: convex,
          offset: offset
        };
      };

      Heightfield.prototype.clearCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
      };
      /**
       * Get a triangle from the heightfield
       * @param  {number} xi
       * @param  {number} yi
       * @param  {boolean} upper
       * @param  {Vec3} a
       * @param  {Vec3} b
       * @param  {Vec3} c
       */


      Heightfield.prototype.getTriangle = function (xi, yi, upper, a, b, c) {
        var data = this.data;
        var elementSize = this.elementSize;

        if (upper) {
          // Top triangle verts
          a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
          b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
          c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
        } else {
          // Top triangle verts
          a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
          b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
          c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
        }
      };
      /**
       * Get a triangle in the terrain in the form of a triangular convex shape.
       * @method getConvexTrianglePillar
       * @param  {integer} i
       * @param  {integer} j
       * @param  {boolean} getUpperTriangle
       */


      Heightfield.prototype.getConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
        var result = this.pillarConvex;
        var offsetResult = this.pillarOffset;

        if (this.cacheEnabled) {
          var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);

          if (data) {
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
          }

          result = new ConvexPolyhedron();
          offsetResult = new Vec3();
          this.pillarConvex = result;
          this.pillarOffset = offsetResult;
        }

        var data = this.data;
        var elementSize = this.elementSize;
        var faces = result.faces; // Reuse verts if possible

        result.vertices.length = 6;

        for (var i = 0; i < 6; i++) {
          if (!result.vertices[i]) {
            result.vertices[i] = new Vec3();
          }
        } // Reuse faces if possible


        faces.length = 5;

        for (var i = 0; i < 5; i++) {
          if (!faces[i]) {
            faces[i] = [];
          }
        }

        var verts = result.vertices;
        var h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;

        if (!getUpperTriangle) {
          // Center of the triangle pillar - all polygons are given relative to this one
          offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
          (yi + 0.25) * elementSize, h // vertical center
          ); // Top triangle verts

          verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
          verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
          verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts

          verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -h - 1);
          verts[4].set(0.75 * elementSize, -0.25 * elementSize, -h - 1);
          verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -h - 1); // top triangle

          faces[0][0] = 0;
          faces[0][1] = 1;
          faces[0][2] = 2; // bottom triangle

          faces[1][0] = 5;
          faces[1][1] = 4;
          faces[1][2] = 3; // -x facing quad

          faces[2][0] = 0;
          faces[2][1] = 2;
          faces[2][2] = 5;
          faces[2][3] = 3; // -y facing quad

          faces[3][0] = 1;
          faces[3][1] = 0;
          faces[3][2] = 3;
          faces[3][3] = 4; // +xy facing quad

          faces[4][0] = 4;
          faces[4][1] = 5;
          faces[4][2] = 2;
          faces[4][3] = 1;
        } else {
          // Center of the triangle pillar - all polygons are given relative to this one
          offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
          (yi + 0.75) * elementSize, h // vertical center
          ); // Top triangle verts

          verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
          verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
          verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts

          verts[3].set(0.25 * elementSize, 0.25 * elementSize, -h - 1);
          verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -h - 1);
          verts[5].set(0.25 * elementSize, -0.75 * elementSize, -h - 1); // Top triangle

          faces[0][0] = 0;
          faces[0][1] = 1;
          faces[0][2] = 2; // bottom triangle

          faces[1][0] = 5;
          faces[1][1] = 4;
          faces[1][2] = 3; // +x facing quad

          faces[2][0] = 2;
          faces[2][1] = 5;
          faces[2][2] = 3;
          faces[2][3] = 0; // +y facing quad

          faces[3][0] = 3;
          faces[3][1] = 4;
          faces[3][2] = 1;
          faces[3][3] = 0; // -xy facing quad

          faces[4][0] = 1;
          faces[4][1] = 4;
          faces[4][2] = 5;
          faces[4][3] = 2;
        }

        result.computeNormals();
        result.computeEdges();
        result.updateBoundingSphereRadius();
        this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
      };

      Heightfield.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        target.set(0, 0, 0);
        return target;
      };

      Heightfield.prototype.volume = function () {
        return Number.MAX_VALUE; // The terrain is infinite
      };

      Heightfield.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // TODO: do it properly
        min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      };

      Heightfield.prototype.updateBoundingSphereRadius = function () {
        // Use the bounding box of the min/max values
        var data = this.data,
            s = this.elementSize;
        this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
      };
      /**
       * Sets the height values from an image. Currently only supported in browser.
       * @method setHeightsFromImage
       * @param {Image} image
       * @param {Vec3} scale
       */


      Heightfield.prototype.setHeightsFromImage = function (image, scale) {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0);
        var imageData = context.getImageData(0, 0, image.width, image.height);
        var matrix = this.data;
        matrix.length = 0;
        this.elementSize = Math.abs(scale.x) / imageData.width;

        for (var i = 0; i < imageData.height; i++) {
          var row = [];

          for (var j = 0; j < imageData.width; j++) {
            var a = imageData.data[(i * imageData.height + j) * 4];
            var b = imageData.data[(i * imageData.height + j) * 4 + 1];
            var c = imageData.data[(i * imageData.height + j) * 4 + 2];
            var height = (a + b + c) / 4 / 255 * scale.z;

            if (scale.x < 0) {
              row.push(height);
            } else {
              row.unshift(height);
            }
          }

          if (scale.y < 0) {
            matrix.unshift(row);
          } else {
            matrix.push(row);
          }
        }

        this.updateMaxValue();
        this.updateMinValue();
        this.update();
      };
    }, {
      "../math/Vec3": 32,
      "../utils/Utils": 55,
      "./ConvexPolyhedron": 40,
      "./Shape": 45
    }],
    43: [function (_dereq_, module, exports) {
      module.exports = Particle;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Particle shape.
       * @class Particle
       * @constructor
       * @author schteppe
       * @extends Shape
       */


      function Particle() {
        Shape.call(this, {
          type: Shape.types.PARTICLE
        });
      }

      Particle.prototype = new Shape();
      Particle.prototype.constructor = Particle;
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3}
       */

      Particle.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        target.set(0, 0, 0);
        return target;
      };

      Particle.prototype.volume = function () {
        return 0;
      };

      Particle.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = 0;
      };

      Particle.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // Get each axis max
        min.copy(pos);
        max.copy(pos);
      };
    }, {
      "../math/Vec3": 32,
      "./Shape": 45
    }],
    44: [function (_dereq_, module, exports) {
      module.exports = Plane;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
       * @class Plane
       * @constructor
       * @extends Shape
       * @author schteppe
       */


      function Plane() {
        Shape.call(this, {
          type: Shape.types.PLANE
        }); // World oriented normal

        this.worldNormal = new Vec3();
        this.worldNormalNeedsUpdate = true;
        this.boundingSphereRadius = Number.MAX_VALUE;
      }

      Plane.prototype = new Shape();
      Plane.prototype.constructor = Plane;

      Plane.prototype.computeWorldNormal = function (quat) {
        var n = this.worldNormal;
        n.set(0, 0, 1);
        quat.vmult(n, n);
        this.worldNormalNeedsUpdate = false;
      };

      Plane.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        return target;
      };

      Plane.prototype.volume = function () {
        return Number.MAX_VALUE; // The plane is infinite...
      };

      var tempNormal = new Vec3();

      Plane.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        // The plane AABB is infinite, except if the normal is pointing along any axis
        tempNormal.set(0, 0, 1); // Default plane normal is z

        quat.vmult(tempNormal, tempNormal);
        var maxVal = Number.MAX_VALUE;
        min.set(-maxVal, -maxVal, -maxVal);
        max.set(maxVal, maxVal, maxVal);

        if (tempNormal.x === 1) {
          max.x = pos.x;
        }

        if (tempNormal.y === 1) {
          max.y = pos.y;
        }

        if (tempNormal.z === 1) {
          max.z = pos.z;
        }

        if (tempNormal.x === -1) {
          min.x = pos.x;
        }

        if (tempNormal.y === -1) {
          min.y = pos.y;
        }

        if (tempNormal.z === -1) {
          min.z = pos.z;
        }
      };

      Plane.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = Number.MAX_VALUE;
      };
    }, {
      "../math/Vec3": 32,
      "./Shape": 45
    }],
    45: [function (_dereq_, module, exports) {
      module.exports = Shape;

      var EventTarget = _dereq_('../utils/EventTarget');

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Material = _dereq_('../material/Material');
      /**
       * Base class for shapes
       * @class Shape
       * @constructor
       * @param {object} [options]
       * @param {number} [options.collisionFilterGroup=1]
       * @param {number} [options.collisionFilterMask=-1]
       * @param {number} [options.collisionResponse=true]
       * @param {number} [options.material=null]
       * @author schteppe
       */


      function Shape(options) {
        options = options || {};
        EventTarget.apply(this);
        /**
         * Identifyer of the Shape.
         * @property {number} id
         */

        this.id = Shape.idCounter++;
        /**
         * The type of this shape. Must be set to an int > 0 by subclasses.
         * @property type
         * @type {Number}
         * @see Shape.types
         */

        this.type = options.type || 0;
        /**
         * The local bounding sphere radius of this shape.
         * @property {Number} boundingSphereRadius
         */

        this.boundingSphereRadius = 0;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
         * @property {boolean} collisionResponse
         */

        this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
        /**
         * @property {Number} collisionFilterGroup
         */

        this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
        /**
         * @property {Number} collisionFilterMask
         */

        this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
        /**
         * @property {Material} material
         */

        this.material = options.material ? options.material : null;
        /**
         * @property {Body} body
         */

        this.body = null;
      }

      Shape.prototype = new EventTarget();
      Shape.prototype.constructor = Shape;
      /**
       * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
       * @method updateBoundingSphereRadius
       */

      Shape.prototype.updateBoundingSphereRadius = function () {
        throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
      };
      /**
       * Get the volume of this shape
       * @method volume
       * @return {Number}
       */


      Shape.prototype.volume = function () {
        throw "volume() not implemented for shape type " + this.type;
      };
      /**
       * Calculates the inertia in the local frame for this shape.
       * @method calculateLocalInertia
       * @param {Number} mass
       * @param {Vec3} target
       * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
       */


      Shape.prototype.calculateLocalInertia = function (mass, target) {
        throw "calculateLocalInertia() not implemented for shape type " + this.type;
      };

      Shape.idCounter = 0;
      /**
       * The available shape types.
       * @static
       * @property types
       * @type {Object}
       */

      Shape.types = {
        SPHERE: 1,
        PLANE: 2,
        BOX: 4,
        COMPOUND: 8,
        CONVEXPOLYHEDRON: 16,
        HEIGHTFIELD: 32,
        PARTICLE: 64,
        CYLINDER: 128,
        TRIMESH: 256
      };
    }, {
      "../material/Material": 26,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../utils/EventTarget": 51,
      "./Shape": 45
    }],
    46: [function (_dereq_, module, exports) {
      module.exports = Sphere;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');
      /**
       * Spherical shape
       * @class Sphere
       * @constructor
       * @extends Shape
       * @param {Number} radius The radius of the sphere, a non-negative number.
       * @author schteppe / http://github.com/schteppe
       */


      function Sphere(radius) {
        Shape.call(this, {
          type: Shape.types.SPHERE
        });
        /**
         * @property {Number} radius
         */

        this.radius = radius !== undefined ? radius : 1.0;

        if (this.radius < 0) {
          throw new Error('The sphere radius cannot be negative.');
        }

        this.updateBoundingSphereRadius();
      }

      Sphere.prototype = new Shape();
      Sphere.prototype.constructor = Sphere;

      Sphere.prototype.calculateLocalInertia = function (mass, target) {
        target = target || new Vec3();
        var I = 2.0 * mass * this.radius * this.radius / 5.0;
        target.x = I;
        target.y = I;
        target.z = I;
        return target;
      };

      Sphere.prototype.volume = function () {
        return 4.0 * Math.PI * this.radius / 3.0;
      };

      Sphere.prototype.updateBoundingSphereRadius = function () {
        this.boundingSphereRadius = this.radius;
      };

      Sphere.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        var r = this.radius;
        var axes = ['x', 'y', 'z'];

        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          min[ax] = pos[ax] - r;
          max[ax] = pos[ax] + r;
        }
      };
    }, {
      "../math/Vec3": 32,
      "./Shape": 45
    }],
    47: [function (_dereq_, module, exports) {
      module.exports = Trimesh;

      var Shape = _dereq_('./Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Transform = _dereq_('../math/Transform');

      var AABB = _dereq_('../collision/AABB');

      var Octree = _dereq_('../utils/Octree');

      var CMath = _dereq_('../math/CMath');
      /**
       * @class Trimesh
       * @constructor
       * @param {array} vertices
       * @param {array} indices
       * @extends Shape
       * @example
       *     // How to make a mesh with a single triangle
       *     var vertices = [
       *         0, 0, 0, // vertex 0
       *         1, 0, 0, // vertex 1
       *         0, 1, 0  // vertex 2
       *     ];
       *     var indices = [
       *         0, 1, 2  // triangle 0
       *     ];
       *     var trimeshShape = new Trimesh(vertices, indices);
       */


      function Trimesh(vertices, indices) {
        Shape.call(this, {
          type: Shape.types.TRIMESH
        });
        /**
         * @property vertices
         * @type {Array}
         */

        this.vertices = new Float32Array(vertices);
        /**
         * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
         * @property indices
         * @type {Array}
         */

        this.indices = new Int16Array(indices);
        /**
         * The normals data.
         * @property normals
         * @type {Array}
         */

        this.normals = new Float32Array(indices.length);
        /**
         * The local AABB of the mesh.
         * @property aabb
         * @type {Array}
         */

        this.aabb = new AABB();
        /**
         * References to vertex pairs, making up all unique edges in the trimesh.
         * @property {array} edges
         */

        this.edges = null;
        /**
         * Local scaling of the mesh. Use .setScale() to set it.
         * @property {Vec3} scale
         */

        this.scale = new Vec3(1, 1, 1);
        /**
         * The indexed triangles. Use .updateTree() to update it.
         * @property {Octree} tree
         */

        this.tree = new Octree();
        this.updateEdges();
        this.updateNormals();
        this.updateAABB();
        this.updateBoundingSphereRadius();
        this.updateTree();
      }

      Trimesh.prototype = new Shape();
      Trimesh.prototype.constructor = Trimesh;
      var computeNormals_n = new Vec3();
      /**
       * @method updateTree
       */

      Trimesh.prototype.updateTree = function () {
        var tree = this.tree;
        tree.reset();
        tree.aabb.copy(this.aabb);
        var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

        tree.aabb.lowerBound.x *= 1 / scale.x;
        tree.aabb.lowerBound.y *= 1 / scale.y;
        tree.aabb.lowerBound.z *= 1 / scale.z;
        tree.aabb.upperBound.x *= 1 / scale.x;
        tree.aabb.upperBound.y *= 1 / scale.y;
        tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

        var triangleAABB = new AABB();
        var a = new Vec3();
        var b = new Vec3();
        var c = new Vec3();
        var points = [a, b, c];

        for (var i = 0; i < this.indices.length / 3; i++) {
          //this.getTriangleVertices(i, a, b, c);
          // Get unscaled triangle verts
          var i3 = i * 3;

          this._getUnscaledVertex(this.indices[i3], a);

          this._getUnscaledVertex(this.indices[i3 + 1], b);

          this._getUnscaledVertex(this.indices[i3 + 2], c);

          triangleAABB.setFromPoints(points);
          tree.insert(triangleAABB, i);
        }

        tree.removeEmptyNodes();
      };

      var unscaledAABB = new AABB();
      /**
       * Get triangles in a local AABB from the trimesh.
       * @method getTrianglesInAABB
       * @param  {AABB} aabb
       * @param  {array} result An array of integers, referencing the queried triangles.
       */

      Trimesh.prototype.getTrianglesInAABB = function (aabb, result) {
        unscaledAABB.copy(aabb); // Scale it to local

        var scale = this.scale;
        var isx = scale.x;
        var isy = scale.y;
        var isz = scale.z;
        var l = unscaledAABB.lowerBound;
        var u = unscaledAABB.upperBound;
        l.x /= isx;
        l.y /= isy;
        l.z /= isz;
        u.x /= isx;
        u.y /= isy;
        u.z /= isz;
        return this.tree.aabbQuery(unscaledAABB, result);
      };
      /**
       * @method setScale
       * @param {Vec3} scale
       */


      Trimesh.prototype.setScale = function (scale) {
        var wasUniform = this.scale.x === this.scale.y === this.scale.z;
        var isUniform = scale.x === scale.y === scale.z;

        if (!(wasUniform && isUniform)) {
          // Non-uniform scaling. Need to update normals.
          this.updateNormals();
        }

        this.scale.copy(scale);
        this.updateAABB();
        this.updateBoundingSphereRadius();
      };
      /**
       * Compute the normals of the faces. Will save in the .normals array.
       * @method updateNormals
       */


      Trimesh.prototype.updateNormals = function () {
        var n = computeNormals_n; // Generate normals

        var normals = this.normals;

        for (var i = 0; i < this.indices.length / 3; i++) {
          var i3 = i * 3;
          var a = this.indices[i3],
              b = this.indices[i3 + 1],
              c = this.indices[i3 + 2];
          this.getVertex(a, va);
          this.getVertex(b, vb);
          this.getVertex(c, vc);
          Trimesh.computeNormal(vb, va, vc, n);
          normals[i3] = n.x;
          normals[i3 + 1] = n.y;
          normals[i3 + 2] = n.z;
        }
      };
      /**
       * Update the .edges property
       * @method updateEdges
       */


      Trimesh.prototype.updateEdges = function () {
        var edges = {};

        var add = function add(indexA, indexB) {
          var key = a < b ? a + '_' + b : b + '_' + a;
          edges[key] = true;
        };

        for (var i = 0; i < this.indices.length / 3; i++) {
          var i3 = i * 3;
          var a = this.indices[i3],
              b = this.indices[i3 + 1],
              c = this.indices[i3 + 2];
          add(a, b);
          add(b, c);
          add(c, a);
        }

        var keys = Object.keys(edges);
        this.edges = new Int16Array(keys.length * 2);

        for (var i = 0; i < keys.length; i++) {
          var indices = keys[i].split('_');
          this.edges[2 * i] = parseInt(indices[0], 10);
          this.edges[2 * i + 1] = parseInt(indices[1], 10);
        }
      };
      /**
       * Get an edge vertex
       * @method getEdgeVertex
       * @param  {number} edgeIndex
       * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
       * @param  {Vec3} vertexStore Where to store the result
       */


      Trimesh.prototype.getEdgeVertex = function (edgeIndex, firstOrSecond, vertexStore) {
        var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
        this.getVertex(vertexIndex, vertexStore);
      };

      var getEdgeVector_va = new Vec3();
      var getEdgeVector_vb = new Vec3();
      /**
       * Get a vector along an edge.
       * @method getEdgeVector
       * @param  {number} edgeIndex
       * @param  {Vec3} vectorStore
       */

      Trimesh.prototype.getEdgeVector = function (edgeIndex, vectorStore) {
        var va = getEdgeVector_va;
        var vb = getEdgeVector_vb;
        this.getEdgeVertex(edgeIndex, 0, va);
        this.getEdgeVertex(edgeIndex, 1, vb);
        vb.vsub(va, vectorStore);
      };
      /**
       * Get face normal given 3 vertices
       * @static
       * @method computeNormal
       * @param {Vec3} va
       * @param {Vec3} vb
       * @param {Vec3} vc
       * @param {Vec3} target
       */


      var cb = new Vec3();
      var ab = new Vec3();

      Trimesh.computeNormal = function (va, vb, vc, target) {
        vb.vsub(va, ab);
        vc.vsub(vb, cb);
        cb.cross(ab, target);

        if (!target.isZero()) {
          target.normalize();
        }
      };

      var va = new Vec3();
      var vb = new Vec3();
      var vc = new Vec3();
      /**
       * Get vertex i.
       * @method getVertex
       * @param  {number} i
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */

      Trimesh.prototype.getVertex = function (i, out) {
        var scale = this.scale;

        this._getUnscaledVertex(i, out);

        out.x *= scale.x;
        out.y *= scale.y;
        out.z *= scale.z;
        return out;
      };
      /**
       * Get raw vertex i
       * @private
       * @method _getUnscaledVertex
       * @param  {number} i
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */


      Trimesh.prototype._getUnscaledVertex = function (i, out) {
        var i3 = i * 3;
        var vertices = this.vertices;
        return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
      };
      /**
       * Get a vertex from the trimesh,transformed by the given position and quaternion.
       * @method getWorldVertex
       * @param  {number} i
       * @param  {Vec3} pos
       * @param  {Quaternion} quat
       * @param  {Vec3} out
       * @return {Vec3} The "out" vector object
       */


      Trimesh.prototype.getWorldVertex = function (i, pos, quat, out) {
        this.getVertex(i, out);
        Transform.pointToWorldFrame(pos, quat, out, out);
        return out;
      };
      /**
       * Get the three vertices for triangle i.
       * @method getTriangleVertices
       * @param  {number} i
       * @param  {Vec3} a
       * @param  {Vec3} b
       * @param  {Vec3} c
       */


      Trimesh.prototype.getTriangleVertices = function (i, a, b, c) {
        var i3 = i * 3;
        this.getVertex(this.indices[i3], a);
        this.getVertex(this.indices[i3 + 1], b);
        this.getVertex(this.indices[i3 + 2], c);
      };
      /**
       * Compute the normal of triangle i.
       * @method getNormal
       * @param  {Number} i
       * @param  {Vec3} target
       * @return {Vec3} The "target" vector object
       */


      Trimesh.prototype.getNormal = function (i, target) {
        var i3 = i * 3;
        return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
      };

      var cli_aabb = new AABB();
      /**
       * @method calculateLocalInertia
       * @param  {Number} mass
       * @param  {Vec3} target
       * @return {Vec3} The "target" vector object
       */

      Trimesh.prototype.calculateLocalInertia = function (mass, target) {
        // Approximate with box inertia
        // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
        this.computeLocalAABB(cli_aabb);
        var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
            y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
            z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
        return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
      };

      var computeLocalAABB_worldVert = new Vec3();
      /**
       * Compute the local AABB for the trimesh
       * @method computeLocalAABB
       * @param  {AABB} aabb
       */

      Trimesh.prototype.computeLocalAABB = function (aabb) {
        var l = aabb.lowerBound,
            u = aabb.upperBound,
            n = this.vertices.length,
            vertices = this.vertices,
            v = computeLocalAABB_worldVert;
        this.getVertex(0, v);
        l.copy(v);
        u.copy(v);

        for (var i = 0; i !== n; i++) {
          this.getVertex(i, v);

          if (v.x < l.x) {
            l.x = v.x;
          } else if (v.x > u.x) {
            u.x = v.x;
          }

          if (v.y < l.y) {
            l.y = v.y;
          } else if (v.y > u.y) {
            u.y = v.y;
          }

          if (v.z < l.z) {
            l.z = v.z;
          } else if (v.z > u.z) {
            u.z = v.z;
          }
        }
      };
      /**
       * Update the .aabb property
       * @method updateAABB
       */


      Trimesh.prototype.updateAABB = function () {
        this.computeLocalAABB(this.aabb);
      };
      /**
       * Will update the .boundingSphereRadius property
       * @method updateBoundingSphereRadius
       */


      Trimesh.prototype.updateBoundingSphereRadius = function () {
        // Assume points are distributed with local (0,0,0) as center
        var max2 = 0;
        var vertices = this.vertices;
        var v = new Vec3();

        for (var i = 0, N = vertices.length / 3; i !== N; i++) {
          this.getVertex(i, v);
          var norm2 = v.norm2();

          if (norm2 > max2) {
            max2 = norm2;
          }
        }

        this.boundingSphereRadius = Math.sqrt(max2);
      };

      var tempWorldVertex = new Vec3();
      var calculateWorldAABB_frame = new Transform();
      var calculateWorldAABB_aabb = new AABB();
      /**
       * @method calculateWorldAABB
       * @param {Vec3}        pos
       * @param {Quaternion}  quat
       * @param {Vec3}        min
       * @param {Vec3}        max
       */

      Trimesh.prototype.calculateWorldAABB = function (pos, quat, min, max) {
        /*
        var n = this.vertices.length / 3,
            verts = this.vertices;
        var minx,miny,minz,maxx,maxy,maxz;
          var v = tempWorldVertex;
        for(var i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
              if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
              if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
        // Faster approximation using local AABB
        var frame = calculateWorldAABB_frame;
        var result = calculateWorldAABB_aabb;
        frame.position = pos;
        frame.quaternion = quat;
        this.aabb.toWorldFrame(frame, result);
        min.copy(result.lowerBound);
        max.copy(result.upperBound);
      };
      /**
       * Get approximate volume
       * @method volume
       * @return {Number}
       */


      Trimesh.prototype.volume = function () {
        return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
      };
      /**
       * Create a Trimesh instance, shaped as a torus.
       * @static
       * @method createTorus
       * @param  {number} [radius=1]
       * @param  {number} [tube=0.5]
       * @param  {number} [radialSegments=8]
       * @param  {number} [tubularSegments=6]
       * @param  {number} [arc=6.283185307179586]
       * @return {Trimesh} A torus
       */


      Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
        radius = radius || 1;
        tube = tube || 0.5;
        radialSegments = radialSegments || 8;
        tubularSegments = tubularSegments || 6;
        arc = arc || Math.PI * 2;
        var vertices = [];
        var indices = [];

        for (var j = 0; j <= radialSegments; j++) {
          for (var i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;
            var x = (radius + tube * CMath.cos(v)) * CMath.cos(u);
            var y = (radius + tube * CMath.cos(v)) * CMath.sin(u);
            var z = tube * CMath.sin(v);
            vertices.push(x, y, z);
          }
        }

        for (var j = 1; j <= radialSegments; j++) {
          for (var i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1;
            var b = (tubularSegments + 1) * (j - 1) + i - 1;
            var c = (tubularSegments + 1) * (j - 1) + i;
            var d = (tubularSegments + 1) * j + i;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }

        return new Trimesh(vertices, indices);
      };
    }, {
      "../collision/AABB": 3,
      "../math/CMath": 27,
      "../math/Quaternion": 30,
      "../math/Transform": 31,
      "../math/Vec3": 32,
      "../utils/Octree": 52,
      "./Shape": 45
    }],
    48: [function (_dereq_, module, exports) {
      module.exports = GSSolver;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('./Solver');
      /**
       * Constraint equation Gauss-Seidel solver.
       * @class GSSolver
       * @constructor
       * @todo The spook parameters should be specified for each constraint, not globally.
       * @author schteppe / https://github.com/schteppe
       * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
       * @extends Solver
       */


      function GSSolver() {
        Solver.call(this);
        /**
         * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
         * @property iterations
         * @type {Number}
         * @todo write more about solver and iterations in the wiki
         */

        this.iterations = 10;
        /**
         * When tolerance is reached, the system is assumed to be converged.
         * @property tolerance
         * @type {Number}
         */

        this.tolerance = 1e-7;
      }

      GSSolver.prototype = new Solver();
      var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.

      var GSSolver_solve_invCs = [];
      var GSSolver_solve_Bs = [];

      GSSolver.prototype.solve = function (dt, world) {
        var iter = 0,
            maxIter = this.iterations,
            tolSquared = this.tolerance * this.tolerance,
            equations = this.equations,
            Neq = equations.length,
            bodies = world.bodies,
            Nbodies = bodies.length,
            h = dt,
            q,
            B,
            invC,
            deltalambda,
            deltalambdaTot,
            GWlambda,
            lambdaj; // Update solve mass

        if (Neq !== 0) {
          for (var i = 0; i !== Nbodies; i++) {
            bodies[i].updateSolveMassProperties();
          }
        } // Things that does not change during iteration can be computed once


        var invCs = GSSolver_solve_invCs,
            Bs = GSSolver_solve_Bs,
            lambda = GSSolver_solve_lambda;
        invCs.length = Neq;
        Bs.length = Neq;
        lambda.length = Neq;

        for (var i = 0; i !== Neq; i++) {
          var c = equations[i];
          lambda[i] = 0.0;
          Bs[i] = c.computeB(h);
          invCs[i] = 1.0 / c.computeC();
        }

        if (Neq !== 0) {
          // Reset vlambda
          for (var i = 0; i !== Nbodies; i++) {
            var b = bodies[i],
                vlambda = b.vlambda,
                wlambda = b.wlambda;
            vlambda.set(0, 0, 0);
            wlambda.set(0, 0, 0);
          } // Iterate over equations


          for (iter = 0; iter !== maxIter; iter++) {
            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for (var j = 0; j !== Neq; j++) {
              var c = equations[j]; // Compute iteration

              B = Bs[j];
              invC = invCs[j];
              lambdaj = lambda[j];
              GWlambda = c.computeGWlambda();
              deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

              if (lambdaj + deltalambda < c.minForce) {
                deltalambda = c.minForce - lambdaj;
              } else if (lambdaj + deltalambda > c.maxForce) {
                deltalambda = c.maxForce - lambdaj;
              }

              lambda[j] += deltalambda;
              deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

              c.addToWlambda(deltalambda);
            } // If the total error is small enough - stop iterate


            if (deltalambdaTot * deltalambdaTot < tolSquared) {
              break;
            }
          } // Add result to velocity


          for (var i = 0; i !== Nbodies; i++) {
            var b = bodies[i],
                v = b.velocity,
                w = b.angularVelocity;
            b.vlambda.vmul(b.linearFactor, b.vlambda);
            v.vadd(b.vlambda, v);
            b.wlambda.vmul(b.angularFactor, b.wlambda);
            w.vadd(b.wlambda, w);
          } // Set the .multiplier property of each equation


          var l = equations.length;
          var invDt = 1 / h;

          while (l--) {
            equations[l].multiplier = lambda[l] * invDt;
          }
        }

        return iter;
      };
    }, {
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "./Solver": 49
    }],
    49: [function (_dereq_, module, exports) {
      module.exports = Solver;
      /**
       * Constraint equation solver base class.
       * @class Solver
       * @constructor
       * @author schteppe / https://github.com/schteppe
       */

      function Solver() {
        /**
         * All equations to be solved
         * @property {Array} equations
         */
        this.equations = [];
      }
      /**
       * Should be implemented in subclasses!
       * @method solve
       * @param  {Number} dt
       * @param  {World} world
       */


      Solver.prototype.solve = function (dt, world) {
        // Should return the number of iterations done!
        return 0;
      };
      /**
       * Add an equation
       * @method addEquation
       * @param {Equation} eq
       */


      Solver.prototype.addEquation = function (eq) {
        if (eq.enabled) {
          this.equations.push(eq);
        }
      };
      /**
       * Remove an equation
       * @method removeEquation
       * @param {Equation} eq
       */


      Solver.prototype.removeEquation = function (eq) {
        var eqs = this.equations;
        var i = eqs.indexOf(eq);

        if (i !== -1) {
          eqs.splice(i, 1);
        }
      };
      /**
       * Add all equations
       * @method removeAllEquations
       */


      Solver.prototype.removeAllEquations = function () {
        this.equations.length = 0;
      };
    }, {}],
    50: [function (_dereq_, module, exports) {
      module.exports = SplitSolver;

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('./Solver');

      var Body = _dereq_('../objects/Body');
      /**
       * Splits the equations into islands and solves them independently. Can improve performance.
       * @class SplitSolver
       * @constructor
       * @extends Solver
       * @param {Solver} subsolver
       */


      function SplitSolver(subsolver) {
        Solver.call(this);
        this.iterations = 10;
        this.tolerance = 1e-7;
        this.subsolver = subsolver;
        this.nodes = [];
        this.nodePool = []; // Create needed nodes, reuse if possible

        while (this.nodePool.length < 128) {
          this.nodePool.push(this.createNode());
        }
      }

      SplitSolver.prototype = new Solver(); // Returns the number of subsystems

      var SplitSolver_solve_nodes = []; // All allocated node objects

      var SplitSolver_solve_nodePool = []; // All allocated node objects

      var SplitSolver_solve_eqs = []; // Temp array

      var SplitSolver_solve_bds = []; // Temp array

      var SplitSolver_solve_dummyWorld = {
        bodies: []
      }; // Temp object

      var STATIC = Body.STATIC;

      function getUnvisitedNode(nodes) {
        var Nnodes = nodes.length;

        for (var i = 0; i !== Nnodes; i++) {
          var node = nodes[i];

          if (!node.visited && !(node.body.type & STATIC)) {
            return node;
          }
        }

        return false;
      }

      var queue = [];

      function bfs(root, visitFunc, bds, eqs) {
        queue.push(root);
        root.visited = true;
        visitFunc(root, bds, eqs);

        while (queue.length) {
          var node = queue.pop(); // Loop over unvisited child nodes

          var child;

          while (child = getUnvisitedNode(node.children)) {
            child.visited = true;
            visitFunc(child, bds, eqs);
            queue.push(child);
          }
        }
      }

      function visitFunc(node, bds, eqs) {
        bds.push(node.body);
        var Neqs = node.eqs.length;

        for (var i = 0; i !== Neqs; i++) {
          var eq = node.eqs[i];

          if (eqs.indexOf(eq) === -1) {
            eqs.push(eq);
          }
        }
      }

      SplitSolver.prototype.createNode = function () {
        return {
          body: null,
          children: [],
          eqs: [],
          visited: false
        };
      };
      /**
       * Solve the subsystems
       * @method solve
       * @param  {Number} dt
       * @param  {World} world
       */


      SplitSolver.prototype.solve = function (dt, world) {
        var nodes = SplitSolver_solve_nodes,
            nodePool = this.nodePool,
            bodies = world.bodies,
            equations = this.equations,
            Neq = equations.length,
            Nbodies = bodies.length,
            subsolver = this.subsolver; // Create needed nodes, reuse if possible

        while (nodePool.length < Nbodies) {
          nodePool.push(this.createNode());
        }

        nodes.length = Nbodies;

        for (var i = 0; i < Nbodies; i++) {
          nodes[i] = nodePool[i];
        } // Reset node values


        for (var i = 0; i !== Nbodies; i++) {
          var node = nodes[i];
          node.body = bodies[i];
          node.children.length = 0;
          node.eqs.length = 0;
          node.visited = false;
        }

        for (var k = 0; k !== Neq; k++) {
          var eq = equations[k],
              i = bodies.indexOf(eq.bi),
              j = bodies.indexOf(eq.bj),
              ni = nodes[i],
              nj = nodes[j];
          ni.children.push(nj);
          ni.eqs.push(eq);
          nj.children.push(ni);
          nj.eqs.push(eq);
        }

        var child,
            n = 0,
            eqs = SplitSolver_solve_eqs;
        subsolver.tolerance = this.tolerance;
        subsolver.iterations = this.iterations;
        var dummyWorld = SplitSolver_solve_dummyWorld;

        while (child = getUnvisitedNode(nodes)) {
          eqs.length = 0;
          dummyWorld.bodies.length = 0;
          bfs(child, visitFunc, dummyWorld.bodies, eqs);
          var Neqs = eqs.length;
          eqs = eqs.sort(sortById);

          for (var i = 0; i !== Neqs; i++) {
            subsolver.addEquation(eqs[i]);
          }

          var iter = subsolver.solve(dt, dummyWorld);
          subsolver.removeAllEquations();
          n++;
        }

        return n;
      };

      function sortById(a, b) {
        return b.id - a.id;
      }
    }, {
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../objects/Body": 33,
      "./Solver": 49
    }],
    51: [function (_dereq_, module, exports) {
      /**
       * Base class for objects that dispatches events.
       * @class EventTarget
       * @constructor
       */
      var EventTarget = function EventTarget() {};

      module.exports = EventTarget;
      EventTarget.prototype = {
        constructor: EventTarget,

        /**
         * Add an event listener
         * @method addEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {EventTarget} The self object, for chainability.
         */
        addEventListener: function addEventListener(type, listener) {
          if (this._listeners === undefined) {
            this._listeners = {};
          }

          var listeners = this._listeners;

          if (listeners[type] === undefined) {
            listeners[type] = [];
          }

          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }

          return this;
        },

        /**
         * Check if an event listener is added
         * @method hasEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {Boolean}
         */
        hasEventListener: function hasEventListener(type, listener) {
          if (this._listeners === undefined) {
            return false;
          }

          var listeners = this._listeners;

          if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
            return true;
          }

          return false;
        },

        /**
         * Check if any event listener of the given type is added
         * @method hasAnyEventListener
         * @param  {String} type
         * @return {Boolean}
         */
        hasAnyEventListener: function hasAnyEventListener(type) {
          if (this._listeners === undefined) {
            return false;
          }

          var listeners = this._listeners;
          return listeners[type] !== undefined;
        },

        /**
         * Remove an event listener
         * @method removeEventListener
         * @param  {String} type
         * @param  {Function} listener
         * @return {EventTarget} The self object, for chainability.
         */
        removeEventListener: function removeEventListener(type, listener) {
          if (this._listeners === undefined) {
            return this;
          }

          var listeners = this._listeners;

          if (listeners[type] === undefined) {
            return this;
          }

          var index = listeners[type].indexOf(listener);

          if (index !== -1) {
            listeners[type].splice(index, 1);
          }

          return this;
        },

        /**
         * Emit an event.
         * @method dispatchEvent
         * @param  {Object} event
         * @param  {String} event.type
         * @return {EventTarget} The self object, for chainability.
         */
        dispatchEvent: function dispatchEvent(event) {
          if (this._listeners === undefined) {
            return this;
          }

          var listeners = this._listeners;
          var listenerArray = listeners[event.type];

          if (listenerArray !== undefined) {
            event.target = this;

            for (var i = 0, l = listenerArray.length; i < l; i++) {
              listenerArray[i].call(this, event);
            }
          }

          return this;
        }
      };
    }, {}],
    52: [function (_dereq_, module, exports) {
      var AABB = _dereq_('../collision/AABB');

      var Vec3 = _dereq_('../math/Vec3');

      module.exports = Octree;
      /**
       * @class OctreeNode
       * @param {object} [options]
       * @param {Octree} [options.root]
       * @param {AABB} [options.aabb]
       */

      function OctreeNode(options) {
        options = options || {};
        /**
         * The root node
         * @property {OctreeNode} root
         */

        this.root = options.root || null;
        /**
         * Boundary of this node
         * @property {AABB} aabb
         */

        this.aabb = options.aabb ? options.aabb.clone() : new AABB();
        /**
         * Contained data at the current node level.
         * @property {Array} data
         */

        this.data = [];
        /**
         * Children to this node
         * @property {Array} children
         */

        this.children = [];
      }
      /**
       * @class Octree
       * @param {AABB} aabb The total AABB of the tree
       * @param {object} [options]
       * @param {number} [options.maxDepth=8]
       * @extends OctreeNode
       */


      function Octree(aabb, options) {
        options = options || {};
        options.root = null;
        options.aabb = aabb;
        OctreeNode.call(this, options);
        /**
         * Maximum subdivision depth
         * @property {number} maxDepth
         */

        this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;
      }

      Octree.prototype = new OctreeNode();

      OctreeNode.prototype.reset = function (aabb, options) {
        this.children.length = this.data.length = 0;
      };
      /**
       * Insert data into this node
       * @method insert
       * @param  {AABB} aabb
       * @param  {object} elementData
       * @return {boolean} True if successful, otherwise false
       */


      OctreeNode.prototype.insert = function (aabb, elementData, level) {
        var nodeData = this.data;
        level = level || 0; // Ignore objects that do not belong in this node

        if (!this.aabb.contains(aabb)) {
          return false; // object cannot be added
        }

        var children = this.children;

        if (level < (this.maxDepth || this.root.maxDepth)) {
          // Subdivide if there are no children yet
          var subdivided = false;

          if (!children.length) {
            this.subdivide();
            subdivided = true;
          } // add to whichever node will accept it


          for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)) {
              return true;
            }
          }

          if (subdivided) {
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
          }
        } // Too deep, or children didnt want it. add it in current node


        nodeData.push(elementData);
        return true;
      };

      var halfDiagonal = new Vec3();
      /**
       * Create 8 equally sized children nodes and put them in the .children array.
       * @method subdivide
       */

      OctreeNode.prototype.subdivide = function () {
        var aabb = this.aabb;
        var l = aabb.lowerBound;
        var u = aabb.upperBound;
        var children = this.children;
        children.push(new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 0, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 0, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 1, 0)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 1, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 1, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 0, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(1, 0, 1)
          })
        }), new OctreeNode({
          aabb: new AABB({
            lowerBound: new Vec3(0, 1, 0)
          })
        }));
        u.vsub(l, halfDiagonal);
        halfDiagonal.scale(0.5, halfDiagonal);
        var root = this.root || this;

        for (var i = 0; i !== 8; i++) {
          var child = children[i]; // Set current node as root

          child.root = root; // Compute bounds

          var lowerBound = child.aabb.lowerBound;
          lowerBound.x *= halfDiagonal.x;
          lowerBound.y *= halfDiagonal.y;
          lowerBound.z *= halfDiagonal.z;
          lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

          lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
        }
      };
      /**
       * Get all data, potentially within an AABB
       * @method aabbQuery
       * @param  {AABB} aabb
       * @param  {array} result
       * @return {array} The "result" object
       */


      OctreeNode.prototype.aabbQuery = function (aabb, result) {
        var nodeData = this.data; // abort if the range does not intersect this node
        // if (!this.aabb.overlaps(aabb)){
        //     return result;
        // }
        // Add objects at this level
        // Array.prototype.push.apply(result, nodeData);
        // Add child data
        // @todo unwrap recursion into a queue / loop, that's faster in JS

        var children = this.children; // for (var i = 0, N = this.children.length; i !== N; i++) {
        //     children[i].aabbQuery(aabb, result);
        // }

        var queue = [this];

        while (queue.length) {
          var node = queue.pop();

          if (node.aabb.overlaps(aabb)) {
            Array.prototype.push.apply(result, node.data);
          }

          Array.prototype.push.apply(queue, node.children);
        }

        return result;
      };

      var tmpAABB = new AABB();
      /**
       * Get all data, potentially intersected by a ray.
       * @method rayQuery
       * @param  {Ray} ray
       * @param  {Transform} treeTransform
       * @param  {array} result
       * @return {array} The "result" object
       */

      OctreeNode.prototype.rayQuery = function (ray, treeTransform, result) {
        // Use aabb query for now.
        // @todo implement real ray query which needs less lookups
        ray.getAABB(tmpAABB);
        tmpAABB.toLocalFrame(treeTransform, tmpAABB);
        this.aabbQuery(tmpAABB, result);
        return result;
      };
      /**
       * @method removeEmptyNodes
       */


      OctreeNode.prototype.removeEmptyNodes = function () {
        for (var i = this.children.length - 1; i >= 0; i--) {
          this.children[i].removeEmptyNodes();

          if (!this.children[i].children.length && !this.children[i].data.length) {
            this.children.splice(i, 1);
          }
        }
      };
    }, {
      "../collision/AABB": 3,
      "../math/Vec3": 32
    }],
    53: [function (_dereq_, module, exports) {
      module.exports = Pool;
      /**
       * For pooling objects that can be reused.
       * @class Pool
       * @constructor
       */

      function Pool() {
        /**
         * The pooled objects
         * @property {Array} objects
         */
        this.objects = [];
        /**
         * Constructor of the objects
         * @property {mixed} type
         */

        this.type = Object;
      }
      /**
       * Release an object after use
       * @method release
       * @param {Object} obj
       */


      Pool.prototype.release = function () {
        var Nargs = arguments.length;

        for (var i = 0; i !== Nargs; i++) {
          this.objects.push(arguments[i]);
        }

        return this;
      };
      /**
       * Get an object
       * @method get
       * @return {mixed}
       */


      Pool.prototype.get = function () {
        if (this.objects.length === 0) {
          return this.constructObject();
        } else {
          return this.objects.pop();
        }
      };
      /**
       * Construct an object. Should be implmented in each subclass.
       * @method constructObject
       * @return {mixed}
       */


      Pool.prototype.constructObject = function () {
        throw new Error("constructObject() not implemented in this Pool subclass yet!");
      };
      /**
       * @method resize
       * @param {number} size
       * @return {Pool} Self, for chaining
       */


      Pool.prototype.resize = function (size) {
        var objects = this.objects;

        while (objects.length > size) {
          objects.pop();
        }

        while (objects.length < size) {
          objects.push(this.constructObject());
        }

        return this;
      };
    }, {}],
    54: [function (_dereq_, module, exports) {
      module.exports = TupleDictionary;
      /**
       * @class TupleDictionary
       * @constructor
       */

      function TupleDictionary() {
        /**
         * The data storage
         * @property data
         * @type {Object}
         */
        this.data = {
          keys: []
        };
      }
      /**
       * @method get
       * @param  {Number} i
       * @param  {Number} j
       * @return {Object}
       */


      TupleDictionary.prototype.get = function (i, j) {
        if (i > j) {
          // swap
          var temp = j;
          j = i;
          i = temp;
        }

        return this.data[i + '-' + j];
      };
      /**
       * @method set
       * @param  {Number} i
       * @param  {Number} j
       * @param {Object} value
       */


      TupleDictionary.prototype.set = function (i, j, value) {
        if (i > j) {
          var temp = j;
          j = i;
          i = temp;
        }

        var key = i + '-' + j; // Check if key already exists

        if (!this.get(i, j)) {
          this.data.keys.push(key);
        }

        this.data[key] = value;
        return this.data[key];
      };
      /**
       * @method del
       * @param  {Number} i
       * @param  {Number} j
       * @returns {Boolean} is remove
       */


      TupleDictionary.prototype.del = function (i, j) {
        if (i > j) {
          var temp = j;
          j = i;
          i = temp;
        }

        var key = i + '-' + j;
        var index = this.data.keys.indexOf(key);

        if (index >= 0) {
          this.data.keys.splice(index, 1);
          delete this.data[key];
          return true;
        }

        return false;
      };
      /**
       * @method reset
       */


      TupleDictionary.prototype.reset = function () {
        this.data = {
          keys: []
        };
      };
      /**
       * @method getLength
       */


      TupleDictionary.prototype.getLength = function () {
        return this.data.keys.length;
      };
      /**
       * @method getKeyByIndex
       * @param {Number} index
       */


      TupleDictionary.prototype.getKeyByIndex = function (index) {
        return this.data.keys[index];
      };
      /**
       * @method getDataByKey
       * @param {Number} Key
       */


      TupleDictionary.prototype.getDataByKey = function (Key) {
        return this.data[Key];
      };
    }, {}],
    55: [function (_dereq_, module, exports) {
      function Utils() {}

      module.exports = Utils;
      /**
       * Extend an options object with default values.
       * @static
       * @method defaults
       * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
       * @param  {object} defaults An object containing default values.
       * @return {object} The modified options object.
       */

      Utils.defaults = function (options, defaults) {
        options = options || {};

        for (var key in defaults) {
          if (!(key in options)) {
            options[key] = defaults[key];
          }
        }

        return options;
      };
    }, {}],
    56: [function (_dereq_, module, exports) {
      module.exports = Vec3Pool;

      var Vec3 = _dereq_('../math/Vec3');

      var Pool = _dereq_('./Pool');
      /**
       * @class Vec3Pool
       * @constructor
       * @extends Pool
       */


      function Vec3Pool() {
        Pool.call(this);
        this.type = Vec3;
      }

      Vec3Pool.prototype = new Pool();
      /**
       * Construct a vector
       * @method constructObject
       * @return {Vec3}
       */

      Vec3Pool.prototype.constructObject = function () {
        return new Vec3();
      };
    }, {
      "../math/Vec3": 32,
      "./Pool": 53
    }],
    57: [function (_dereq_, module, exports) {
      module.exports = Narrowphase;

      var AABB = _dereq_('../collision/AABB');

      var Body = _dereq_('../objects/Body');

      var Shape = _dereq_('../shapes/Shape');

      var Ray = _dereq_('../collision/Ray');

      var Vec3 = _dereq_('../math/Vec3');

      var Transform = _dereq_('../math/Transform');

      var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');

      var Quaternion = _dereq_('../math/Quaternion');

      var Solver = _dereq_('../solver/Solver');

      var Vec3Pool = _dereq_('../utils/Vec3Pool');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var FrictionEquation = _dereq_('../equations/FrictionEquation');
      /**
       * Helper class for the World. Generates ContactEquations.
       * @class Narrowphase
       * @constructor
       * @todo Sphere-ConvexPolyhedron contacts
       * @todo Contact reduction
       * @todo  should move methods to prototype
       */


      function Narrowphase(world) {
        /**
         * Internal storage of pooled contact points.
         * @property {Array} contactPointPool
         */
        this.contactPointPool = [];
        this.frictionEquationPool = [];
        this.result = [];
        this.frictionResult = [];
        /**
         * Pooled vectors.
         * @property {Vec3Pool} v3pool
         */

        this.v3pool = new Vec3Pool();
        this.world = world;
        this.currentContactMaterial = null;
        /**
         * @property {Boolean} enableFrictionReduction
         */

        this.enableFrictionReduction = false;
      }
      /**
       * Make a contact object, by using the internal pool or creating a new one.
       * @method createContactEquation
       * @param {Body} bi
       * @param {Body} bj
       * @param {Shape} si
       * @param {Shape} sj
       * @param {Shape} overrideShapeA
       * @param {Shape} overrideShapeB
       * @return {ContactEquation}
       */


      Narrowphase.prototype.createContactEquation = function (bi, bj, si, sj, overrideShapeA, overrideShapeB) {
        var c;

        if (this.contactPointPool.length) {
          c = this.contactPointPool.pop();
          c.bi = bi;
          c.bj = bj;
        } else {
          c = new ContactEquation(bi, bj);
        }

        c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
        var cm = this.currentContactMaterial;
        c.restitution = cm.restitution;
        c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
        var matA = si.material || bi.material;
        var matB = sj.material || bj.material;

        if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
          c.restitution = matA.restitution * matB.restitution;
        }

        c.si = overrideShapeA || si;
        c.sj = overrideShapeB || sj;
        return c;
      };

      Narrowphase.prototype.createFrictionEquationsFromContact = function (contactEquation, outArray) {
        var bodyA = contactEquation.bi;
        var bodyB = contactEquation.bj;
        var shapeA = contactEquation.si;
        var shapeB = contactEquation.sj;
        var world = this.world;
        var cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

        var friction = cm.friction;
        var matA = shapeA.material || bodyA.material;
        var matB = shapeB.material || bodyB.material;

        if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
          friction = matA.friction * matB.friction;
        }

        if (friction > 0) {
          // Create 2 tangent equations
          var mug = friction * world.gravity.length();
          var reducedMass = bodyA.invMass + bodyB.invMass;

          if (reducedMass > 0) {
            reducedMass = 1 / reducedMass;
          }

          var pool = this.frictionEquationPool;
          var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
          var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
          c1.bi = c2.bi = bodyA;
          c1.bj = c2.bj = bodyB;
          c1.minForce = c2.minForce = -mug * reducedMass;
          c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

          c1.ri.copy(contactEquation.ri);
          c1.rj.copy(contactEquation.rj);
          c2.ri.copy(contactEquation.ri);
          c2.rj.copy(contactEquation.rj); // Construct tangents

          contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

          c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
          c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
          c1.enabled = c2.enabled = contactEquation.enabled;
          outArray.push(c1, c2);
          return true;
        }

        return false;
      };

      var averageNormal = new Vec3();
      var averageContactPointA = new Vec3();
      var averageContactPointB = new Vec3(); // Take the average N latest contact point on the plane.

      Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
        // The last contactEquation
        var c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

        if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
          return;
        }

        var f1 = this.frictionResult[this.frictionResult.length - 2];
        var f2 = this.frictionResult[this.frictionResult.length - 1];
        averageNormal.setZero();
        averageContactPointA.setZero();
        averageContactPointB.setZero();
        var bodyA = c.bi;
        var bodyB = c.bj;

        for (var i = 0; i !== numContacts; i++) {
          c = this.result[this.result.length - 1 - i];

          if (c.bodyA !== bodyA) {
            averageNormal.vadd(c.ni, averageNormal);
            averageContactPointA.vadd(c.ri, averageContactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
          } else {
            averageNormal.vsub(c.ni, averageNormal);
            averageContactPointA.vadd(c.rj, averageContactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
          }
        }

        var invNumContacts = 1 / numContacts;
        averageContactPointA.scale(invNumContacts, f1.ri);
        averageContactPointB.scale(invNumContacts, f1.rj);
        f2.ri.copy(f1.ri); // Should be the same

        f2.rj.copy(f1.rj);
        averageNormal.normalize();
        averageNormal.tangents(f1.t, f2.t); // return eq;
      };

      var tmpVec1 = new Vec3();
      var tmpVec2 = new Vec3();
      var tmpQuat1 = new Quaternion();
      var tmpQuat2 = new Quaternion();
      /**
       * Generate all contacts between a list of body pairs
       * @method getContacts
       * @param {array} p1 Array of body indices
       * @param {array} p2 Array of body indices
       * @param {World} world
       * @param {array} result Array to store generated contacts
       * @param {array} oldcontacts Optional. Array of reusable contact objects
       */

      Narrowphase.prototype.getContacts = function (p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
        // Save old contact objects
        this.contactPointPool = oldcontacts;
        this.frictionEquationPool = frictionPool;
        this.result = result;
        this.frictionResult = frictionResult;
        var qi = tmpQuat1;
        var qj = tmpQuat2;
        var xi = tmpVec1;
        var xj = tmpVec2;

        for (var k = 0, N = p1.length; k !== N; k++) {
          // Get current collision bodies
          var bi = p1[k],
              bj = p2[k]; // Get contact material

          var bodyContactMaterial = null;

          if (bi.material && bj.material) {
            bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
          }

          var justTest = bi.collisionResponse == false || bj.collisionResponse == false || bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

          for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {
              // Compute world transform of shapes
              bj.quaternion.mult(bj.shapeOrientations[j], qj);
              bj.quaternion.vmult(bj.shapeOffsets[j], xj);
              xj.vadd(bj.position, xj);
              var sj = bj.shapes[j];

              if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
                continue;
              }

              if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                continue;
              } // is trigger ? ,trigger test


              justTest |= si.collisionResponse == false || sj.collisionResponse == false; // Get collision material

              var shapeContactMaterial = null;

              if (si.material && sj.material) {
                shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
              }

              this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

              var resolver = this[si.type | sj.type];

              if (resolver) {
                var retval = false;

                if (si.type < sj.type) {
                  retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
                } else {
                  retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
                }

                if (retval && justTest) {
                  // Register overlap
                  world.shapeOverlapKeeper.set(si.id, sj.id);
                  world.bodyOverlapKeeper.set(bi.id, bj.id);
                  var data = {
                    si: si,
                    sj: sj
                  };
                  world.triggerDic.set(si.id, sj.id, data);
                  world.oldTriggerDic.set(si.id, sj.id, data);
                }
              }
            }
          }
        }
      };

      var numWarnings = 0;
      var maxWarnings = 10;

      function warn(msg) {
        if (numWarnings > maxWarnings) {
          return;
        }

        numWarnings++;
        console.warn(msg);
      }

      Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] = Narrowphase.prototype.boxBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        sj.convexPolyhedronRepresentation.material = sj.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
        return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };
      /**
       * @method sphereSphere
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */


      Narrowphase.prototype[Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        if (justTest) {
          return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);
        } // We will have only one contact in this case


        var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

        xj.vsub(xi, r.ni);
        r.ni.normalize(); // Contact point locations

        r.ri.copy(r.ni);
        r.rj.copy(r.ni);
        r.ri.mult(si.radius, r.ri);
        r.rj.mult(-sj.radius, r.rj);
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      };
      /**
       * @method planeTrimesh
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */


      var planeTrimesh_normal = new Vec3();
      var planeTrimesh_relpos = new Vec3();
      var planeTrimesh_projected = new Vec3();

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh = function (planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
        // Make contacts!
        var v = new Vec3();
        var normal = planeTrimesh_normal;
        normal.set(0, 0, 1);
        planeQuat.vmult(normal, normal); // Turn normal according to plane

        for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {
          // Get world vertex from trimesh
          trimeshShape.getVertex(i, v); // Safe up

          var v2 = new Vec3();
          v2.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

          var relpos = planeTrimesh_relpos;
          v.vsub(planePos, relpos);
          var dot = normal.dot(relpos);

          if (dot <= 0.0) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
            r.ni.copy(normal); // Contact normal is the plane normal
            // Get vertex position projected on plane

            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected, projected); // ri is the projected world position minus plane position

            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj); // Store result

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      };
      /**
       * @method sphereTrimesh
       * @param  {Shape}      sphereShape
       * @param  {Shape}      trimeshShape
       * @param  {Vec3}       spherePos
       * @param  {Vec3}       trimeshPos
       * @param  {Quaternion} sphereQuat
       * @param  {Quaternion} trimeshQuat
       * @param  {Body}       sphereBody
       * @param  {Body}       trimeshBody
       */


      var sphereTrimesh_normal = new Vec3();
      var sphereTrimesh_relpos = new Vec3();
      var sphereTrimesh_projected = new Vec3();
      var sphereTrimesh_v = new Vec3();
      var sphereTrimesh_v2 = new Vec3();
      var sphereTrimesh_edgeVertexA = new Vec3();
      var sphereTrimesh_edgeVertexB = new Vec3();
      var sphereTrimesh_edgeVector = new Vec3();
      var sphereTrimesh_edgeVectorUnit = new Vec3();
      var sphereTrimesh_localSpherePos = new Vec3();
      var sphereTrimesh_tmp = new Vec3();
      var sphereTrimesh_va = new Vec3();
      var sphereTrimesh_vb = new Vec3();
      var sphereTrimesh_vc = new Vec3();
      var sphereTrimesh_localSphereAABB = new AABB();
      var sphereTrimesh_triangles = [];

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh = function (sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
        var edgeVertexA = sphereTrimesh_edgeVertexA;
        var edgeVertexB = sphereTrimesh_edgeVertexB;
        var edgeVector = sphereTrimesh_edgeVector;
        var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
        var localSpherePos = sphereTrimesh_localSpherePos;
        var tmp = sphereTrimesh_tmp;
        var localSphereAABB = sphereTrimesh_localSphereAABB;
        var v2 = sphereTrimesh_v2;
        var relpos = sphereTrimesh_relpos;
        var triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

        Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

        var sphereRadius = sphereShape.radius;
        localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
        localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
        trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
        // Vertices

        var v = sphereTrimesh_v;
        var radiusSquared = sphereShape.radius * sphereShape.radius;

        for (var i = 0; i < triangles.length; i++) {
          for (var j = 0; j < 3; j++) {
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

            v.vsub(localSpherePos, relpos);

            if (relpos.norm2() <= radiusSquared) {
              // Safe up
              v2.copy(v);
              Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
              v.vsub(spherePos, relpos);

              if (justTest) {
                return true;
              }

              var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
              r.ni.copy(relpos);
              r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

              r.ri.copy(r.ni);
              r.ri.scale(sphereShape.radius, r.ri);
              r.ri.vadd(spherePos, r.ri);
              r.ri.vsub(sphereBody.position, r.ri);
              r.rj.copy(v);
              r.rj.vsub(trimeshBody.position, r.rj); // Store result

              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }
        } // Check all edges


        for (var i = 0; i < triangles.length; i++) {
          for (var j = 0; j < 3; j++) {
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);
            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
              // Now check the orthogonal distance from edge to sphere center
              localSpherePos.vsub(edgeVertexA, tmp);
              edgeVectorUnit.copy(edgeVector);
              edgeVectorUnit.normalize();
              positionAlongEdgeA = tmp.dot(edgeVectorUnit);
              edgeVectorUnit.scale(positionAlongEdgeA, tmp);
              tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

              var dist = tmp.distanceTo(localSpherePos);

              if (dist < sphereShape.radius) {
                if (justTest) {
                  return true;
                }

                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                tmp.vsub(localSpherePos, r.ni);
                r.ni.normalize();
                r.ni.scale(sphereShape.radius, r.ri);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                tmp.vsub(trimeshBody.position, r.rj);
                Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
          }
        } // Triangle faces


        var va = sphereTrimesh_va;
        var vb = sphereTrimesh_vb;
        var vc = sphereTrimesh_vc;
        var normal = sphereTrimesh_normal;

        for (var i = 0, N = triangles.length; i !== N; i++) {
          trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
          trimeshShape.getNormal(triangles[i], normal);
          localSpherePos.vsub(va, tmp);
          var dist = tmp.dot(normal);
          normal.scale(dist, tmp);
          localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

          dist = tmp.distanceTo(localSpherePos);

          if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }

        triangles.length = 0;
      };

      var point_on_plane_to_sphere = new Vec3();
      var plane_to_sphere_ortho = new Vec3();
      var p_s_ni = new Vec3();
      var p_s_ri = new Vec3();
      var p_s_rj = new Vec3();
      /**
       * @method spherePlane
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] = Narrowphase.prototype.spherePlane = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        // Contact normal
        p_s_ni.set(0, 0, 1);
        qj.vmult(p_s_ni, p_s_ni);
        p_s_ni.negate(p_s_ni); // body i is the sphere, flip normal

        p_s_ni.normalize(); // Needed?
        // Vector from sphere center to contact point

        p_s_ni.mult(si.radius, p_s_ri); // Project down sphere on plane

        xi.vsub(xj, point_on_plane_to_sphere);
        p_s_ni.mult(p_s_ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
        point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, p_s_rj); // The sphere position projected to plane

        if (-point_on_plane_to_sphere.dot(p_s_ni) <= si.radius) {
          if (justTest) {
            return true;
          } // We will have one contact in this case


          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Make it relative to the body

          r.ni.copy(p_s_ni);
          r.ri.copy(p_s_ri);
          r.rj.copy(p_s_rj);
          var ri = r.ri;
          var rj = r.rj;
          ri.vadd(xi, ri);
          ri.vsub(bi.position, ri);
          rj.vadd(xj, rj);
          rj.vsub(bj.position, rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }

        return false;
      }; // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html


      var pointInPolygon_edge = new Vec3();
      var pointInPolygon_edge_x_normal = new Vec3();
      var pointInPolygon_vtp = new Vec3();

      function pointInPolygon(verts, normal, p) {
        var positiveResult = null;
        var N = verts.length;

        for (var i = 0; i !== N; i++) {
          var v = verts[i]; // Get edge to the next vertex

          var edge = pointInPolygon_edge;
          verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

          var edge_x_normal = pointInPolygon_edge_x_normal; //var edge_x_normal = new Vec3();

          edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

          var vertex_to_p = pointInPolygon_vtp;
          p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

          var r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

          if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
            if (positiveResult === null) {
              positiveResult = r > 0;
            }

            continue;
          } else {
            return false; // Encountered some other sign. Exit.
          }
        } // If we got here, all dot products were of the same sign.


        return true;
      }

      var box_to_sphere = new Vec3();
      var sphereBox_ns = new Vec3();
      var sphereBox_ns1 = new Vec3();
      var sphereBox_ns2 = new Vec3();
      var sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
      var sphereBox_sphere_to_corner = new Vec3();
      var sphereBox_side_ns = new Vec3();
      var sphereBox_side_ns1 = new Vec3();
      var sphereBox_side_ns2 = new Vec3();
      /**
       * @method sphereBox
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] = Narrowphase.prototype.sphereBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        var v3pool = this.v3pool; // we refer to the box as body j

        var sides = sphereBox_sides;
        xi.vsub(xj, box_to_sphere);
        sj.getSideNormals(sides, qj);
        var R = si.radius;
        var penetrating_sides = []; // Check side (plane) intersections

        var found = false; // Store the resulting side penetration info

        var side_ns = sphereBox_side_ns;
        var side_ns1 = sphereBox_side_ns1;
        var side_ns2 = sphereBox_side_ns2;
        var side_h = null;
        var side_penetrations = 0;
        var side_dot1 = 0;
        var side_dot2 = 0;
        var side_distance = null;

        for (var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
          // Get the plane side normal (ns)
          var ns = sphereBox_ns;
          ns.copy(sides[idx]);
          var h = ns.norm();
          ns.normalize(); // The normal/distance dot product tells which side of the plane we are

          var dot = box_to_sphere.dot(ns);

          if (dot < h + R && dot > 0) {
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx + 1) % 3]);
            ns2.copy(sides[(idx + 2) % 3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);

            if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
              var dist = Math.abs(dot - h - R);

              if (side_distance === null || dist < side_distance) {
                side_distance = dist;
                side_dot1 = dot1;
                side_dot2 = dot2;
                side_h = h;
                side_ns.copy(ns);
                side_ns1.copy(ns1);
                side_ns2.copy(ns2);
                side_penetrations++;

                if (justTest) {
                  return true;
                }
              }
            }
          }
        }

        if (side_penetrations) {
          found = true;
          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          side_ns.mult(-R, r.ri); // Sphere r

          r.ni.copy(side_ns);
          r.ni.negate(r.ni); // Normal should be out of sphere

          side_ns.mult(side_h, side_ns);
          side_ns1.mult(side_dot1, side_ns1);
          side_ns.vadd(side_ns1, side_ns);
          side_ns2.mult(side_dot2, side_ns2);
          side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        } // Check corners


        var rj = v3pool.get();
        var sphere_to_corner = sphereBox_sphere_to_corner;

        for (var j = 0; j !== 2 && !found; j++) {
          for (var k = 0; k !== 2 && !found; k++) {
            for (var l = 0; l !== 2 && !found; l++) {
              rj.set(0, 0, 0);

              if (j) {
                rj.vadd(sides[0], rj);
              } else {
                rj.vsub(sides[0], rj);
              }

              if (k) {
                rj.vadd(sides[1], rj);
              } else {
                rj.vsub(sides[1], rj);
              }

              if (l) {
                rj.vadd(sides[2], rj);
              } else {
                rj.vsub(sides[2], rj);
              } // World position of corner


              xj.vadd(rj, sphere_to_corner);
              sphere_to_corner.vsub(xi, sphere_to_corner);

              if (sphere_to_corner.norm2() < R * R) {
                if (justTest) {
                  return true;
                }

                found = true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                r.ri.copy(sphere_to_corner);
                r.ri.normalize();
                r.ni.copy(r.ri);
                r.ri.mult(R, r.ri);
                r.rj.copy(rj); // Make relative to bodies

                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
          }
        }

        v3pool.release(rj);
        rj = null; // Check edges

        var edgeTangent = v3pool.get();
        var edgeCenter = v3pool.get();
        var r = v3pool.get(); // r = edge center to sphere center

        var orthogonal = v3pool.get();
        var dist = v3pool.get();
        var Nsides = sides.length;

        for (var j = 0; j !== Nsides && !found; j++) {
          for (var k = 0; k !== Nsides && !found; k++) {
            if (j % 3 !== k % 3) {
              // Get edge tangent
              sides[k].cross(sides[j], edgeTangent);
              edgeTangent.normalize();
              sides[j].vadd(sides[k], edgeCenter);
              r.copy(xi);
              r.vsub(edgeCenter, r);
              r.vsub(xj, r);
              var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

              edgeTangent.mult(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
              // Find the third side orthogonal to this one

              var l = 0;

              while (l === j % 3 || l === k % 3) {
                l++;
              } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


              dist.copy(xi);
              dist.vsub(orthogonal, dist);
              dist.vsub(edgeCenter, dist);
              dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

              var tdist = Math.abs(orthonorm);
              var ndist = dist.norm();

              if (tdist < sides[l].norm() && ndist < R) {
                if (justTest) {
                  return true;
                }

                found = true;
                var res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                edgeCenter.vadd(orthogonal, res.rj); // box rj

                res.rj.copy(res.rj);
                dist.negate(res.ni);
                res.ni.normalize();
                res.ri.copy(res.rj);
                res.ri.vadd(xj, res.ri);
                res.ri.vsub(xi, res.ri);
                res.ri.normalize();
                res.ri.mult(R, res.ri); // Make relative to bodies

                res.ri.vadd(xi, res.ri);
                res.ri.vsub(bi.position, res.ri);
                res.rj.vadd(xj, res.rj);
                res.rj.vsub(bj.position, res.rj);
                this.result.push(res);
                this.createFrictionEquationsFromContact(res, this.frictionResult);
              }
            }
          }
        }

        v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
      };

      var convex_to_sphere = new Vec3();
      var sphereConvex_edge = new Vec3();
      var sphereConvex_edgeUnit = new Vec3();
      var sphereConvex_sphereToCorner = new Vec3();
      var sphereConvex_worldCorner = new Vec3();
      var sphereConvex_worldNormal = new Vec3();
      var sphereConvex_worldPoint = new Vec3();
      var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
      var sphereConvex_penetrationVec = new Vec3();
      var sphereConvex_sphereToWorldPoint = new Vec3();
      /**
       * @method sphereConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        var v3pool = this.v3pool;
        xi.vsub(xj, convex_to_sphere);
        var normals = sj.faceNormals;
        var faces = sj.faces;
        var verts = sj.vertices;
        var R = si.radius;
        var penetrating_sides = []; // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
        //     return;
        // }
        // Check corners

        for (var i = 0; i !== verts.length; i++) {
          var v = verts[i]; // World position of corner

          var worldCorner = sphereConvex_worldCorner;
          qj.vmult(v, worldCorner);
          xj.vadd(worldCorner, worldCorner);
          var sphere_to_corner = sphereConvex_sphereToCorner;
          worldCorner.vsub(xi, sphere_to_corner);

          if (sphere_to_corner.norm2() < R * R) {
            if (justTest) {
              return true;
            }

            found = true;
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R, r.ri);
            worldCorner.vsub(xj, r.rj); // Should be relative to the body.

            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
            return;
          }
        } // Check side (plane) intersections


        var found = false;

        for (var i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
          var normal = normals[i];
          var face = faces[i]; // Get world-transformed normal of the face

          var worldNormal = sphereConvex_worldNormal;
          qj.vmult(normal, worldNormal); // Get a world vertex from the face

          var worldPoint = sphereConvex_worldPoint;
          qj.vmult(verts[face[0]], worldPoint);
          worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

          var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
          worldNormal.mult(-R, worldSpherePointClosestToPlane);
          xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

          var penetrationVec = sphereConvex_penetrationVec;
          worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

          var penetration = penetrationVec.dot(worldNormal);
          var worldPointToSphere = sphereConvex_sphereToWorldPoint;
          xi.vsub(worldPoint, worldPointToSphere);

          if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords

            for (var j = 0, Nverts = face.length; j !== Nverts; j++) {
              var worldVertex = v3pool.get();
              qj.vmult(verts[face[j]], worldVertex);
              xj.vadd(worldVertex, worldVertex);
              faceVerts.push(worldVertex);
            }

            if (pointInPolygon(faceVerts, worldNormal, xi)) {
              // Is the sphere center in the face polygon?
              if (justTest) {
                return true;
              }

              found = true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact

              worldNormal.negate(r.ni); // Normal pointing out of sphere

              var penetrationVec2 = v3pool.get();
              worldNormal.mult(-penetration, penetrationVec2);
              var penetrationSpherePoint = v3pool.get();
              worldNormal.mult(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

              xi.vsub(xj, r.rj);
              r.rj.vadd(penetrationSpherePoint, r.rj);
              r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              v3pool.release(penetrationVec2);
              v3pool.release(penetrationSpherePoint);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

              for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                v3pool.release(faceVerts[j]);
              }

              return; // We only expect *one* face contact
            } else {
              // Edge?
              for (var j = 0; j !== face.length; j++) {
                // Get two world transformed vertices
                var v1 = v3pool.get();
                var v2 = v3pool.get();
                qj.vmult(verts[face[(j + 1) % face.length]], v1);
                qj.vmult(verts[face[(j + 2) % face.length]], v2);
                xj.vadd(v1, v1);
                xj.vadd(v2, v2); // Construct edge vector

                var edge = sphereConvex_edge;
                v2.vsub(v1, edge); // Construct the same vector, but normalized

                var edgeUnit = sphereConvex_edgeUnit;
                edge.unit(edgeUnit); // p is xi projected onto the edge

                var p = v3pool.get();
                var v1_to_xi = v3pool.get();
                xi.vsub(v1, v1_to_xi);
                var dot = v1_to_xi.dot(edgeUnit);
                edgeUnit.mult(dot, p);
                p.vadd(v1, p); // Compute a vector from p to the center of the sphere

                var xi_to_p = v3pool.get();
                p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
                // AND if p is in between v1 and v2

                if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) {
                  // Collision if the edge-sphere distance is less than the radius
                  // Edge contact!
                  if (justTest) {
                    return true;
                  }

                  var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                  p.vsub(xj, r.rj);
                  p.vsub(xi, r.ni);
                  r.ni.normalize();
                  r.ni.mult(R, r.ri); // Should be relative to the body.

                  r.rj.vadd(xj, r.rj);
                  r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

                  r.ri.vadd(xi, r.ri);
                  r.ri.vsub(bi.position, r.ri);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

                  for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                    v3pool.release(faceVerts[j]);
                  }

                  v3pool.release(v1);
                  v3pool.release(v2);
                  v3pool.release(p);
                  v3pool.release(xi_to_p);
                  v3pool.release(v1_to_xi);
                  return;
                }

                v3pool.release(v1);
                v3pool.release(v2);
                v3pool.release(p);
                v3pool.release(xi_to_p);
                v3pool.release(v1_to_xi);
              }
            } // Release world vertices


            for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
              v3pool.release(faceVerts[j]);
            }
          }
        }
      };

      var planeBox_normal = new Vec3();
      var plane_to_corner = new Vec3();
      /**
       * @method planeBox
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] = Narrowphase.prototype.planeBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        sj.convexPolyhedronRepresentation.material = sj.material;
        sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
        sj.convexPolyhedronRepresentation.id = sj.id;
        return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      var planeConvex_v = new Vec3();
      var planeConvex_normal = new Vec3();
      var planeConvex_relpos = new Vec3();
      var planeConvex_projected = new Vec3();
      /**
       * @method planeConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex = function (planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
        // Simply return the points behind the plane.
        var worldVertex = planeConvex_v,
            worldNormal = planeConvex_normal;
        worldNormal.set(0, 0, 1);
        planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

        var numContacts = 0;
        var relpos = planeConvex_relpos;

        for (var i = 0; i !== convexShape.vertices.length; i++) {
          // Get world convex vertex
          worldVertex.copy(convexShape.vertices[i]);
          convexQuat.vmult(worldVertex, worldVertex);
          convexPosition.vadd(worldVertex, worldVertex);
          worldVertex.vsub(planePosition, relpos);
          var dot = worldNormal.dot(relpos);

          if (dot <= 0.0) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos), projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
            // rj is now just the vector from the convex center to the vertex

            worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);
            this.result.push(r);
            numContacts++;

            if (!this.enableFrictionReduction) {
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }
        }

        if (this.enableFrictionReduction && numContacts) {
          this.createFrictionFromAverage(numContacts);
        }
      };

      var convexConvex_sepAxis = new Vec3();
      var convexConvex_q = new Vec3();
      /**
       * @method convexConvex
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
        var sepAxis = convexConvex_sepAxis;

        if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
          return;
        }

        if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
          var res = [];
          var q = convexConvex_q;
          si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
          var numContacts = 0;

          for (var j = 0; j !== res.length; j++) {
            if (justTest) {
              return true;
            }

            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

            ri.vsub(xi, ri);
            rj.vsub(xj, rj); // Make relative to bodies

            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);
            this.result.push(r);
            numContacts++;

            if (!this.enableFrictionReduction) {
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          }

          if (this.enableFrictionReduction && numContacts) {
            this.createFrictionFromAverage(numContacts);
          }
        }
      };
      /**
       * @method convexTrimesh
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */
      // Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
      // Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest,faceListA,faceListB){
      //     var sepAxis = convexConvex_sepAxis;
      //     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
      //         return;
      //     }
      //     // Construct a temp hull for each triangle
      //     var hullB = new ConvexPolyhedron();
      //     hullB.faces = [[0,1,2]];
      //     var va = new Vec3();
      //     var vb = new Vec3();
      //     var vc = new Vec3();
      //     hullB.vertices = [
      //         va,
      //         vb,
      //         vc
      //     ];
      //     for (var i = 0; i < sj.indices.length / 3; i++) {
      //         var triangleNormal = new Vec3();
      //         sj.getNormal(i, triangleNormal);
      //         hullB.faceNormals = [triangleNormal];
      //         sj.getTriangleVertices(i, va, vb, vc);
      //         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
      //         if(!d){
      //             triangleNormal.scale(-1, triangleNormal);
      //             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
      //             if(!d){
      //                 continue;
      //             }
      //         }
      //         var res = [];
      //         var q = convexConvex_q;
      //         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
      //         if(res.length == 0) return false;
      //         if(justTest) return true;
      //         for(var j = 0; j !== res.length; j++){
      //             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
      //                 ri = r.ri,
      //                 rj = r.rj;
      //             r.ni.copy(triangleNormal);
      //             r.ni.negate(r.ni);
      //             res[j].normal.negate(q);
      //             q.mult(res[j].depth, q);
      //             res[j].point.vadd(q, ri);
      //             rj.copy(res[j].point);
      //             // Contact points are in world coordinates. Transform back to relative
      //             ri.vsub(xi,ri);
      //             rj.vsub(xj,rj);
      //             // Make relative to bodies
      //             ri.vadd(xi, ri);
      //             ri.vsub(bi.position, ri);
      //             rj.vadd(xj, rj);
      //             rj.vsub(bj.position, rj);
      //             result.push(r);
      //         }
      //     }
      // };


      var particlePlane_normal = new Vec3();
      var particlePlane_relpos = new Vec3();
      var particlePlane_projected = new Vec3();
      /**
       * @method particlePlane
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        var normal = particlePlane_normal;
        normal.set(0, 0, 1);
        bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

        var relpos = particlePlane_relpos;
        xi.vsub(bj.position, relpos);
        var dot = normal.dot(relpos);

        if (dot <= 0.0) {
          if (justTest) {
            return true;
          }

          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          r.ni.copy(normal); // Contact normal is the plane normal

          r.ni.negate(r.ni);
          r.ri.set(0, 0, 0); // Center of particle
          // Get particle position projected on plane

          var projected = particlePlane_projected;
          normal.mult(normal.dot(xi), projected);
          xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
          // rj is now the projected world position minus plane position

          r.rj.copy(projected);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      };

      var particleSphere_normal = new Vec3();
      /**
       * @method particleSphere
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        // The normal is the unit vector from sphere center to particle center
        var normal = particleSphere_normal;
        normal.set(0, 0, 1);
        xi.vsub(xj, normal);
        var lengthSquared = normal.norm2();

        if (lengthSquared <= sj.radius * sj.radius) {
          if (justTest) {
            return true;
          }

          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          normal.normalize();
          r.rj.copy(normal);
          r.rj.mult(sj.radius, r.rj);
          r.ni.copy(normal); // Contact normal

          r.ni.negate(r.ni);
          r.ri.set(0, 0, 0); // Center of particle

          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }; // WIP


      var cqj = new Quaternion();
      var convexParticle_local = new Vec3();
      var convexParticle_normal = new Vec3();
      var convexParticle_penetratedFaceNormal = new Vec3();
      var convexParticle_vertexToParticle = new Vec3();
      var convexParticle_worldPenetrationVec = new Vec3();
      /**
       * @method convexParticle
       * @param  {Array}      result
       * @param  {Shape}      si
       * @param  {Shape}      sj
       * @param  {Vec3}       xi
       * @param  {Vec3}       xj
       * @param  {Quaternion} qi
       * @param  {Quaternion} qj
       * @param  {Body}       bi
       * @param  {Body}       bj
       */

      Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
        var penetratedFaceIndex = -1;
        var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
        var worldPenetrationVec = convexParticle_worldPenetrationVec;
        var minPenetration = null;
        var numDetectedFaces = 0; // Convert particle position xi to local coords in the convex

        var local = convexParticle_local;
        local.copy(xi);
        local.vsub(xj, local); // Convert position to relative the convex origin

        qj.conjugate(cqj);
        cqj.vmult(local, local);

        if (sj.pointIsInside(local)) {
          if (sj.worldVerticesNeedsUpdate) {
            sj.computeWorldVertices(xj, qj);
          }

          if (sj.worldFaceNormalsNeedsUpdate) {
            sj.computeWorldFaceNormals(qj);
          } // For each world polygon in the polyhedra


          for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
            // Construct world face vertices
            var verts = [sj.worldVertices[sj.faces[i][0]]];
            var normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

            xi.vsub(verts[0], convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);

            if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
              if (justTest) {
                return true;
              }

              minPenetration = penetration;
              penetratedFaceIndex = i;
              penetratedFaceNormal.copy(normal);
              numDetectedFaces++;
            }
          }

          if (penetratedFaceIndex !== -1) {
            // Setup contact
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

            worldPenetrationVec.vadd(xi, worldPenetrationVec);
            worldPenetrationVec.vsub(xj, worldPenetrationVec);
            r.rj.copy(worldPenetrationVec); //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);
            //qj.vmult(r.rj,r.rj);

            penetratedFaceNormal.negate(r.ni); // Contact normal

            r.ri.set(0, 0, 0); // Center of particle

            var ri = r.ri,
                rj = r.rj; // Make relative to bodies

            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
          }
        }
      };

      Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
        si.convexPolyhedronRepresentation.material = si.material;
        si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
        return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
      };

      var convexHeightfield_tmp1 = new Vec3();
      var convexHeightfield_tmp2 = new Vec3();
      var convexHeightfield_faceList = [0];
      /**
       * @method convexHeightfield
       */

      Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function (convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
        var data = hfShape.data,
            w = hfShape.elementSize,
            radius = convexShape.boundingSphereRadius,
            worldPillarOffset = convexHeightfield_tmp2,
            faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

        var localConvexPos = convexHeightfield_tmp1;
        Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

        var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
            iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
            iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
            iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

        if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
          return;
        } // Clamp index to edges


        if (iMinX < 0) {
          iMinX = 0;
        }

        if (iMaxX < 0) {
          iMaxX = 0;
        }

        if (iMinY < 0) {
          iMinY = 0;
        }

        if (iMaxY < 0) {
          iMaxY = 0;
        }

        if (iMinX >= data.length) {
          iMinX = data.length - 1;
        }

        if (iMaxX >= data.length) {
          iMaxX = data.length - 1;
        }

        if (iMaxY >= data[0].length) {
          iMaxY = data[0].length - 1;
        }

        if (iMinY >= data[0].length) {
          iMinY = data[0].length - 1;
        }

        var minMax = [];
        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
        var min = minMax[0];
        var max = minMax[1]; // Bail out if we're cant touch the bounding height box

        if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
          return;
        }

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            var intersecting = false; // Lower triangle

            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
              intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest, faceList, null);
            }

            if (justTest && intersecting) {
              return true;
            } // Upper triangle


            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
              intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest, faceList, null);
            }

            if (justTest && intersecting) {
              return true;
            }
          }
        }
      };

      var sphereHeightfield_tmp1 = new Vec3();
      var sphereHeightfield_tmp2 = new Vec3();
      /**
       * @method sphereHeightfield
       */

      Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield = function (sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
        var data = hfShape.data,
            radius = sphereShape.radius,
            w = hfShape.elementSize,
            worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

        var localSpherePos = sphereHeightfield_tmp1;
        Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

        var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
            iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
            iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
            iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

        if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
          return;
        } // Clamp index to edges


        if (iMinX < 0) {
          iMinX = 0;
        }

        if (iMaxX < 0) {
          iMaxX = 0;
        }

        if (iMinY < 0) {
          iMinY = 0;
        }

        if (iMaxY < 0) {
          iMaxY = 0;
        }

        if (iMinX >= data.length) {
          iMinX = data.length - 1;
        }

        if (iMaxX >= data.length) {
          iMaxX = data.length - 1;
        }

        if (iMaxY >= data[0].length) {
          iMaxY = data[0].length - 1;
        }

        if (iMinY >= data[0].length) {
          iMinY = data[0].length - 1;
        }

        var minMax = [];
        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
        var min = minMax[0];
        var max = minMax[1]; // Bail out if we're cant touch the bounding height box

        if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
          return;
        }

        var result = this.result;

        for (var i = iMinX; i < iMaxX; i++) {
          for (var j = iMinY; j < iMaxY; j++) {
            var numContactsBefore = result.length;
            var intersecting = false; // Lower triangle

            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
              intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if (justTest && intersecting) {
              return true;
            } // Upper triangle


            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
              intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if (justTest && intersecting) {
              return true;
            }

            var numContacts = result.length - numContactsBefore;

            if (numContacts > 2) {
              return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */

          }
        }
      };
    }, {
      "../collision/AABB": 3,
      "../collision/Ray": 10,
      "../equations/ContactEquation": 20,
      "../equations/FrictionEquation": 22,
      "../math/Quaternion": 30,
      "../math/Transform": 31,
      "../math/Vec3": 32,
      "../objects/Body": 33,
      "../shapes/ConvexPolyhedron": 40,
      "../shapes/Shape": 45,
      "../solver/Solver": 49,
      "../utils/Vec3Pool": 56
    }],
    58: [function (_dereq_, module, exports) {
      /* global performance */
      module.exports = World;

      var Shape = _dereq_('../shapes/Shape');

      var Vec3 = _dereq_('../math/Vec3');

      var Quaternion = _dereq_('../math/Quaternion');

      var GSSolver = _dereq_('../solver/GSSolver');

      var ContactEquation = _dereq_('../equations/ContactEquation');

      var FrictionEquation = _dereq_('../equations/FrictionEquation');

      var Narrowphase = _dereq_('./Narrowphase');

      var EventTarget = _dereq_('../utils/EventTarget');

      var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');

      var ObjectCollisionMatrix = _dereq_('../collision/ObjectCollisionMatrix');

      var OverlapKeeper = _dereq_('../collision/OverlapKeeper');

      var Material = _dereq_('../material/Material');

      var ContactMaterial = _dereq_('../material/ContactMaterial');

      var Body = _dereq_('../objects/Body');

      var TupleDictionary = _dereq_('../utils/TupleDictionary');

      var RaycastResult = _dereq_('../collision/RaycastResult');

      var AABB = _dereq_('../collision/AABB');

      var Ray = _dereq_('../collision/Ray');

      var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');
      /**
       * The physics world
       * @class World
       * @constructor
       * @extends EventTarget
       * @param {object} [options]
       * @param {Vec3} [options.gravity]
       * @param {boolean} [options.allowSleep]
       * @param {Broadphase} [options.broadphase]
       * @param {Solver} [options.solver]
       * @param {boolean} [options.quatNormalizeFast]
       * @param {number} [options.quatNormalizeSkip]
       */


      function World(options) {
        options = options || {};
        EventTarget.apply(this);
        /**
         * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
         * @property {Number} dt
         */

        this.dt = -1;
        /**
         * Makes bodies go to sleep when they've been inactive
         * @property allowSleep
         * @type {Boolean}
         * @default false
         */

        this.allowSleep = !!options.allowSleep;
        /**
         * All the current contacts (instances of ContactEquation) in the world.
         * @property contacts
         * @type {Array}
         */

        this.contacts = [];
        this.frictionEquations = [];
        /**
         * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
         * @property quatNormalizeSkip
         * @type {Number}
         * @default 0
         */

        this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
        /**
         * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
         * @property quatNormalizeFast
         * @type {Boolean}
         * @see Quaternion.normalizeFast
         * @see Quaternion.normalize
         * @default false
         */

        this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
        /**
         * The wall-clock time since simulation start
         * @property time
         * @type {Number}
         */

        this.time = 0.0;
        this.timeFixed = 0.0;
        /**
         * Number of timesteps taken since start
         * @property stepnumber
         * @type {Number}
         */

        this.stepnumber = 0; /// Default and last timestep sizes

        this.default_dt = 1 / 60;
        this.nextId = 0;
        /**
         * @property gravity
         * @type {Vec3}
         */

        this.gravity = new Vec3();

        if (options.gravity) {
          this.gravity.copy(options.gravity);
        }
        /**
         * The broadphase algorithm to use. Default is NaiveBroadphase
         * @property broadphase
         * @type {Broadphase}
         */


        this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
        /**
         * @property bodies
         * @type {Array}
         */

        this.bodies = [];
        /**
         * The solver algorithm to use. Default is GSSolver
         * @property solver
         * @type {Solver}
         */

        this.solver = options.solver !== undefined ? options.solver : new GSSolver();
        /**
         * @property constraints
         * @type {Array}
         */

        this.constraints = [];
        /**
         * @property narrowphase
         * @type {Narrowphase}
         */

        this.narrowphase = new Narrowphase(this);
        /**
         * @property {ArrayCollisionMatrix} collisionMatrix
        * @type {ArrayCollisionMatrix}
        */

        this.collisionMatrix = new ArrayCollisionMatrix();
        /**
         * CollisionMatrix from the previous step.
         * @property {ArrayCollisionMatrix} collisionMatrixPrevious
        * @type {ArrayCollisionMatrix}
        */

        this.collisionMatrixPrevious = new ArrayCollisionMatrix();
        this.bodyOverlapKeeper = new OverlapKeeper();
        this.shapeOverlapKeeper = new OverlapKeeper();
        /**
         * All added materials
         * @property materials
         * @type {Array}
         */

        this.materials = [];
        /**
         * @property contactmaterials
         * @type {Array}
         */

        this.contactmaterials = [];
        /**
         * Used to look up a ContactMaterial given two instances of Material.
         * @property {TupleDictionary} contactMaterialTable
         */

        this.contactMaterialTable = new TupleDictionary();
        this.defaultMaterial = new Material("default");
        /**
         * This contact material is used if no suitable contactmaterial is found for a contact.
         * @property defaultContactMaterial
         * @type {ContactMaterial}
         */

        this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
          friction: 0.3,
          restitution: 0.0
        });
        /**
         * @property doProfiling
         * @type {Boolean}
         */

        this.doProfiling = false;
        /**
         * @property profile
         * @type {Object}
         */

        this.profile = {
          solve: 0,
          makeContactConstraints: 0,
          broadphase: 0,
          integrate: 0,
          narrowphase: 0
        };
        /**
         * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/
         * @property {Number} accumulator
         */

        this.accumulator = 0;
        /**
         * @property subsystems
         * @type {Array}
         */

        this.subsystems = [];
        /**
         * Dispatched after a body has been added to the world.
         * @event addBody
         * @param {Body} body The body that has been added to the world.
         */

        this.addBodyEvent = {
          type: "addBody",
          body: null
        };
        /**
         * Dispatched after a body has been removed from the world.
         * @event removeBody
         * @param {Body} body The body that has been removed from the world.
         */

        this.removeBodyEvent = {
          type: "removeBody",
          body: null
        };
        this.idToBodyMap = {};
        this.broadphase.setWorld(this);
        this.substeps = 0;
        this.cm = new ObjectCollisionMatrix();
        this.tm = new ObjectCollisionMatrix();
        this.triggerDic = new TupleDictionary();
        this.oldTriggerDic = new TupleDictionary();
        this.contactsDic = new TupleDictionary();
        this.oldContactsDic = new TupleDictionary();
      }

      World.idToBodyMap = {};
      World.idToShapeMap = {};
      World.prototype = new EventTarget(); // Temp stuff

      var tmpAABB1 = new AABB();
      var tmpArray1 = [];
      var tmpRay = new Ray();
      /**
       * Get the contact material between materials m1 and m2
       * @method getContactMaterial
       * @param {Material} m1
       * @param {Material} m2
       * @return {ContactMaterial} The contact material if it was found.
       */

      World.prototype.getContactMaterial = function (m1, m2) {
        return this.contactMaterialTable.get(m1.id, m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
      };
      /**
       * Get number of objects in the world.
       * @method numObjects
       * @return {Number}
       * @deprecated
       */


      World.prototype.numObjects = function () {
        return this.bodies.length;
      };
      /**
       * Store old collision state info
       * @method collisionMatrixTick
       */


      World.prototype.collisionMatrixTick = function () {
        var temp = this.collisionMatrixPrevious;
        this.collisionMatrixPrevious = this.collisionMatrix;
        this.collisionMatrix = temp;
        this.collisionMatrix.reset();
        this.bodyOverlapKeeper.tick();
        this.shapeOverlapKeeper.tick();
      };
      /**
       * Add a rigid body to the simulation.
       * @method add
       * @param {Body} body
       * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
       * @todo Adding an array of bodies should be possible. This would save some loops too
       * @deprecated Use .addBody instead
       */


      World.prototype.add = World.prototype.addBody = function (body) {
        World.SLEEPING = false;

        if (this.bodies.indexOf(body) !== -1) {
          return;
        }

        body.index = this.bodies.length;
        this.bodies.push(body);
        body.world = this;
        body.initPosition.copy(body.position);
        body.initVelocity.copy(body.velocity);
        body.timeLastSleepy = this.time;

        if (body instanceof Body) {
          body.initAngularVelocity.copy(body.angularVelocity);
          body.initQuaternion.copy(body.quaternion);
        }

        this.collisionMatrix.setNumObjects(this.bodies.length);
        this.addBodyEvent.body = body;
        this.cm.setNumObjects(this.bodies.length);
        World.idToBodyMap[body.id] = body;
        this.dispatchEvent(this.addBodyEvent);
      };
      /**
       * Add a constraint to the simulation.
       * @method addConstraint
       * @param {Constraint} c
       */


      World.prototype.addConstraint = function (c) {
        World.SLEEPING = false;
        this.constraints.push(c);
      };
      /**
       * Removes a constraint
       * @method removeConstraint
       * @param {Constraint} c
       */


      World.prototype.removeConstraint = function (c) {
        World.SLEEPING = false;
        var idx = this.constraints.indexOf(c);

        if (idx !== -1) {
          this.constraints.splice(idx, 1);
        }
      };
      /**
       * Raycast test
       * @method rayTest
       * @param {Vec3} from
       * @param {Vec3} to
       * @param {RaycastResult} result
       * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
       */


      World.prototype.rayTest = function (from, to, result) {
        if (result instanceof RaycastResult) {
          // Do raycastclosest
          this.raycastClosest(from, to, {
            skipBackfaces: true
          }, result);
        } else {
          // Do raycastAll
          this.raycastAll(from, to, {
            skipBackfaces: true
          }, result);
        }
      };
      /**
       * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
       * @method raycastAll
       * @param  {Vec3} from
       * @param  {Vec3} to
       * @param  {Object} options
       * @param  {number} [options.collisionFilterMask=-1]
       * @param  {number} [options.collisionFilterGroup=-1]
       * @param  {boolean} [options.skipBackfaces=false]
       * @param  {boolean} [options.checkCollisionResponse=true]
       * @param  {Function} callback
       * @return {boolean} True if any body was hit.
       */


      World.prototype.raycastAll = function (from, to, options, callback) {
        options.mode = Ray.ALL;
        options.from = from;
        options.to = to;
        options.callback = callback;
        return tmpRay.intersectWorld(this, options);
      };
      /**
       * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
       * @method raycastAny
       * @param  {Vec3} from
       * @param  {Vec3} to
       * @param  {Object} options
       * @param  {number} [options.collisionFilterMask=-1]
       * @param  {number} [options.collisionFilterGroup=-1]
       * @param  {boolean} [options.skipBackfaces=false]
       * @param  {boolean} [options.checkCollisionResponse=true]
       * @param  {RaycastResult} result
       * @return {boolean} True if any body was hit.
       */


      World.prototype.raycastAny = function (from, to, options, result) {
        options.mode = Ray.ANY;
        options.from = from;
        options.to = to;
        options.result = result;
        return tmpRay.intersectWorld(this, options);
      };
      /**
       * Ray cast, and return information of the closest hit.
       * @method raycastClosest
       * @param  {Vec3} from
       * @param  {Vec3} to
       * @param  {Object} options
       * @param  {number} [options.collisionFilterMask=-1]
       * @param  {number} [options.collisionFilterGroup=-1]
       * @param  {boolean} [options.skipBackfaces=false]
       * @param  {boolean} [options.checkCollisionResponse=true]
       * @param  {RaycastResult} result
       * @return {boolean} True if any body was hit.
       */


      World.prototype.raycastClosest = function (from, to, options, result) {
        options.mode = Ray.CLOSEST;
        options.from = from;
        options.to = to;
        options.result = result;
        return tmpRay.intersectWorld(this, options);
      };
      /**
       * Remove a rigid body from the simulation.
       * @method remove
       * @param {Body} body
       * @deprecated Use .removeBody instead
       */


      World.prototype.remove = function (body) {
        World.SLEEPING = false;
        body.world = null;
        var n = this.bodies.length - 1,
            bodies = this.bodies,
            idx = bodies.indexOf(body);

        if (idx !== -1) {
          bodies.splice(idx, 1); // Todo: should use a garbage free method
          // Recompute index

          for (var i = 0; i !== bodies.length; i++) {
            bodies[i].index = i;
          }

          this.collisionMatrix.setNumObjects(n);
          this.removeBodyEvent.body = body;
          delete World.idToBodyMap[body.id];
          this.cm.setNumObjects(n);
          this.dispatchEvent(this.removeBodyEvent);
        }
      };
      /**
       * Remove a rigid body from the simulation.
       * @method removeBody
       * @param {Body} body
       */


      World.prototype.removeBody = World.prototype.remove;

      World.prototype.getBodyById = function (id) {
        return World.idToBodyMap[id];
      };

      World.prototype.getShapeById = function (id) {
        return World.idToShapeMap[id];
      };
      /**
       * Adds a material to the World.
       * @method addMaterial
       * @param {Material} m
       * @todo Necessary?
       */


      World.prototype.addMaterial = function (m) {
        this.materials.push(m);
      };
      /**
       * Adds a contact material to the World
       * @method addContactMaterial
       * @param {ContactMaterial} cmat
       */


      World.prototype.addContactMaterial = function (cmat) {
        // Add contact material
        this.contactmaterials.push(cmat); // Add current contact material to the material table

        this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
      }; // performance.now()


      if (typeof performance === 'undefined') {
        performance = {};
      }

      if (!performance.now) {
        var nowOffset = Date.now();

        if (performance.timing && performance.timing.navigationStart) {
          nowOffset = performance.timing.navigationStart;
        }

        performance.now = function () {
          return Date.now() - nowOffset;
        };
      }

      var step_tmp1 = new Vec3();
      /**
       * Step the physics world forward in time.
       *
       * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
       *
       * @method step
       * @param {Number} dt                       The fixed time step size to use.
       * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
       * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
       *
       * @example
       *     // fixed timestepping without interpolation
       *     world.step(1/60);
       *
       * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
       */

      World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
        maxSubSteps = maxSubSteps || 10;
        timeSinceLastCalled = timeSinceLastCalled || 0;

        if (timeSinceLastCalled === 0) {
          // Fixed, simple stepping
          this.internalStep(dt); // Increment time

          this.time += dt;
          this.substeps = 1;
        } else {
          this.accumulator += timeSinceLastCalled;
          this.substeps = 0;

          while (this.accumulator >= dt && this.substeps < maxSubSteps) {
            // Do fixed steps to catch up
            this.internalStep(dt);
            this.accumulator -= dt;
            this.substeps++;
          }

          var t = this.accumulator % dt / dt;

          for (var j = 0; j !== this.bodies.length; j++) {
            var b = this.bodies[j];
            b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
            b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
            b.previousQuaternion.normalize();
          }

          this.time += timeSinceLastCalled;
        }
      };

      var
      /**
       * Dispatched after the world has stepped forward in time.
       * @event postStep
       */
      World_step_postStepEvent = {
        type: "postStep"
      },
          // Reusable event objects to save memory

      /**
       * Dispatched before the world steps forward in time.
       * @event preStep
       */
      World_step_preStepEvent = {
        type: "preStep"
      },
          World_step_collideEvent = {
        type: "collide",
        body: null,
        contact: null
      },
          World_step_oldContacts = [],
          // Pools for unused objects
      World_step_frictionEquationPool = [],
          World_step_p1 = [],
          // Reusable arrays for collision pairs
      World_step_p2 = [],
          World_step_gvec = new Vec3(),
          // Temporary vectors and quats
      World_step_vi = new Vec3(),
          World_step_vj = new Vec3(),
          World_step_wi = new Vec3(),
          World_step_wj = new Vec3(),
          World_step_t1 = new Vec3(),
          World_step_t2 = new Vec3(),
          World_step_rixn = new Vec3(),
          World_step_rjxn = new Vec3(),
          World_step_step_q = new Quaternion(),
          World_step_step_w = new Quaternion(),
          World_step_step_wq = new Quaternion(),
          invI_tau_dt = new Vec3();

      World.prototype.internalStep = function (dt) {
        this.dt = dt;
        var world = this,
            that = this,
            contacts = this.contacts,
            p1 = World_step_p1,
            p2 = World_step_p2,
            N = this.numObjects(),
            bodies = this.bodies,
            solver = this.solver,
            gravity = this.gravity,
            doProfiling = this.doProfiling,
            profile = this.profile,
            DYNAMIC = Body.DYNAMIC,
            profilingStart,
            constraints = this.constraints,
            frictionEquationPool = World_step_frictionEquationPool,
            gnorm = gravity.norm(),
            gx = gravity.x,
            gy = gravity.y,
            gz = gravity.z,
            i = 0;

        if (doProfiling) {
          profilingStart = performance.now();
        } // Add gravity to all objects


        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          if (bi.useGravity && bi.type === DYNAMIC) {
            // Only for dynamic bodies
            var f = bi.force,
                m = bi.mass;
            f.x += m * gx;
            f.y += m * gy;
            f.z += m * gz;
          }
        } // Update subsystems


        for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
          this.subsystems[i].update();
        } // Collision detection


        if (doProfiling) {
          profilingStart = performance.now();
        }

        p1.length = 0; // Clean up pair arrays from last step

        p2.length = 0;
        this.broadphase.collisionPairs(this, p1, p2);

        if (doProfiling) {
          profile.broadphase = performance.now() - profilingStart;
        } // Remove constrained pairs with collideConnected == false


        var Nconstraints = constraints.length;

        for (i = 0; i !== Nconstraints; i++) {
          var c = constraints[i];

          if (!c.collideConnected) {
            for (var j = p1.length - 1; j >= 0; j -= 1) {
              if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
                p1.splice(j, 1);
                p2.splice(j, 1);
              }
            }
          }
        }

        this.collisionMatrixTick(); // Generate contacts

        if (doProfiling) {
          profilingStart = performance.now();
        }

        var oldcontacts = World_step_oldContacts;
        var NoldContacts = contacts.length;

        for (i = 0; i !== NoldContacts; i++) {
          oldcontacts.push(contacts[i]);
        }

        contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

        var NoldFrictionEquations = this.frictionEquations.length;

        for (i = 0; i !== NoldFrictionEquations; i++) {
          frictionEquationPool.push(this.frictionEquations[i]);
        }

        this.frictionEquations.length = 0;
        this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
        this.frictionEquations, frictionEquationPool);
        if (contacts.length == 0 && World.SLEEPING) return;

        if (doProfiling) {
          profile.narrowphase = performance.now() - profilingStart;
        } // Loop over all collisions


        if (doProfiling) {
          profilingStart = performance.now();
        } // Add all friction eqs


        for (var i = 0; i < this.frictionEquations.length; i++) {
          solver.addEquation(this.frictionEquations[i]);
        }

        var ncontacts = contacts.length;

        for (var k = 0; k !== ncontacts; k++) {
          // Current contact
          var c = contacts[k]; // Get current collision indeces

          var bi = c.bi,
              bj = c.bj,
              si = c.si,
              sj = c.sj; // // Get collision properties
          // var cm;
          // if(bi.material && bj.material){
          //     cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
          // } else {
          //     cm = this.defaultContactMaterial;
          // }
          // // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
          // var mu = cm.friction;
          // // c.restitution = cm.restitution;
          // // If friction or restitution were specified in the material, use them
          // if(bi.material && bj.material){
          //     if(bi.material.friction >= 0 && bj.material.friction >= 0){
          //         mu = bi.material.friction * bj.material.friction;
          //     }
          //     if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
          //         c.restitution = bi.material.restitution * bj.material.restitution;
          //     }
          // }
          // EXTEND

          if (si.material && sj.material) {
            if (si.material.restitution >= 0 && sj.material.restitution >= 0) {
              c.restitution = si.material.restitution * sj.material.restitution;
            }
          } else {
            if (bi.material && bj.material) {
              if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
                c.restitution = bi.material.restitution * bj.material.restitution;
              }
            }
          } // c.setSpookParams(
          //           cm.contactEquationStiffness,
          //           cm.contactEquationRelaxation,
          //           dt
          //       );


          solver.addEquation(c); // // Add friction constraint equation
          // if(mu > 0){
          // 	// Create 2 tangent equations
          // 	var mug = mu * gnorm;
          // 	var reducedMass = (bi.invMass + bj.invMass);
          // 	if(reducedMass > 0){
          // 		reducedMass = 1/reducedMass;
          // 	}
          // 	var pool = frictionEquationPool;
          // 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
          // 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
          // 	this.frictionEquations.push(c1, c2);
          // 	c1.bi = c2.bi = bi;
          // 	c1.bj = c2.bj = bj;
          // 	c1.minForce = c2.minForce = -mug*reducedMass;
          // 	c1.maxForce = c2.maxForce = mug*reducedMass;
          // 	// Copy over the relative vectors
          // 	c1.ri.copy(c.ri);
          // 	c1.rj.copy(c.rj);
          // 	c2.ri.copy(c.ri);
          // 	c2.rj.copy(c.rj);
          // 	// Construct tangents
          // 	c.ni.tangents(c1.t, c2.t);
          //           // Set spook params
          //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
          //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
          //           c1.enabled = c2.enabled = c.enabled;
          // 	// Add equations to solver
          // 	solver.addEquation(c1);
          // 	solver.addEquation(c2);
          // }

          if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);

            if (speedSquaredB >= speedLimitSquaredB * 2) {
              bi._wakeUpAfterNarrowphase = true;
            }
          }

          if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);

            if (speedSquaredA >= speedLimitSquaredA * 2) {
              bj._wakeUpAfterNarrowphase = true;
            }
          } // Now we know that i and j are in contact. Set collision matrix state


          this.collisionMatrix.set(bi, bj, true);

          if (!this.collisionMatrixPrevious.get(bi, bj)) {
            // First contact!
            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
            World_step_collideEvent.body = bj;
            World_step_collideEvent.contact = c;
            bi.dispatchEvent(World_step_collideEvent);
            World_step_collideEvent.body = bi;
            bj.dispatchEvent(World_step_collideEvent);
          }

          this.bodyOverlapKeeper.set(bi.id, bj.id);
          this.shapeOverlapKeeper.set(si.id, sj.id);
        }

        this.emitContactEvents();

        if (doProfiling) {
          profile.makeContactConstraints = performance.now() - profilingStart;
          profilingStart = performance.now();
        } // Wake up bodies


        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          if (bi._wakeUpAfterNarrowphase) {
            bi.wakeUp();
            bi._wakeUpAfterNarrowphase = false;
          }
        } // Add user-added constraints


        var Nconstraints = constraints.length;

        for (i = 0; i !== Nconstraints; i++) {
          var c = constraints[i];
          c.update();

          for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
            var eq = c.equations[j];
            solver.addEquation(eq);
          }
        } // Solve the constrained system


        solver.solve(dt, this);

        if (doProfiling) {
          profile.solve = performance.now() - profilingStart;
        } // Remove all contacts from solver


        solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

        var pow = Math.pow;

        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          if (bi.type & DYNAMIC) {
            // Only for dynamic bodies
            var ld = pow(1.0 - bi.linearDamping, dt);
            var v = bi.velocity;
            v.mult(ld, v);
            var av = bi.angularVelocity;

            if (av) {
              var ad = pow(1.0 - bi.angularDamping, dt);
              av.mult(ad, av);
            }
          }
        }

        this.dispatchEvent(World_step_preStepEvent); // Invoke pre-step callbacks

        for (i = 0; i !== N; i++) {
          var bi = bodies[i];

          if (bi.preStep) {
            bi.preStep.call(bi);
          }
        } // Leap frog
        // vnew = v + h*f/m
        // xnew = x + h*vnew


        if (doProfiling) {
          profilingStart = performance.now();
        }

        var stepnumber = this.stepnumber;
        var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
        var quatNormalizeFast = this.quatNormalizeFast;

        for (i = 0; i !== N; i++) {
          bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
        }

        this.clearForces();
        this.broadphase.dirty = true;

        if (doProfiling) {
          profile.integrate = performance.now() - profilingStart;
        } // Update world time


        this.time += dt;
        this.timeFixed += dt;
        this.stepnumber += 1;
        this.dispatchEvent(World_step_postStepEvent); // Invoke post-step callbacks

        for (i = 0; i !== N; i++) {
          var bi = bodies[i];
          var postStep = bi.postStep;

          if (postStep) {
            postStep.call(bi);
          }
        } // Sleeping update


        if (this.allowSleep) {
          for (i = 0; i !== N; i++) {
            bodies[i].sleepTick(this.time);
          }

          World.SLEEPING = true;

          for (i = 0; i !== N; i++) {
            var bi = bodies[i];

            if (bi.type != Body.STATIC && !bi.isSleeping()) {
              World.SLEEPING = false;
              break;
            }
          }
        } else {
          World.SLEEPING = false;
        }
      };

      World.prototype.emitContactEvents = function () {
        var additions = [];
        var removals = [];
        var beginContactEvent = {
          type: 'beginContact',
          bodyA: null,
          bodyB: null
        };
        var endContactEvent = {
          type: 'endContact',
          bodyA: null,
          bodyB: null
        };
        var beginShapeContactEvent = {
          type: 'beginShapeContact',
          bodyA: null,
          bodyB: null,
          shapeA: null,
          shapeB: null
        };
        var endShapeContactEvent = {
          type: 'endShapeContact',
          bodyA: null,
          bodyB: null,
          shapeA: null,
          shapeB: null
        };
        return function () {
          var hasBeginContact = this.hasAnyEventListener('beginContact');
          var hasEndContact = this.hasAnyEventListener('endContact');

          if (hasBeginContact || hasEndContact) {
            this.bodyOverlapKeeper.getDiff(additions, removals);
          }

          if (hasBeginContact) {
            for (var i = 0, l = additions.length; i < l; i += 2) {
              beginContactEvent.bodyA = this.getBodyById(additions[i]);
              beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
              this.dispatchEvent(beginContactEvent);
            }

            beginContactEvent.bodyA = beginContactEvent.bodyB = null;
          }

          if (hasEndContact) {
            for (var i = 0, l = removals.length; i < l; i += 2) {
              endContactEvent.bodyA = this.getBodyById(removals[i]);
              endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
              this.dispatchEvent(endContactEvent);
            }

            endContactEvent.bodyA = endContactEvent.bodyB = null;
          }

          additions.length = removals.length = 0;
          var hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
          var hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

          if (hasBeginShapeContact || hasEndShapeContact) {
            this.shapeOverlapKeeper.getDiff(additions, removals);
          }

          if (hasBeginShapeContact) {
            for (var i = 0, l = additions.length; i < l; i += 2) {
              var shapeA = this.getShapeById(additions[i]);
              var shapeB = this.getShapeById(additions[i + 1]);
              beginShapeContactEvent.shapeA = shapeA;
              beginShapeContactEvent.shapeB = shapeB;
              beginShapeContactEvent.bodyA = shapeA.body;
              beginShapeContactEvent.bodyB = shapeB.body;
              this.dispatchEvent(beginShapeContactEvent);
            }

            beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
          }

          if (hasEndShapeContact) {
            for (var i = 0, l = removals.length; i < l; i += 2) {
              var shapeA = this.getShapeById(removals[i]);
              var shapeB = this.getShapeById(removals[i + 1]);
              endShapeContactEvent.shapeA = shapeA;
              endShapeContactEvent.shapeB = shapeB;
              endShapeContactEvent.bodyA = shapeA.body;
              endShapeContactEvent.bodyB = shapeB.body;
              this.dispatchEvent(endShapeContactEvent);
            }

            endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
          }
        };
      }();
      /**
       * Sets all body forces in the world to zero.
       * @method clearForces
       */


      World.prototype.clearForces = function () {
        var bodies = this.bodies;
        var N = bodies.length;

        for (var i = 0; i !== N; i++) {
          var b = bodies[i],
              force = b.force,
              tau = b.torque;
          b.force.set(0, 0, 0);
          b.torque.set(0, 0, 0);
        }
      };

      var cc_trigger = {
        type: 'cc-trigger',
        event: '',
        selfBody: null,
        otherBody: null,
        selfShape: null,
        otherShape: null
      };
      var cc_collide = {
        type: "cc-collide",
        event: '',
        body: null,
        selfShape: null,
        otherShape: null,
        contacts: null
      };
      var cc_oldContacts = [];

      World.prototype.emitTriggeredEvents = function () {
        if (this.substeps == 0) return;
        var key;
        var data;
        var i = this.triggerDic.getLength();

        while (i--) {
          key = this.triggerDic.getKeyByIndex(i);
          data = this.triggerDic.getDataByKey(key);
          if (data == null) continue;
          var shapeA = data.si;
          var shapeB = data.sj;

          if (this.tm.get(shapeA, shapeB)) {
            cc_trigger.event = 'onTriggerStay';
          } else {
            this.tm.set(shapeA, shapeB, true);
            cc_trigger.event = 'onTriggerEnter';
          }

          cc_trigger.selfShape = shapeA;
          cc_trigger.otherShape = shapeB;
          cc_trigger.selfBody = shapeA.body;
          cc_trigger.otherBody = shapeB.body;
          shapeA.dispatchEvent(cc_trigger);
          cc_trigger.selfShape = shapeB;
          cc_trigger.otherShape = shapeA;
          cc_trigger.selfBody = shapeB.body;
          cc_trigger.otherBody = shapeA.body;
          shapeB.dispatchEvent(cc_trigger);
        }

        i = this.oldTriggerDic.getLength();

        while (i > 0) {
          i--;
          key = this.oldTriggerDic.getKeyByIndex(i);
          if (this.triggerDic.getDataByKey(key) != null) continue;
          data = this.oldTriggerDic.getDataByKey(key);
          if (data == null) continue;
          var shapeA = data.si;
          var shapeB = data.sj;
          this.tm.set(shapeA, shapeB, false);
          if (this.oldTriggerDic.del(shapeA.id, shapeB.id)) i--;
          cc_trigger.event = 'onTriggerExit';
          cc_trigger.selfShape = shapeA;
          cc_trigger.otherShape = shapeB;
          cc_trigger.selfBody = shapeA.body;
          cc_trigger.otherBody = shapeB.body;
          shapeA.dispatchEvent(cc_trigger);
          cc_trigger.selfShape = shapeB;
          cc_trigger.otherShape = shapeA;
          cc_trigger.selfBody = shapeB.body;
          cc_trigger.otherBody = shapeA.body;
          shapeB.dispatchEvent(cc_trigger);
        }

        this.triggerDic.reset();
      };

      World.prototype.emitCollisionEvents = function () {
        if (this.substeps == 0) return;
        var contacts = this.contacts;
        var i = this.contacts.length;

        while (i--) {
          // Current contact
          var c = contacts[i]; // Get current collision indeces

          var si = c.si;
          var sj = c.sj;
          var item = this.contactsDic.get(si.id, sj.id);

          if (item == null) {
            item = this.contactsDic.set(si.id, sj.id, []);
          }

          item.push(c);
        }

        var key;
        var data; // is collision enter or stay

        var i = this.contactsDic.getLength();

        while (i--) {
          key = this.contactsDic.getKeyByIndex(i);
          data = this.contactsDic.getDataByKey(key);
          if (data == null) continue;
          var si = data[0].si;
          var sj = data[0].sj;
          var bi = si.body;
          var bj = sj.body; // Now we know that i and j are in contact. Set collision matrix state		

          if (this.cm.get(bi, bj)) {
            // collision stay
            cc_collide.event = 'onCollisionStay';
          } else {
            this.cm.set(bi, bj, true); // collision enter

            cc_collide.event = 'onCollisionEnter';
          }

          cc_collide.bi = bi;
          cc_collide.contact = data[0];
          cc_collide.contacts = data;
          cc_collide.body = bj;
          cc_collide.selfShape = si;
          cc_collide.otherShape = sj;
          bi.dispatchEvent(cc_collide);
          cc_collide.body = bi;
          cc_collide.selfShape = sj;
          cc_collide.otherShape = si;
          bj.dispatchEvent(cc_collide);
        }

        var oldcontacts = cc_oldContacts;

        for (i = oldcontacts.length; i--;) {
          // Current contact
          var c = oldcontacts[i]; // Get current collision indeces

          var si = c.si;
          var sj = c.sj;

          if (this.oldContactsDic.get(si.id, sj.id) == null) {
            this.oldContactsDic.set(si.id, sj.id, c);
          }
        } // is collision exit


        i = this.oldContactsDic.getLength();

        while (i--) {
          key = this.oldContactsDic.getKeyByIndex(i);

          if (this.contactsDic.getDataByKey(key) == null) {
            data = this.oldContactsDic.getDataByKey(key);
            var si = data.si;
            var sj = data.sj;
            var bi = si.body;
            var bj = sj.body;

            if (this.cm.get(bi, bj)) {
              if (!bi.isSleeping() || !bj.isSleeping()) {
                this.cm.set(bi, bj, false);
                cc_collide.bi = bi;
                cc_collide.contact = data; // collision exit

                cc_collide.event = 'onCollisionExit';
                cc_collide.body = bj;
                cc_collide.selfShape = si;
                cc_collide.otherShape = sj;
                cc_collide.contacts.length = 0;
                cc_collide.contacts.push(data);
                bi.dispatchEvent(cc_collide);
                cc_collide.body = bi;
                cc_collide.selfShape = sj;
                cc_collide.otherShape = si;
                bj.dispatchEvent(cc_collide);
              } else {// not exit, due to sleeping
              }
            }
          }
        }

        this.contactsDic.reset();
        this.oldContactsDic.reset();
        World_step_oldContacts = cc_oldContacts;
        cc_oldContacts = this.contacts.slice();
        this.contacts.length = 0;
      };
    }, {
      "../collision/AABB": 3,
      "../collision/ArrayCollisionMatrix": 4,
      "../collision/NaiveBroadphase": 7,
      "../collision/ObjectCollisionMatrix": 8,
      "../collision/OverlapKeeper": 9,
      "../collision/Ray": 10,
      "../collision/RaycastResult": 11,
      "../equations/ContactEquation": 20,
      "../equations/FrictionEquation": 22,
      "../material/ContactMaterial": 25,
      "../material/Material": 26,
      "../math/Quaternion": 30,
      "../math/Vec3": 32,
      "../objects/Body": 33,
      "../shapes/Shape": 45,
      "../solver/GSSolver": 48,
      "../utils/EventTarget": 51,
      "../utils/TupleDictionary": 54,
      "./Narrowphase": 57
    }]
  }, {}, [2])(2);
});
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXZcXGV4dGVybmFsXFxjYW5ub25cXGNhbm5vbi5qcyJdLCJuYW1lcyI6WyJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiQ0FOTk9OIiwidCIsIm4iLCJyIiwicyIsIm8iLCJ1IiwiYSIsInJlcXVpcmUiLCJpIiwiRXJyb3IiLCJjYWxsIiwibGVuZ3RoIiwiX2RlcmVxXyIsInZlcnNpb24iLCJBQUJCIiwiQXJyYXlDb2xsaXNpb25NYXRyaXgiLCJCb2R5IiwiQm94IiwiQnJvYWRwaGFzZSIsIkNvbnN0cmFpbnQiLCJDb250YWN0RXF1YXRpb24iLCJOYXJyb3dwaGFzZSIsIkNvbmVUd2lzdENvbnN0cmFpbnQiLCJDb250YWN0TWF0ZXJpYWwiLCJDb252ZXhQb2x5aGVkcm9uIiwiQ3lsaW5kZXIiLCJEaXN0YW5jZUNvbnN0cmFpbnQiLCJFcXVhdGlvbiIsIkV2ZW50VGFyZ2V0IiwiRnJpY3Rpb25FcXVhdGlvbiIsIkdTU29sdmVyIiwiR3JpZEJyb2FkcGhhc2UiLCJIZWlnaHRmaWVsZCIsIkhpbmdlQ29uc3RyYWludCIsIkxvY2tDb25zdHJhaW50IiwiTWF0MyIsIk1hdGVyaWFsIiwiTmFpdmVCcm9hZHBoYXNlIiwiT2JqZWN0Q29sbGlzaW9uTWF0cml4IiwiUG9vbCIsIlBhcnRpY2xlIiwiUGxhbmUiLCJQb2ludFRvUG9pbnRDb25zdHJhaW50IiwiUXVhdGVybmlvbiIsIlJheSIsIlJheWNhc3RWZWhpY2xlIiwiUmF5Y2FzdFJlc3VsdCIsIlJpZ2lkVmVoaWNsZSIsIlJvdGF0aW9uYWxFcXVhdGlvbiIsIlJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIiwiU0FQQnJvYWRwaGFzZSIsIlNQSFN5c3RlbSIsIlNoYXBlIiwiU29sdmVyIiwiU3BoZXJlIiwiU3BsaXRTb2x2ZXIiLCJTcHJpbmciLCJUcmFuc2Zvcm0iLCJUcmltZXNoIiwiVmVjMyIsIlZlYzNQb29sIiwiV29ybGQiLCJPY3RyZWUiLCJDTWF0aCIsIlV0aWxzIiwib3B0aW9ucyIsImxvd2VyQm91bmQiLCJjb3B5IiwidXBwZXJCb3VuZCIsInRtcCIsInByb3RvdHlwZSIsInNldEZyb21Qb2ludHMiLCJwb2ludHMiLCJwb3NpdGlvbiIsInF1YXRlcm5pb24iLCJza2luU2l6ZSIsImwiLCJxIiwidm11bHQiLCJwIiwieCIsInkiLCJ6IiwidmFkZCIsImFhYmIiLCJjbG9uZSIsImV4dGVuZCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJvdmVybGFwcyIsImwxIiwidTEiLCJsMiIsInUyIiwib3ZlcmxhcHNYIiwib3ZlcmxhcHNZIiwib3ZlcmxhcHNaIiwidm9sdW1lIiwiY29udGFpbnMiLCJnZXRDb3JuZXJzIiwiYiIsImMiLCJkIiwiZyIsImgiLCJzZXQiLCJ0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycyIsInRvTG9jYWxGcmFtZSIsImZyYW1lIiwidGFyZ2V0IiwiY29ybmVycyIsImNvcm5lciIsInBvaW50VG9Mb2NhbCIsInRvV29ybGRGcmFtZSIsInBvaW50VG9Xb3JsZCIsIm92ZXJsYXBzUmF5IiwicmF5IiwiZGlyRnJhY1giLCJfZGlyZWN0aW9uIiwiZGlyRnJhY1kiLCJkaXJGcmFjWiIsInQxIiwiZnJvbSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0bWluIiwidG1heCIsIm1hdHJpeCIsImdldCIsImoiLCJpbmRleCIsInRlbXAiLCJ2YWx1ZSIsInJlc2V0Iiwic2V0TnVtT2JqZWN0cyIsIndvcmxkIiwidXNlQm91bmRpbmdCb3hlcyIsImRpcnR5IiwiY29sbGlzaW9uUGFpcnMiLCJwMSIsInAyIiwibmVlZEJyb2FkcGhhc2VDb2xsaXNpb24iLCJib2R5QSIsImJvZHlCIiwiY29sbGlzaW9uRmlsdGVyR3JvdXAiLCJjb2xsaXNpb25GaWx0ZXJNYXNrIiwiaGFzVHJpZ2dlciIsInR5cGUiLCJTVEFUSUMiLCJzbGVlcFN0YXRlIiwiU0xFRVBJTkciLCJpbnRlcnNlY3Rpb25UZXN0IiwicGFpcnMxIiwicGFpcnMyIiwiZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UiLCJkb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZSIsIkJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfciIsIkJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfbm9ybWFsIiwiQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19xdWF0IiwiQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yZWxwb3MiLCJ2c3ViIiwiYm91bmRpbmdSYWRpdXNTdW0yIiwicG93IiwiYm91bmRpbmdSYWRpdXMiLCJub3JtMiIsInB1c2giLCJhYWJiTmVlZHNVcGRhdGUiLCJjb21wdXRlQUFCQiIsIkJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAiLCJrZXlzIiwiQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEiLCJCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMiIsIm1ha2VQYWlyc1VuaXF1ZSIsIk4iLCJpZDEiLCJpZCIsImlkMiIsImtleSIsInBvcCIsInBhaXJJbmRleCIsInNldFdvcmxkIiwiYnNjX2Rpc3QiLCJib3VuZGluZ1NwaGVyZUNoZWNrIiwiZGlzdCIsInNoYXBlIiwiYm91bmRpbmdTcGhlcmVSYWRpdXMiLCJhYWJiUXVlcnkiLCJyZXN1bHQiLCJjb25zb2xlIiwid2FybiIsImFhYmJNaW4iLCJhYWJiTWF4IiwibngiLCJueSIsIm56IiwiYXBwbHkiLCJuYmlucyIsImJpbnMiLCJiaW5MZW5ndGhzIiwiY29uc3RydWN0b3IiLCJHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kIiwiR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfYmluUG9zIiwibnVtT2JqZWN0cyIsImJvZGllcyIsInhzdGVwIiwieXN0ZXAiLCJ6c3RlcCIsInhtYXgiLCJ5bWF4Iiwiem1heCIsInhtaW4iLCJ5bWluIiwiem1pbiIsInhtdWx0IiwieW11bHQiLCJ6bXVsdCIsImJpbnNpemVYIiwiYmluc2l6ZVkiLCJiaW5zaXplWiIsImJpblJhZGl1cyIsInNxcnQiLCJ0eXBlcyIsIlNQSEVSRSIsIlBMQU5FIiwiQk9YIiwiQ09NUE9VTkQiLCJDT05WRVhQT0xZSEVEUk9OIiwiTmJpbnMiLCJjZWlsIiwiYWRkQm94VG9CaW5zIiwieDAiLCJ5MCIsInowIiwieDEiLCJ5MSIsInoxIiwiYmkiLCJ4b2ZmMCIsInlvZmYwIiwiem9mZjAiLCJ4b2ZmMSIsInlvZmYxIiwiem9mZjEiLCJ4b2ZmIiwieW9mZiIsInpvZmYiLCJpZHgiLCJzaSIsInJhZGl1cyIsIndvcmxkTm9ybWFsTmVlZHNVcGRhdGUiLCJjb21wdXRlV29ybGROb3JtYWwiLCJwbGFuZU5vcm1hbCIsIndvcmxkTm9ybWFsIiwieHJlc2V0IiwieXJlc2V0IiwienJlc2V0IiwieGkiLCJ5aSIsInppIiwiZG90IiwiYmluTGVuZ3RoIiwiYmluIiwiYmoiLCJ0bXBBQUJCIiwiT3ZlcmxhcEtlZXBlciIsImN1cnJlbnQiLCJwcmV2aW91cyIsImdldEtleSIsInRpY2siLCJ1bnBhY2tBbmRQdXNoIiwiYXJyYXkiLCJnZXREaWZmIiwiYWRkaXRpb25zIiwicmVtb3ZhbHMiLCJhbCIsImJsIiwiZm91bmQiLCJrZXlBIiwia2V5QiIsInRvIiwicHJlY2lzaW9uIiwiY2hlY2tDb2xsaXNpb25SZXNwb25zZSIsInNraXBCYWNrZmFjZXMiLCJtb2RlIiwiQU5ZIiwiaGFzSGl0IiwiY2FsbGJhY2siLCJDTE9TRVNUIiwiQUxMIiwidG1wQXJyYXkiLCJpbnRlcnNlY3RXb3JsZCIsIl91cGRhdGVEaXJlY3Rpb24iLCJnZXRBQUJCIiwiYnJvYWRwaGFzZSIsImludGVyc2VjdEJvZGllcyIsInYxIiwidjIiLCJwb2ludEluVHJpYW5nbGUiLCJ2MCIsImRvdDAwIiwiZG90MDEiLCJkb3QwMiIsImRvdDExIiwiZG90MTIiLCJ2IiwiaW50ZXJzZWN0Qm9keV94aSIsImludGVyc2VjdEJvZHlfcWkiLCJpbnRlcnNlY3RCb2R5IiwiYm9keSIsImNvbGxpc2lvblJlc3BvbnNlIiwicWkiLCJzaGFwZXMiLCJtdWx0Iiwic2hhcGVPcmllbnRhdGlvbnMiLCJzaGFwZU9mZnNldHMiLCJpbnRlcnNlY3RTaGFwZSIsIl9zaG91bGRTdG9wIiwibm9ybWFsaXplIiwicXVhdCIsImRpc3RhbmNlIiwiZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0TWV0aG9kIiwidmVjdG9yIiwibm9ybWFsIiwiaW50ZXJzZWN0UG9pbnQiLCJ0bXBSYXljYXN0UmVzdWx0IiwiaW50ZXJzZWN0Qm94IiwicmVwb3J0ZWRTaGFwZSIsImludGVyc2VjdENvbnZleCIsImNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiIsImludGVyc2VjdFBsYW5lIiwiZGlyZWN0aW9uIiwibGVuIiwicGxhbmVUb0Zyb20iLCJwbGFuZVRvVG8iLCJkaXN0YW5jZVRvIiwibl9kb3RfZGlyIiwiYWJzIiwicGxhbmVQb2ludFRvRnJvbSIsImRpcl9zY2FsZWRfd2l0aF90IiwiaGl0UG9pbnRXb3JsZCIsInNjYWxlIiwicmVwb3J0SW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0Q29udmV4T3B0aW9ucyIsImZhY2VMaXN0Iiwid29ybGRQaWxsYXJPZmZzZXQiLCJpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFJheSIsImludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4IiwiaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbWluTWF4IiwiaW50ZXJzZWN0SGVpZ2h0ZmllbGQiLCJkYXRhIiwidyIsImVsZW1lbnRTaXplIiwibG9jYWxSYXkiLCJwb2ludFRvTG9jYWxGcmFtZSIsImlNaW5YIiwiaU1pblkiLCJpTWF4WCIsImlNYXhZIiwiZ2V0SW5kZXhPZlBvc2l0aW9uIiwiZ2V0QWFiYkF0SW5kZXgiLCJnZXRDb252ZXhUcmlhbmdsZVBpbGxhciIsInBvaW50VG9Xb3JsZEZyYW1lIiwicGlsbGFyT2Zmc2V0IiwicGlsbGFyQ29udmV4IiwiSEVJR0hURklFTEQiLCJSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50IiwiUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwiLCJpbnRlcnNlY3RTcGhlcmUiLCJkZWx0YSIsImludGVyc2VjdGlvblBvaW50IiwibGVycCIsImQxIiwiZDIiLCJpbnRlcnNlY3RDb252ZXhfbm9ybWFsIiwiaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWwiLCJpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdCIsImludGVyc2VjdENvbnZleF92ZWN0b3IiLCJtaW5EaXN0Tm9ybWFsIiwibWluRGlzdEludGVyc2VjdCIsImZhY2VzIiwidmVydGljZXMiLCJub3JtYWxzIiwiZmFjZU5vcm1hbHMiLCJmcm9tVG9EaXN0YW5jZSIsIm1pbkRpc3QiLCJOZmFjZXMiLCJmaSIsImZhY2UiLCJmYWNlTm9ybWFsIiwic2NhbGFyIiwiaW50ZXJzZWN0VHJpbWVzaF9ub3JtYWwiLCJpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uIiwiaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb20iLCJpbnRlcnNlY3RUcmltZXNoX2xvY2FsVG8iLCJpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsIiwiaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50IiwiaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEFBQkIiLCJpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcyIsImludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybSIsImludGVyc2VjdFRyaW1lc2giLCJtZXNoIiwidHJpYW5nbGVzIiwidHJlZVRyYW5zZm9ybSIsImxvY2FsQUFCQiIsImxvY2FsRGlyZWN0aW9uIiwibG9jYWxGcm9tIiwibG9jYWxUbyIsIndvcmxkSW50ZXJzZWN0UG9pbnQiLCJpbmRpY2VzIiwidmVjdG9yVG9Mb2NhbEZyYW1lIiwiZnJvbVRvRGlzdGFuY2VTcXVhcmVkIiwiZGlzdGFuY2VTcXVhcmVkIiwidHJlZSIsInJheVF1ZXJ5IiwidHJpYW5nbGVzSW5kZXgiLCJnZXROb3JtYWwiLCJnZXRWZXJ0ZXgiLCJzcXVhcmVkRGlzdGFuY2UiLCJ2ZWN0b3JUb1dvcmxkRnJhbWUiLCJUUklNRVNIIiwiaGl0RmFjZUluZGV4IiwiaW50ZXJzZWN0IiwicmF5RnJvbVdvcmxkIiwicmF5VG9Xb3JsZCIsImhpdE5vcm1hbFdvcmxkIiwic2V0WmVybyIsImFib3J0IiwiYXhpc0xpc3QiLCJheGlzSW5kZXgiLCJfYWRkQm9keUhhbmRsZXIiLCJfcmVtb3ZlQm9keUhhbmRsZXIiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbnNlcnRpb25Tb3J0WCIsImluc2VydGlvblNvcnRZIiwiaW5zZXJ0aW9uU29ydFoiLCJzb3J0TGlzdCIsImNoZWNrQm91bmRzIiwiYmlQb3MiLCJialBvcyIsInJpIiwicmoiLCJib3VuZEExIiwiYm91bmRBMiIsImJvdW5kQjEiLCJib3VuZEIyIiwiYXV0b0RldGVjdEF4aXMiLCJzdW1YIiwic3VtWDIiLCJzdW1ZIiwic3VtWTIiLCJzdW1aIiwic3VtWjIiLCJpbnZOIiwiY2VudGVyWCIsImNlbnRlclkiLCJjZW50ZXJaIiwidmFyaWFuY2VYIiwidmFyaWFuY2VZIiwidmFyaWFuY2VaIiwiYXhpcyIsImxvd2VyIiwidXBwZXIiLCJDb25lRXF1YXRpb24iLCJtYXhGb3JjZSIsInBpdm90QSIsInBpdm90QiIsImF4aXNBIiwiYXhpc0IiLCJjb2xsaWRlQ29ubmVjdGVkIiwiYW5nbGUiLCJjb25lRXF1YXRpb24iLCJ0d2lzdEVxdWF0aW9uIiwidHdpc3RBbmdsZSIsIm1pbkZvcmNlIiwiZXF1YXRpb25zIiwiQ29uZVR3aXN0Q29uc3RyYWludF91cGRhdGVfdG1wVmVjMSIsIkNvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIiLCJ1cGRhdGUiLCJjb25lIiwidHdpc3QiLCJ0YW5nZW50cyIsIm1heEFuZ2xlIiwiZGVmYXVsdHMiLCJ3YWtlVXBCb2RpZXMiLCJpZENvdW50ZXIiLCJ3YWtlVXAiLCJlbmFibGUiLCJlcXMiLCJlbmFibGVkIiwiZGlzYWJsZSIsImVxIiwiZGlzdGFuY2VFcXVhdGlvbiIsImhhbGZEaXN0IiwibmkiLCJyMSIsInJvdGF0aW9uYWxFcXVhdGlvbjEiLCJyMiIsInJvdGF0aW9uYWxFcXVhdGlvbjIiLCJtb3RvciIsIm1vdG9yRXF1YXRpb24iLCJlbmFibGVNb3RvciIsImRpc2FibGVNb3RvciIsInNldE1vdG9yU3BlZWQiLCJzcGVlZCIsInRhcmdldFZlbG9jaXR5Iiwic2V0TW90b3JNYXhGb3JjZSIsIkhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMSIsIkhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiIsIndvcmxkQXhpc0EiLCJ3b3JsZEF4aXNCIiwiaGFsZldheSIsInhBIiwiVU5JVF9YIiwieEIiLCJ5QSIsIlVOSVRfWSIsInlCIiwiekEiLCJVTklUX1oiLCJ6QiIsInIzIiwicm90YXRpb25hbEVxdWF0aW9uMyIsIkxvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxIiwiTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIiLCJlcXVhdGlvblgiLCJlcXVhdGlvblkiLCJlcXVhdGlvbloiLCJ0bXBWZWMxIiwidG1wVmVjMiIsImNvbXB1dGVCIiwibmoiLCJuaXhuaiIsIm5qeG5pIiwiR0EiLCJqYWNvYmlhbkVsZW1lbnRBIiwiR0IiLCJqYWNvYmlhbkVsZW1lbnRCIiwiY3Jvc3MiLCJyb3RhdGlvbmFsIiwiY29zIiwiR1ciLCJjb21wdXRlR1ciLCJHaU1mIiwiY29tcHV0ZUdpTWYiLCJCIiwic2oiLCJyZXN0aXR1dGlvbiIsIkNvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMSIsIkNvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiIsIkNvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMyIsInJpeG4iLCJyanhuIiwidmkiLCJ2ZWxvY2l0eSIsIndpIiwiYW5ndWxhclZlbG9jaXR5IiwiZm9yY2UiLCJ0YXVpIiwidG9ycXVlIiwidmoiLCJ3aiIsImZqIiwidGF1aiIsInBlbmV0cmF0aW9uVmVjIiwibmVnYXRlIiwic3BhdGlhbCIsImVQbHVzT25lIiwiQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmkiLCJDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiIsIkNvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hpIiwiQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGoiLCJDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwiLCJnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsIiwieGoiLCJyZWxWZWwiLCJnZXRWZWxvY2l0eUF0V29ybGRQb2ludCIsIkphY29iaWFuRWxlbWVudCIsImVwcyIsIm11bHRpcGxpZXIiLCJzZXRTcG9va1BhcmFtcyIsInN0aWZmbmVzcyIsInJlbGF4YXRpb24iLCJ0aW1lU3RlcCIsImsiLCJHcSIsImNvbXB1dGVHcSIsInplcm8iLCJtdWx0aXBseVZlY3RvcnMiLCJjb21wdXRlR1dsYW1iZGEiLCJ2bGFtYmRhIiwid2xhbWJkYSIsImlNZmkiLCJpTWZqIiwiaW52SWlfdm11bHRfdGF1aSIsImludklqX3ZtdWx0X3RhdWoiLCJ0aSIsInRqIiwiaW52TWFzc2kiLCJpbnZNYXNzU29sdmUiLCJpbnZNYXNzaiIsImludkluZXJ0aWFXb3JsZFNvbHZlIiwiY29tcHV0ZUdpTUd0IiwiaW52SWkiLCJpbnZJaiIsImFkZFRvV2xhbWJkYV90ZW1wIiwiYWRkVG9XbGFtYmRhX0dpIiwiYWRkVG9XbGFtYmRhX0dqIiwiYWRkVG9XbGFtYmRhX3JpIiwiYWRkVG9XbGFtYmRhX3JqIiwiYWRkVG9XbGFtYmRhX01kaWFnIiwiYWRkVG9XbGFtYmRhIiwiZGVsdGFsYW1iZGEiLCJhZGRTY2FsZWRWZWN0b3IiLCJjb21wdXRlQyIsInNsaXBGb3JjZSIsIkZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEiLCJGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyIiwicml4dCIsInJqeHQiLCJQSSIsIm0xIiwibTIiLCJmcmljdGlvbiIsImNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyIsImNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24iLCJmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzIiwiZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24iLCJtYXRlcmlhbHMiLCJuYW1lIiwicmFkMmFuZyIsInJhZGlhbjJhbmdsZSIsInJhZCIsInNpbkFyciIsImNhbGN1bGF0ZVNpbkJ5RGlnaXQiLCJkaWdpdCIsInN0ZXAiLCJ0b0ZpeGVkIiwic2luIiwic2luMzYwIiwiX2RpZ2l0Iiwic2luTmF0aXZlIiwiY29zTmF0aXZlIiwiYXRhbjIiLCJfc2luIiwiX2NvcyIsIl9zaW5BcnIiLCJfc2luMzYwIiwiX3Npbk5hdGl2ZSIsIl9jb3NOYXRpdmUiLCJfcmFkaWFuMmFuZ2xlIiwiX2NhbGN1bGF0ZVNpbkJ5RGlnaXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9tb2RlIiwibXVsdGlwbHlFbGVtZW50IiwiZWxlbWVudCIsImVsZW1lbnRzIiwiaWRlbnRpdHkiLCJzZXRUcmFjZSIsInZlYzMiLCJnZXRUcmFjZSIsInNtdWx0IiwibW11bHQiLCJtIiwic3VtIiwic29sdmUiLCJuciIsIm5jIiwiZXFucyIsIm5wIiwia3AiLCJlbHMiLCJpc05hTiIsIkluZmluaXR5IiwidG9TdHJpbmciLCJyb3ciLCJjb2x1bW4iLCJ1bmRlZmluZWQiLCJzb3VyY2UiLCJzZXAiLCJyZXZlcnNlIiwic2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiIsIngyIiwieTIiLCJ6MiIsInh4IiwieHkiLCJ4eiIsInl5IiwieXoiLCJ6eiIsInd4Iiwid3kiLCJ3eiIsInRyYW5zcG9zZSIsIk10IiwiTSIsInRvQXJyYXkiLCJzZXRGcm9tQXhpc0FuZ2xlIiwidG9BeGlzQW5nbGUiLCJ0YXJnZXRBeGlzIiwiYWNvcyIsInNmdl90MSIsInNmdl90MiIsInNldEZyb21WZWN0b3JzIiwiaXNBbnRpcGFyYWxsZWxUbyIsIm5vcm0iLCJRdWF0ZXJuaW9uX211bHRfdmEiLCJRdWF0ZXJuaW9uX211bHRfdmIiLCJRdWF0ZXJuaW9uX211bHRfdmF4dmIiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3IiwiaW52ZXJzZSIsImNvbmp1Z2F0ZSIsImlub3JtMiIsIm5vcm1hbGl6ZUZhc3QiLCJxeCIsInF5IiwicXoiLCJxdyIsIml4IiwiaXkiLCJpeiIsIml3IiwidG9FdWxlciIsIm9yZGVyIiwiaGVhZGluZyIsImF0dGl0dWRlIiwiYmFuayIsInRlc3QiLCJzcXgiLCJzcXkiLCJzcXoiLCJhc2luIiwic2V0RnJvbUV1bGVyIiwiYzEiLCJjMiIsImMzIiwiczEiLCJzMiIsInMzIiwic2xlcnAiLCJ0b1F1YXQiLCJvbWVnYSIsImNvc29tIiwic2lub20iLCJzY2FsZTAiLCJzY2FsZTEiLCJpbnRlZ3JhdGUiLCJkdCIsImFuZ3VsYXJGYWN0b3IiLCJoYWxmX2R0IiwidG1wUXVhdCIsIndvcmxkUG9pbnQiLCJsb2NhbFBvaW50IiwibG9jYWxWZWN0b3IiLCJ3b3JsZFZlY3RvciIsIlpFUk8iLCJ2eCIsInZ5IiwidnoiLCJjcm9zc21hdCIsInVuaXQiLCJuaW52IiwibGVuZ3RoU3F1YXJlZCIsInB4IiwicHkiLCJweiIsInZtdWwiLCJpc1plcm8iLCJWZWMzX3RhbmdlbnRzX24iLCJWZWMzX3RhbmdlbnRzX3JhbmRWZWMiLCJpbm9ybSIsInJhbmRWZWMiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RaZXJvIiwiYW50aXBfbmVnIiwicHJlU3RlcCIsInBvc3RTdGVwIiwicHJldmlvdXNQb3NpdGlvbiIsImludGVycG9sYXRlZFBvc2l0aW9uIiwiaW5pdFBvc2l0aW9uIiwiaW5pdFZlbG9jaXR5IiwibWFzcyIsImludk1hc3MiLCJtYXRlcmlhbCIsImxpbmVhckRhbXBpbmciLCJEWU5BTUlDIiwiYWxsb3dTbGVlcCIsInNsZWVwU3BlZWRMaW1pdCIsInNsZWVwVGltZUxpbWl0IiwidGltZUxhc3RTbGVlcHkiLCJfd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSIsImluaXRRdWF0ZXJuaW9uIiwicHJldmlvdXNRdWF0ZXJuaW9uIiwiaW50ZXJwb2xhdGVkUXVhdGVybmlvbiIsImluaXRBbmd1bGFyVmVsb2NpdHkiLCJpbmVydGlhIiwiaW52SW5lcnRpYSIsImludkluZXJ0aWFXb3JsZCIsImludkluZXJ0aWFTb2x2ZSIsImZpeGVkUm90YXRpb24iLCJ1c2VHcmF2aXR5IiwiYW5ndWxhckRhbXBpbmciLCJsaW5lYXJGYWN0b3IiLCJhZGRTaGFwZSIsInVwZGF0ZU1hc3NQcm9wZXJ0aWVzIiwiQ09MTElERV9FVkVOVF9OQU1FIiwiS0lORU1BVElDIiwiQVdBS0UiLCJTTEVFUFkiLCJ3YWtldXBFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJzbGVlcCIsInNsZWVweUV2ZW50Iiwic2xlZXBFdmVudCIsInNsZWVwVGljayIsInRpbWUiLCJzcGVlZFNxdWFyZWQiLCJzcGVlZExpbWl0U3F1YXJlZCIsInVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMiLCJ0bXBWZWMiLCJfb2Zmc2V0IiwiX29yaWVudGF0aW9uIiwib2Zmc2V0Iiwib3JpZW50YXRpb24iLCJ1cGRhdGVCb3VuZGluZ1JhZGl1cyIsInVwZGF0ZUhhc1RyaWdnZXIiLCJpZFRvU2hhcGVNYXAiLCJyZW1vdmVTaGFwZSIsInVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzIiwiY29tcHV0ZUFBQkJfc2hhcGVBQUJCIiwiYm9keVF1YXQiLCJzaGFwZUFBQkIiLCJjYWxjdWxhdGVXb3JsZEFBQkIiLCJ1aXdfbTEiLCJ1aXdfbTIiLCJ1aXdfbTMiLCJ1cGRhdGVJbmVydGlhV29ybGQiLCJJIiwibTMiLCJCb2R5X2FwcGx5Rm9yY2VfciIsIkJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZSIsImFwcGx5Rm9yY2UiLCJyZWxhdGl2ZVBvaW50Iiwicm90Rm9yY2UiLCJCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlIiwiQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkIiwiYXBwbHlMb2NhbEZvcmNlIiwibG9jYWxGb3JjZSIsIndvcmxkRm9yY2UiLCJyZWxhdGl2ZVBvaW50V29ybGQiLCJCb2R5X2FwcGx5SW1wdWxzZV9yIiwiQm9keV9hcHBseUltcHVsc2VfdmVsbyIsIkJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG8iLCJhcHBseUltcHVsc2UiLCJpbXB1bHNlIiwidmVsbyIsInJvdFZlbG8iLCJCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZSIsIkJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludCIsImFwcGx5TG9jYWxJbXB1bHNlIiwibG9jYWxJbXB1bHNlIiwid29ybGRJbXB1bHNlIiwiQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyIsImhhbGZFeHRlbnRzIiwiZml4ZWQiLCJjYWxjdWxhdGVJbmVydGlhIiwiaW52SV90YXVfZHQiLCJ3cSIsInF1YXROb3JtYWxpemUiLCJxdWF0Tm9ybWFsaXplRmFzdCIsImFuZ3VsYXJWZWxvIiwicG9zIiwiaU1kdCIsInR4IiwidHkiLCJ0eiIsImlzU2xlZXBpbmciLCJpc1NsZWVweSIsImlzQXdha2UiLCJXaGVlbEluZm8iLCJjaGFzc2lzQm9keSIsIndoZWVsSW5mb3MiLCJzbGlkaW5nIiwiaW5kZXhSaWdodEF4aXMiLCJpbmRleEZvcndhcmRBeGlzIiwiaW5kZXhVcEF4aXMiLCJ0bXBWZWMzIiwidG1wVmVjNCIsInRtcFZlYzUiLCJ0bXBWZWM2IiwidG1wUmF5IiwiYWRkV2hlZWwiLCJpbmZvIiwic2V0U3RlZXJpbmdWYWx1ZSIsIndoZWVsSW5kZXgiLCJ3aGVlbCIsInN0ZWVyaW5nIiwiYXBwbHlFbmdpbmVGb3JjZSIsImVuZ2luZUZvcmNlIiwic2V0QnJha2UiLCJicmFrZSIsImFkZFRvV29ybGQiLCJjb25zdHJhaW50cyIsImFkZEJvZHkiLCJ0aGF0IiwicHJlU3RlcENhbGxiYWNrIiwidXBkYXRlVmVoaWNsZSIsImdldFZlaGljbGVBeGlzV29ybGQiLCJudW1XaGVlbHMiLCJ1cGRhdGVXaGVlbFRyYW5zZm9ybSIsImN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIiLCJmb3J3YXJkV29ybGQiLCJjYXN0UmF5IiwidXBkYXRlU3VzcGVuc2lvbiIsInJlbHBvcyIsInN1c3BlbnNpb25Gb3JjZSIsIm1heFN1c3BlbnNpb25Gb3JjZSIsInJheWNhc3RSZXN1bHQiLCJ1cGRhdGVGcmljdGlvbiIsImhpdE5vcm1hbFdvcmxkU2NhbGVkV2l0aFByb2oiLCJmd2QiLCJ2ZWwiLCJjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQiLCJpc0luQ29udGFjdCIsInByb2oiLCJwcm9qMiIsImRlbHRhUm90YXRpb24iLCJ1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkIiwiY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCIsInJvdGF0aW9uIiwiZGVsdGFUaW1lIiwiY2hhc3Npc01hc3MiLCJ3X2l0Iiwic3VzcF9sZW5ndGgiLCJzdXNwZW5zaW9uUmVzdExlbmd0aCIsImN1cnJlbnRfbGVuZ3RoIiwic3VzcGVuc2lvbkxlbmd0aCIsImxlbmd0aF9kaWZmIiwic3VzcGVuc2lvblN0aWZmbmVzcyIsImNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiIsInByb2plY3RlZF9yZWxfdmVsIiwic3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkiLCJzdXNwX2RhbXBpbmciLCJkYW1waW5nQ29tcHJlc3Npb24iLCJkYW1waW5nUmVsYXhhdGlvbiIsInJlbW92ZUZyb21Xb3JsZCIsInJlbW92ZSIsImNhc3RSYXlfcmF5dmVjdG9yIiwiY2FzdFJheV90YXJnZXQiLCJyYXl2ZWN0b3IiLCJ1cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkIiwiZGVwdGgiLCJyYXlsZW4iLCJkaXJlY3Rpb25Xb3JsZCIsInBhcmFtIiwib2xkU3RhdGUiLCJyYXlUZXN0Iiwib2JqZWN0IiwiZ3JvdW5kT2JqZWN0IiwiaGl0RGlzdGFuY2UiLCJtaW5TdXNwZW5zaW9uTGVuZ3RoIiwibWF4U3VzcGVuc2lvblRyYXZlbCIsIm1heFN1c3BlbnNpb25MZW5ndGgiLCJkZW5vbWluYXRvciIsImNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50IiwicHJvalZlbCIsImludiIsImNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCIsImRpcmVjdGlvbkxvY2FsIiwiYXhsZUxvY2FsIiwiYXhsZVdvcmxkIiwidXAiLCJyaWdodCIsInN0ZWVyaW5nT3JuIiwicm90YXRpbmdPcm4iLCJ3b3JsZFRyYW5zZm9ybSIsImRpcmVjdGlvbnMiLCJnZXRXaGVlbFRyYW5zZm9ybVdvcmxkIiwidXBkYXRlRnJpY3Rpb25fc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qIiwidXBkYXRlRnJpY3Rpb25fYXhsZSIsInVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUyIsInNpZGVGcmljdGlvblN0aWZmbmVzczIiLCJzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2oiLCJmb3J3YXJkV1MiLCJheGxlIiwibnVtV2hlZWxzT25Hcm91bmQiLCJzaWRlSW1wdWxzZSIsImZvcndhcmRJbXB1bHNlIiwiYXhsZWkiLCJ3aGVlbFRyYW5zIiwic3VyZk5vcm1hbFdTIiwicmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbCIsInNpZGVGYWN0b3IiLCJmd2RGYWN0b3IiLCJyb2xsaW5nRnJpY3Rpb24iLCJzbGlwSW5mbyIsImRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlIiwibWF4SW1wdWxzZSIsImNhbGNSb2xsaW5nRnJpY3Rpb24iLCJmYWN0b3IiLCJza2lkSW5mbyIsIm1heGltcCIsImZyaWN0aW9uU2xpcCIsIm1heGltcFNpZGUiLCJtYXhpbXBTcXVhcmVkIiwiaW1wdWxzZVNxdWFyZWQiLCJyZWxfcG9zIiwicmVsX3BvczIiLCJzaWRlSW1wIiwicm9sbEluZmx1ZW5jZSIsImNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMSIsImNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMiIsImNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsIiwiYm9keTAiLCJib2R5MSIsImZyaWN0aW9uUG9zV29ybGQiLCJmcmljdGlvbkRpcmVjdGlvbldvcmxkIiwiajEiLCJjb250YWN0UG9zV29ybGQiLCJ2ZWwxIiwidmVsMiIsInZyZWwiLCJkZW5vbTAiLCJjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yIiwiZGVub20xIiwiamFjRGlhZ0FCSW52IiwiY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9yMCIsImNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzAiLCJjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyIsImNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfbSIsInIwIiwiYzAiLCJ2ZWMiLCJyZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEiLCJyZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDIiLCJyZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbCIsInBvczEiLCJib2R5MiIsInBvczIiLCJub3JtYWxMZW5TcXIiLCJyZWxfdmVsIiwiY29udGFjdERhbXBpbmciLCJtYXNzVGVybSIsIndoZWVsQm9kaWVzIiwiY29vcmRpbmF0ZVN5c3RlbSIsImNoYXNzaXNTaGFwZSIsIndoZWVsQXhlcyIsIndoZWVsRm9yY2VzIiwid2hlZWxCb2R5Iiwid29ybGRQb3NpdGlvbiIsImhpbmdlQ29uc3RyYWludCIsIm1vdG9yVGFyZ2V0VmVsb2NpdHkiLCJzZXRXaGVlbEZvcmNlIiwiYXBwbHlXaGVlbEZvcmNlIiwiYm9keVRvcnF1ZSIsImNvbmNhdCIsImFkZENvbnN0cmFpbnQiLCJfdXBkYXRlIiwiYmluZCIsInJlbW92ZUNvbnN0cmFpbnQiLCJ3b3JsZEF4aXMiLCJnZXRXaGVlbFNwZWVkIiwicGFydGljbGVzIiwiZGVuc2l0eSIsInNtb290aGluZ1JhZGl1cyIsInNwZWVkT2ZTb3VuZCIsInZpc2Nvc2l0eSIsInByZXNzdXJlcyIsImRlbnNpdGllcyIsIm5laWdoYm9ycyIsImFkZCIsInBhcnRpY2xlIiwiU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0IiwiZ2V0TmVpZ2hib3JzIiwiUjIiLCJTUEhTeXN0ZW1fdXBkYXRlX2Rpc3QiLCJTUEhTeXN0ZW1fdXBkYXRlX2FfcHJlc3N1cmUiLCJTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYyIsIlNQSFN5c3RlbV91cGRhdGVfZ3JhZFciLCJTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjIiwiU1BIU3lzdGVtX3VwZGF0ZV91IiwiY3MiLCJudW1OZWlnaGJvcnMiLCJ3ZWlnaHQiLCJhX3ByZXNzdXJlIiwiYV92aXNjIiwiZ3JhZFciLCJyX3ZlYyIsIlBpaiIsIm5hYmxhIiwiVmlqIiwibmVpZ2hib3IiLCJncmFkdyIsIm5hYmxhdyIsInJWZWMiLCJyZXN1bHRWZWMiLCJyZXN0TGVuZ3RoIiwiZGFtcGluZyIsImxvY2FsQW5jaG9yQSIsImxvY2FsQW5jaG9yQiIsIndvcmxkQW5jaG9yQSIsInNldFdvcmxkQW5jaG9yQSIsIndvcmxkQW5jaG9yQiIsInNldFdvcmxkQW5jaG9yQiIsImdldFdvcmxkQW5jaG9yQSIsImdldFdvcmxkQW5jaG9yQiIsImFwcGx5Rm9yY2VfciIsImFwcGx5Rm9yY2Vfcl91bml0IiwiYXBwbHlGb3JjZV91IiwiYXBwbHlGb3JjZV9mIiwiYXBwbHlGb3JjZV93b3JsZEFuY2hvckEiLCJhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiIsImFwcGx5Rm9yY2VfcmkiLCJhcHBseUZvcmNlX3JqIiwiYXBwbHlGb3JjZV9yaV94X2YiLCJhcHBseUZvcmNlX3JqX3hfZiIsImFwcGx5Rm9yY2VfdG1wIiwicl91bml0IiwicmlfeF9mIiwicmpfeF9mIiwicmxlbiIsInN1c3BlbnNpb25NYXhMZW5ndGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJpc0Zyb250V2hlZWwiLCJ1cGRhdGVXaGVlbCIsImNoYXNzaXMiLCJwcm9qZWN0IiwidXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uIiwic3giLCJzeSIsInN6IiwiViIsImF4ZXMiLCJjYWxjdWxhdGVMb2NhbEluZXJ0aWEiLCJnZXRTaWRlTm9ybWFscyIsInNpeFRhcmdldFZlY3RvcnMiLCJzaWRlcyIsImV4Iiwid29ybGRDb3JuZXJUZW1wUG9zIiwid29ybGRDb3JuZXJUZW1wTmVnIiwiZm9yRWFjaFdvcmxkQ29ybmVyIiwid29ybGRDb3JuZXJzVGVtcCIsIndjIiwidW5pcXVlQXhlcyIsIndvcmxkVmVydGljZXMiLCJ3b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUiLCJjb21wdXRlTm9ybWFscyIsIndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSIsIndvcmxkRmFjZU5vcm1hbHMiLCJ1bmlxdWVFZGdlcyIsInNsaWNlIiwiY29tcHV0ZUVkZ2VzIiwiY29tcHV0ZUVkZ2VzX3RtcEVkZ2UiLCJudiIsImVkZ2VzIiwiZWRnZSIsIm51bVZlcnRpY2VzIiwiZ2V0RmFjZU5vcm1hbCIsInZlcnRleCIsImVycm9yIiwiY2IiLCJhYiIsImNvbXB1dGVOb3JtYWwiLCJ2YSIsInZiIiwidmMiLCJjYWhfV29ybGROb3JtYWwiLCJjbGlwQWdhaW5zdEh1bGwiLCJwb3NBIiwicXVhdEEiLCJodWxsQiIsInBvc0IiLCJxdWF0QiIsInNlcGFyYXRpbmdOb3JtYWwiLCJtYXhEaXN0IiwiV29ybGROb3JtYWwiLCJodWxsQSIsImN1ck1heERpc3QiLCJjbG9zZXN0RmFjZUIiLCJkbWF4Iiwid29ybGRWZXJ0c0IxIiwicG9seUIiLCJlMCIsIndvcmxkYiIsImNsaXBGYWNlQWdhaW5zdEh1bGwiLCJmc2FfZmFjZUFOb3JtYWxXUzMiLCJmc2FfV29ybGRub3JtYWwxIiwiZnNhX2RlbHRhQyIsImZzYV93b3JsZEVkZ2UwIiwiZnNhX3dvcmxkRWRnZTEiLCJmc2FfQ3Jvc3MiLCJmaW5kU2VwYXJhdGluZ0F4aXMiLCJmYWNlTGlzdEEiLCJmYWNlTGlzdEIiLCJmYWNlQU5vcm1hbFdTMyIsIldvcmxkbm9ybWFsMSIsImRlbHRhQyIsIndvcmxkRWRnZTAiLCJ3b3JsZEVkZ2UxIiwiQ3Jvc3MiLCJkbWluIiwiY3VyUGxhbmVUZXN0cyIsIm51bUZhY2VzQSIsInRlc3RTZXBBeGlzIiwibnVtRmFjZXNCIiwiZTEiLCJtYXhtaW5BIiwibWF4bWluQiIsIm1heEEiLCJtaW5BIiwibWF4QiIsIm1pbkIiLCJkMCIsImNsaV9hYWJibWluIiwiY2xpX2FhYmJtYXgiLCJjb21wdXRlTG9jYWxBQUJCIiwiZ2V0UGxhbmVDb25zdGFudE9mRmFjZSIsImZhY2VfaSIsImNmYWhfZmFjZUFOb3JtYWxXUyIsImNmYWhfZWRnZTAiLCJjZmFoX1dvcmxkRWRnZTAiLCJjZmFoX3dvcmxkUGxhbmVBbm9ybWFsMSIsImNmYWhfcGxhbmVOb3JtYWxXUzEiLCJjZmFoX3dvcmxkQTEiLCJjZmFoX2xvY2FsUGxhbmVOb3JtYWwiLCJjZmFoX3BsYW5lTm9ybWFsV1MiLCJmYWNlQU5vcm1hbFdTIiwiZWRnZTAiLCJXb3JsZEVkZ2UwIiwid29ybGRQbGFuZUFub3JtYWwxIiwicGxhbmVOb3JtYWxXUzEiLCJ3b3JsZEExIiwibG9jYWxQbGFuZU5vcm1hbCIsInBsYW5lTm9ybWFsV1MiLCJ3b3JsZFZlcnRzQjIiLCJwVnR4SW4iLCJwVnR4T3V0IiwiY2xvc2VzdEZhY2VBIiwicG9seUEiLCJjb25uZWN0ZWRGYWNlcyIsIm51bUNvbnRhY3RzIiwibnVtVmVydGljZXNBIiwicmVzIiwicGxhbmVFcVdTMSIsInBsYW5lRXFXUyIsIm90aGVyRmFjZSIsImxvY2FsUGxhbmVFcSIsImNsaXBGYWNlQWdhaW5zdFBsYW5lIiwic2hpZnQiLCJwb2ludCIsImluVmVydGljZXMiLCJvdXRWZXJ0aWNlcyIsInBsYW5lQ29uc3RhbnQiLCJuX2RvdF9maXJzdCIsIm5fZG90X2xhc3QiLCJudW1WZXJ0cyIsImZpcnN0VmVydGV4IiwibGFzdFZlcnRleCIsIm5ld3YiLCJjb21wdXRlV29ybGRWZXJ0aWNlcyIsInZlcnRzIiwid29ybGRWZXJ0cyIsImNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0IiwiYWFiYm1pbiIsImFhYmJtYXgiLCJ3b3JsZFZlcnQiLCJjb21wdXRlV29ybGRGYWNlTm9ybWFscyIsIndvcmxkTm9ybWFscyIsIm1heDIiLCJ0ZW1wV29ybGRWZXJ0ZXgiLCJtaW54IiwibWlueSIsIm1pbnoiLCJtYXh4IiwibWF4eSIsIm1heHoiLCJnZXRBdmVyYWdlUG9pbnRMb2NhbCIsInRyYW5zZm9ybUFsbFBvaW50cyIsIkNvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSIsIkNvbnZleFBvbHloZWRyb25fdlRvUCIsIkNvbnZleFBvbHloZWRyb25fdlRvUG9pbnRJbnNpZGUiLCJwb2ludElzSW5zaWRlIiwicG9zaXRpdmVSZXN1bHQiLCJwb2ludEluc2lkZSIsInZUb1AiLCJ2VG9Qb2ludEluc2lkZSIsInByb2plY3Rfd29ybGRWZXJ0ZXgiLCJwcm9qZWN0X2xvY2FsQXhpcyIsInByb2plY3RfbG9jYWxPcmlnaW4iLCJodWxsIiwid29ybGRWZXJ0ZXgiLCJsb2NhbEF4aXMiLCJsb2NhbE9yaWdpbiIsInZzIiwidmFsIiwicmFkaXVzVG9wIiwicmFkaXVzQm90dG9tIiwiaGVpZ2h0IiwibnVtU2VnbWVudHMiLCJpc0RpclkiLCJoYWxmSCIsInRmIiwiYmYiLCJ0aGV0YSIsImJvdHRvbWZhY2UiLCJ0b3BmYWNlIiwidGhldGFOIiwibWF4VmFsdWUiLCJtaW5WYWx1ZSIsInVwZGF0ZU1pblZhbHVlIiwidXBkYXRlTWF4VmFsdWUiLCJjYWNoZUVuYWJsZWQiLCJfY2FjaGVkUGlsbGFycyIsInNldEhlaWdodFZhbHVlQXRJbmRleCIsImNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIiLCJnZXRSZWN0TWluTWF4IiwiY2xhbXAiLCJmbG9vciIsImdldEhlaWdodEF0X2lkeCIsImdldEhlaWdodEF0X3dlaWdodHMiLCJnZXRIZWlnaHRBdF9hIiwiZ2V0SGVpZ2h0QXRfYiIsImdldEhlaWdodEF0X2MiLCJnZXRUcmlhbmdsZUF0IiwiZWRnZUNsYW1wIiwibG93ZXJEaXN0MiIsInVwcGVyRGlzdDIiLCJnZXRUcmlhbmdsZSIsImdldE5vcm1hbEF0X2EiLCJnZXROb3JtYWxBdF9iIiwiZ2V0Tm9ybWFsQXRfYyIsImdldE5vcm1hbEF0X2UwIiwiZ2V0Tm9ybWFsQXRfZTEiLCJnZXROb3JtYWxBdCIsImdldEhlaWdodEF0IiwiYmFyeWNlbnRyaWNXZWlnaHRzIiwiY3giLCJjeSIsImdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkiLCJnZXRVcHBlclRyaWFuZ2xlIiwiZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIiLCJzZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciIsImNvbnZleCIsIm9mZnNldFJlc3VsdCIsInNldEhlaWdodHNGcm9tSW1hZ2UiLCJpbWFnZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiY29udGV4dCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJ1bnNoaWZ0IiwiUEFSVElDTEUiLCJ0ZW1wTm9ybWFsIiwibWF4VmFsIiwiQ1lMSU5ERVIiLCJGbG9hdDMyQXJyYXkiLCJJbnQxNkFycmF5IiwidXBkYXRlRWRnZXMiLCJ1cGRhdGVOb3JtYWxzIiwidXBkYXRlQUFCQiIsInVwZGF0ZVRyZWUiLCJjb21wdXRlTm9ybWFsc19uIiwidHJpYW5nbGVBQUJCIiwiaTMiLCJfZ2V0VW5zY2FsZWRWZXJ0ZXgiLCJpbnNlcnQiLCJyZW1vdmVFbXB0eU5vZGVzIiwidW5zY2FsZWRBQUJCIiwiZ2V0VHJpYW5nbGVzSW5BQUJCIiwiaXN4IiwiaXN5IiwiaXN6Iiwic2V0U2NhbGUiLCJ3YXNVbmlmb3JtIiwiaXNVbmlmb3JtIiwiaW5kZXhBIiwiaW5kZXhCIiwic3BsaXQiLCJwYXJzZUludCIsImdldEVkZ2VWZXJ0ZXgiLCJlZGdlSW5kZXgiLCJmaXJzdE9yU2Vjb25kIiwidmVydGV4U3RvcmUiLCJ2ZXJ0ZXhJbmRleCIsImdldEVkZ2VWZWN0b3JfdmEiLCJnZXRFZGdlVmVjdG9yX3ZiIiwiZ2V0RWRnZVZlY3RvciIsInZlY3RvclN0b3JlIiwib3V0IiwiZ2V0V29ybGRWZXJ0ZXgiLCJnZXRUcmlhbmdsZVZlcnRpY2VzIiwiY2xpX2FhYmIiLCJjYWxjdWxhdGVXb3JsZEFBQkJfZnJhbWUiLCJjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYiIsImNyZWF0ZVRvcnVzIiwidHViZSIsInJhZGlhbFNlZ21lbnRzIiwidHVidWxhclNlZ21lbnRzIiwiYXJjIiwiaXRlcmF0aW9ucyIsInRvbGVyYW5jZSIsIkdTU29sdmVyX3NvbHZlX2xhbWJkYSIsIkdTU29sdmVyX3NvbHZlX2ludkNzIiwiR1NTb2x2ZXJfc29sdmVfQnMiLCJpdGVyIiwibWF4SXRlciIsInRvbFNxdWFyZWQiLCJOZXEiLCJOYm9kaWVzIiwiaW52QyIsImRlbHRhbGFtYmRhVG90IiwiR1dsYW1iZGEiLCJsYW1iZGFqIiwiaW52Q3MiLCJCcyIsImxhbWJkYSIsImludkR0IiwiYWRkRXF1YXRpb24iLCJyZW1vdmVFcXVhdGlvbiIsInJlbW92ZUFsbEVxdWF0aW9ucyIsInN1YnNvbHZlciIsIm5vZGVzIiwibm9kZVBvb2wiLCJjcmVhdGVOb2RlIiwiU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMiLCJTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlUG9vbCIsIlNwbGl0U29sdmVyX3NvbHZlX2VxcyIsIlNwbGl0U29sdmVyX3NvbHZlX2JkcyIsIlNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQiLCJnZXRVbnZpc2l0ZWROb2RlIiwiTm5vZGVzIiwibm9kZSIsInZpc2l0ZWQiLCJxdWV1ZSIsImJmcyIsInJvb3QiLCJ2aXNpdEZ1bmMiLCJiZHMiLCJjaGlsZCIsImNoaWxkcmVuIiwiTmVxcyIsImR1bW15V29ybGQiLCJzb3J0Iiwic29ydEJ5SWQiLCJsaXN0ZW5lciIsIl9saXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJoYXNFdmVudExpc3RlbmVyIiwiaGFzQW55RXZlbnRMaXN0ZW5lciIsImV2ZW50IiwibGlzdGVuZXJBcnJheSIsIk9jdHJlZU5vZGUiLCJtYXhEZXB0aCIsImVsZW1lbnREYXRhIiwibGV2ZWwiLCJub2RlRGF0YSIsInN1YmRpdmlkZWQiLCJzdWJkaXZpZGUiLCJoYWxmRGlhZ29uYWwiLCJBcnJheSIsIm9iamVjdHMiLCJyZWxlYXNlIiwiTmFyZ3MiLCJhcmd1bWVudHMiLCJjb25zdHJ1Y3RPYmplY3QiLCJyZXNpemUiLCJzaXplIiwiVHVwbGVEaWN0aW9uYXJ5IiwiZGVsIiwiZ2V0TGVuZ3RoIiwiZ2V0S2V5QnlJbmRleCIsImdldERhdGFCeUtleSIsIktleSIsImNvbnRhY3RQb2ludFBvb2wiLCJmcmljdGlvbkVxdWF0aW9uUG9vbCIsImZyaWN0aW9uUmVzdWx0IiwidjNwb29sIiwiY3VycmVudENvbnRhY3RNYXRlcmlhbCIsImVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uIiwiY3JlYXRlQ29udGFjdEVxdWF0aW9uIiwib3ZlcnJpZGVTaGFwZUEiLCJvdmVycmlkZVNoYXBlQiIsImNtIiwibWF0QSIsIm1hdEIiLCJjcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0IiwiY29udGFjdEVxdWF0aW9uIiwib3V0QXJyYXkiLCJzaGFwZUEiLCJzaGFwZUIiLCJtdWciLCJncmF2aXR5IiwicmVkdWNlZE1hc3MiLCJwb29sIiwiYXZlcmFnZU5vcm1hbCIsImF2ZXJhZ2VDb250YWN0UG9pbnRBIiwiYXZlcmFnZUNvbnRhY3RQb2ludEIiLCJjcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlIiwiZjEiLCJmMiIsImludk51bUNvbnRhY3RzIiwidG1wUXVhdDEiLCJ0bXBRdWF0MiIsImdldENvbnRhY3RzIiwib2xkY29udGFjdHMiLCJmcmljdGlvblBvb2wiLCJxaiIsImJvZHlDb250YWN0TWF0ZXJpYWwiLCJnZXRDb250YWN0TWF0ZXJpYWwiLCJqdXN0VGVzdCIsInNoYXBlQ29udGFjdE1hdGVyaWFsIiwiZGVmYXVsdENvbnRhY3RNYXRlcmlhbCIsInJlc29sdmVyIiwicmV0dmFsIiwic2hhcGVPdmVybGFwS2VlcGVyIiwiYm9keU92ZXJsYXBLZWVwZXIiLCJ0cmlnZ2VyRGljIiwib2xkVHJpZ2dlckRpYyIsIm51bVdhcm5pbmdzIiwibWF4V2FybmluZ3MiLCJtc2ciLCJib3hCb3giLCJyc2kiLCJyc2oiLCJjb252ZXhDb252ZXgiLCJib3hDb252ZXgiLCJib3hQYXJ0aWNsZSIsImNvbnZleFBhcnRpY2xlIiwic3BoZXJlU3BoZXJlIiwicGxhbmVUcmltZXNoX25vcm1hbCIsInBsYW5lVHJpbWVzaF9yZWxwb3MiLCJwbGFuZVRyaW1lc2hfcHJvamVjdGVkIiwicGxhbmVUcmltZXNoIiwicGxhbmVTaGFwZSIsInRyaW1lc2hTaGFwZSIsInBsYW5lUG9zIiwidHJpbWVzaFBvcyIsInBsYW5lUXVhdCIsInRyaW1lc2hRdWF0IiwicGxhbmVCb2R5IiwidHJpbWVzaEJvZHkiLCJwcm9qZWN0ZWQiLCJzcGhlcmVUcmltZXNoX25vcm1hbCIsInNwaGVyZVRyaW1lc2hfcmVscG9zIiwic3BoZXJlVHJpbWVzaF9wcm9qZWN0ZWQiLCJzcGhlcmVUcmltZXNoX3YiLCJzcGhlcmVUcmltZXNoX3YyIiwic3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QSIsInNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEIiLCJzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IiLCJzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0Iiwic3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvcyIsInNwaGVyZVRyaW1lc2hfdG1wIiwic3BoZXJlVHJpbWVzaF92YSIsInNwaGVyZVRyaW1lc2hfdmIiLCJzcGhlcmVUcmltZXNoX3ZjIiwic3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkIiLCJzcGhlcmVUcmltZXNoX3RyaWFuZ2xlcyIsInNwaGVyZVRyaW1lc2giLCJzcGhlcmVTaGFwZSIsInNwaGVyZVBvcyIsInNwaGVyZVF1YXQiLCJzcGhlcmVCb2R5IiwiZWRnZVZlcnRleEEiLCJlZGdlVmVydGV4QiIsImVkZ2VWZWN0b3IiLCJlZGdlVmVjdG9yVW5pdCIsImxvY2FsU3BoZXJlUG9zIiwibG9jYWxTcGhlcmVBQUJCIiwic3BoZXJlUmFkaXVzIiwicmFkaXVzU3F1YXJlZCIsInBvc2l0aW9uQWxvbmdFZGdlQiIsInBvc2l0aW9uQWxvbmdFZGdlQSIsInBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSIsInBsYW5lX3RvX3NwaGVyZV9vcnRobyIsInBfc19uaSIsInBfc19yaSIsInBfc19yaiIsInNwaGVyZVBsYW5lIiwicG9pbnRJblBvbHlnb25fZWRnZSIsInBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWwiLCJwb2ludEluUG9seWdvbl92dHAiLCJwb2ludEluUG9seWdvbiIsImVkZ2VfeF9ub3JtYWwiLCJ2ZXJ0ZXhfdG9fcCIsImJveF90b19zcGhlcmUiLCJzcGhlcmVCb3hfbnMiLCJzcGhlcmVCb3hfbnMxIiwic3BoZXJlQm94X25zMiIsInNwaGVyZUJveF9zaWRlcyIsInNwaGVyZUJveF9zcGhlcmVfdG9fY29ybmVyIiwic3BoZXJlQm94X3NpZGVfbnMiLCJzcGhlcmVCb3hfc2lkZV9uczEiLCJzcGhlcmVCb3hfc2lkZV9uczIiLCJzcGhlcmVCb3giLCJSIiwicGVuZXRyYXRpbmdfc2lkZXMiLCJzaWRlX25zIiwic2lkZV9uczEiLCJzaWRlX25zMiIsInNpZGVfaCIsInNpZGVfcGVuZXRyYXRpb25zIiwic2lkZV9kb3QxIiwic2lkZV9kb3QyIiwic2lkZV9kaXN0YW5jZSIsIm5zaWRlcyIsIm5zIiwibnMxIiwibnMyIiwiaDEiLCJoMiIsImRvdDEiLCJkb3QyIiwic3BoZXJlX3RvX2Nvcm5lciIsImVkZ2VUYW5nZW50IiwiZWRnZUNlbnRlciIsIm9ydGhvZ29uYWwiLCJOc2lkZXMiLCJvcnRob25vcm0iLCJ0ZGlzdCIsIm5kaXN0IiwiY29udmV4X3RvX3NwaGVyZSIsInNwaGVyZUNvbnZleF9lZGdlIiwic3BoZXJlQ29udmV4X2VkZ2VVbml0Iiwic3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyIiwic3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyIiwic3BoZXJlQ29udmV4X3dvcmxkTm9ybWFsIiwic3BoZXJlQ29udmV4X3dvcmxkUG9pbnQiLCJzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lIiwic3BoZXJlQ29udmV4X3BlbmV0cmF0aW9uVmVjIiwic3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCIsInNwaGVyZUNvbnZleCIsIndvcmxkQ29ybmVyIiwibmZhY2VzIiwid29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lIiwicGVuZXRyYXRpb24iLCJ3b3JsZFBvaW50VG9TcGhlcmUiLCJmYWNlVmVydHMiLCJOdmVydHMiLCJwZW5ldHJhdGlvblZlYzIiLCJwZW5ldHJhdGlvblNwaGVyZVBvaW50IiwiTmZhY2V2ZXJ0cyIsImVkZ2VVbml0IiwidjFfdG9feGkiLCJ4aV90b19wIiwicGxhbmVCb3hfbm9ybWFsIiwicGxhbmVfdG9fY29ybmVyIiwicGxhbmVCb3giLCJwbGFuZUNvbnZleCIsInBsYW5lQ29udmV4X3YiLCJwbGFuZUNvbnZleF9ub3JtYWwiLCJwbGFuZUNvbnZleF9yZWxwb3MiLCJwbGFuZUNvbnZleF9wcm9qZWN0ZWQiLCJjb252ZXhTaGFwZSIsInBsYW5lUG9zaXRpb24iLCJjb252ZXhQb3NpdGlvbiIsImNvbnZleFF1YXQiLCJjb252ZXhCb2R5IiwiY29udmV4Q29udmV4X3NlcEF4aXMiLCJjb252ZXhDb252ZXhfcSIsInNlcEF4aXMiLCJwYXJ0aWNsZVBsYW5lX25vcm1hbCIsInBhcnRpY2xlUGxhbmVfcmVscG9zIiwicGFydGljbGVQbGFuZV9wcm9qZWN0ZWQiLCJwbGFuZVBhcnRpY2xlIiwicGFydGljbGVTcGhlcmVfbm9ybWFsIiwic3BoZXJlUGFydGljbGUiLCJjcWoiLCJjb252ZXhQYXJ0aWNsZV9sb2NhbCIsImNvbnZleFBhcnRpY2xlX25vcm1hbCIsImNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsIiwiY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSIsImNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWMiLCJwZW5ldHJhdGVkRmFjZUluZGV4IiwicGVuZXRyYXRlZEZhY2VOb3JtYWwiLCJ3b3JsZFBlbmV0cmF0aW9uVmVjIiwibWluUGVuZXRyYXRpb24iLCJudW1EZXRlY3RlZEZhY2VzIiwibG9jYWwiLCJib3hIZWlnaHRmaWVsZCIsImNvbnZleEhlaWdodGZpZWxkIiwiY29udmV4SGVpZ2h0ZmllbGRfdG1wMSIsImNvbnZleEhlaWdodGZpZWxkX3RtcDIiLCJjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdCIsImhmU2hhcGUiLCJjb252ZXhQb3MiLCJoZlBvcyIsImhmUXVhdCIsImhmQm9keSIsImxvY2FsQ29udmV4UG9zIiwibWluTWF4IiwiaW50ZXJzZWN0aW5nIiwic3BoZXJlSGVpZ2h0ZmllbGRfdG1wMSIsInNwaGVyZUhlaWdodGZpZWxkX3RtcDIiLCJzcGhlcmVIZWlnaHRmaWVsZCIsIm51bUNvbnRhY3RzQmVmb3JlIiwiY29udGFjdHMiLCJmcmljdGlvbkVxdWF0aW9ucyIsInF1YXROb3JtYWxpemVTa2lwIiwidGltZUZpeGVkIiwic3RlcG51bWJlciIsImRlZmF1bHRfZHQiLCJuZXh0SWQiLCJzb2x2ZXIiLCJuYXJyb3dwaGFzZSIsImNvbGxpc2lvbk1hdHJpeCIsImNvbGxpc2lvbk1hdHJpeFByZXZpb3VzIiwiY29udGFjdG1hdGVyaWFscyIsImNvbnRhY3RNYXRlcmlhbFRhYmxlIiwiZGVmYXVsdE1hdGVyaWFsIiwiZG9Qcm9maWxpbmciLCJwcm9maWxlIiwibWFrZUNvbnRhY3RDb25zdHJhaW50cyIsImFjY3VtdWxhdG9yIiwic3Vic3lzdGVtcyIsImFkZEJvZHlFdmVudCIsInJlbW92ZUJvZHlFdmVudCIsImlkVG9Cb2R5TWFwIiwic3Vic3RlcHMiLCJ0bSIsImNvbnRhY3RzRGljIiwib2xkQ29udGFjdHNEaWMiLCJ0bXBBQUJCMSIsInRtcEFycmF5MSIsImNvbGxpc2lvbk1hdHJpeFRpY2siLCJyYXljYXN0Q2xvc2VzdCIsInJheWNhc3RBbGwiLCJyYXljYXN0QW55IiwicmVtb3ZlQm9keSIsImdldEJvZHlCeUlkIiwiZ2V0U2hhcGVCeUlkIiwiYWRkTWF0ZXJpYWwiLCJhZGRDb250YWN0TWF0ZXJpYWwiLCJjbWF0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJub3dPZmZzZXQiLCJEYXRlIiwidGltaW5nIiwibmF2aWdhdGlvblN0YXJ0Iiwic3RlcF90bXAxIiwidGltZVNpbmNlTGFzdENhbGxlZCIsIm1heFN1YlN0ZXBzIiwiaW50ZXJuYWxTdGVwIiwiV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50IiwiV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQiLCJXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCIsImNvbnRhY3QiLCJXb3JsZF9zdGVwX29sZENvbnRhY3RzIiwiV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCIsIldvcmxkX3N0ZXBfcDEiLCJXb3JsZF9zdGVwX3AyIiwiV29ybGRfc3RlcF9ndmVjIiwiV29ybGRfc3RlcF92aSIsIldvcmxkX3N0ZXBfdmoiLCJXb3JsZF9zdGVwX3dpIiwiV29ybGRfc3RlcF93aiIsIldvcmxkX3N0ZXBfdDEiLCJXb3JsZF9zdGVwX3QyIiwiV29ybGRfc3RlcF9yaXhuIiwiV29ybGRfc3RlcF9yanhuIiwiV29ybGRfc3RlcF9zdGVwX3EiLCJXb3JsZF9zdGVwX3N0ZXBfdyIsIldvcmxkX3N0ZXBfc3RlcF93cSIsInByb2ZpbGluZ1N0YXJ0IiwiZ25vcm0iLCJneCIsImd5IiwiZ3oiLCJOc3Vic3lzdGVtcyIsIk5jb25zdHJhaW50cyIsIk5vbGRDb250YWN0cyIsIk5vbGRGcmljdGlvbkVxdWF0aW9ucyIsIm5jb250YWN0cyIsInNwZWVkU3F1YXJlZEIiLCJzcGVlZExpbWl0U3F1YXJlZEIiLCJzcGVlZFNxdWFyZWRBIiwic3BlZWRMaW1pdFNxdWFyZWRBIiwiZW1pdENvbnRhY3RFdmVudHMiLCJsZCIsImF2IiwiYWQiLCJjbGVhckZvcmNlcyIsImJlZ2luQ29udGFjdEV2ZW50IiwiZW5kQ29udGFjdEV2ZW50IiwiYmVnaW5TaGFwZUNvbnRhY3RFdmVudCIsImVuZFNoYXBlQ29udGFjdEV2ZW50IiwiaGFzQmVnaW5Db250YWN0IiwiaGFzRW5kQ29udGFjdCIsImhhc0JlZ2luU2hhcGVDb250YWN0IiwiaGFzRW5kU2hhcGVDb250YWN0IiwidGF1IiwiY2NfdHJpZ2dlciIsInNlbGZCb2R5Iiwib3RoZXJCb2R5Iiwic2VsZlNoYXBlIiwib3RoZXJTaGFwZSIsImNjX2NvbGxpZGUiLCJjY19vbGRDb250YWN0cyIsImVtaXRUcmlnZ2VyZWRFdmVudHMiLCJlbWl0Q29sbGlzaW9uRXZlbnRzIiwiaXRlbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFBQyxNQUFHLFlBQVUsT0FBT0MsT0FBakIsSUFBMEIsZUFBYSxPQUFPQyxNQUFqRCxFQUF3REEsTUFBTSxDQUFDRCxPQUFQLEdBQWVELENBQUMsRUFBaEIsQ0FBeEQsS0FBZ0YsSUFBRyxjQUFZLE9BQU9HLE1BQW5CLElBQTJCQSxNQUFNLENBQUNDLEdBQXJDLEVBQXlDRCxNQUFNLENBQUMsRUFBRCxFQUFJSCxDQUFKLENBQU4sQ0FBekMsS0FBMEQ7QUFBQyxRQUFJSyxDQUFKO0FBQU0sbUJBQWEsT0FBT0MsTUFBcEIsR0FBMkJELENBQUMsR0FBQ0MsTUFBN0IsR0FBb0MsZUFBYSxPQUFPQyxNQUFwQixHQUEyQkYsQ0FBQyxHQUFDRSxNQUE3QixHQUFvQyxlQUFhLE9BQU9DLElBQXBCLEtBQTJCSCxDQUFDLEdBQUNHLElBQTdCLENBQXhFLEVBQTJHSCxDQUFDLENBQUNJLE1BQUYsR0FBU1QsQ0FBQyxFQUFySDtBQUF3SDtBQUFDLENBQXRSLENBQXVSLFlBQVU7QUFBQyxNQUFJRyxNQUFKLEVBQVdELE1BQVgsRUFBa0JELE9BQWxCO0FBQTBCLFNBQVEsU0FBU0QsQ0FBVCxDQUFXVSxDQUFYLEVBQWFDLENBQWIsRUFBZUMsQ0FBZixFQUFpQjtBQUFDLGFBQVNDLENBQVQsQ0FBV0MsQ0FBWCxFQUFhQyxDQUFiLEVBQWU7QUFBQyxVQUFHLENBQUNKLENBQUMs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LEdBQUd2QixJQUFOLElBQWNHLEtBQWYsQ0FMYjs7QUFPQSxjQUFJc0IsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSTdDLEVBQWIsRUFBaUI7QUFBRTZDLFlBQUFBLEtBQUssR0FBRzdDLEVBQUUsR0FBRyxDQUFiO0FBQWlCOztBQUN2RSxjQUFJOEMsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSTdDLEVBQWIsRUFBaUI7QUFBRTZDLFlBQUFBLEtBQUssR0FBRzdDLEVBQUUsR0FBRyxDQUFiO0FBQWlCOztBQUN2RSxjQUFJOEMsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSTdDLEVBQWIsRUFBaUI7QUFBRTZDLFlBQUFBLEtBQUssR0FBRzdDLEVBQUUsR0FBRyxDQUFiO0FBQWlCOztBQUN2RSxjQUFJOEMsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSWhELEVBQWIsRUFBaUI7QUFBRWdELFlBQUFBLEtBQUssR0FBR2hELEVBQUUsR0FBRyxDQUFiO0FBQWlCOztBQUN2RSxjQUFJaUQsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSWhELEVBQWIsRUFBaUI7QUFBRWdELFlBQUFBLEtBQUssR0FBR2hELEVBQUUsR0FBRyxDQUFiO0FBQWlCOztBQUN2RSxjQUFJaUQsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFQSxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUFZLFdBQTdCLE1BQW1DLElBQUlBLEtBQUssSUFBSWhELEVBQWIsRUFBaUI7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QVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FGSixFQUdJLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENBQVM7QUFBRW9ELFlBQUFBLFVBQVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FISixFQUlJLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENBQVM7QUFBRW9ELFlBQUFBLFVBQVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FKSixFQUtJLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENBQVM7QUFBRW9ELFlBQUFBLFVBQVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FMSixFQU1JLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENBQVM7QUFBRW9ELFlBQUFBLFVBQVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FOSixFQU9JLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENBQVM7QUFBRW9ELFlBQUFBLFVBQVUsRUFBRSxJQUFJUCxJQUFKLENBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiO0FBQWQsV0FBVDtBQUFSLFNBQWYsQ0FQSixFQVFJLElBQUlzNEMsVUFBSixDQUFlO0FBQUU3MkMsVUFBQUEsSUFBSSxFQUFFLElBQUl0RSxJQUFKLENB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QUFvQixDQUFyQjtBQUF1QiwyQ0FBb0MsQ0FBM0Q7QUFBNkQsc0NBQStCLENBQTVGO0FBQThGLDRDQUFxQyxDQUFuSTtBQUFxSSxvQ0FBNkIsQ0FBbEs7QUFBb0ssMEJBQW1CLEVBQXZMO0FBQTBMLG9DQUE2QixFQUF2TjtBQUEwTixzQ0FBK0IsRUFBelA7QUFBNFAsdUNBQWdDLEVBQTVSO0FBQStSLHFDQUE4QixFQUE3VDtBQUFnVSw4QkFBdUIsRUFBdlY7QUFBMFYsNEJBQXFCLEVBQS9XO0FBQWtYLHNCQUFlLEVBQWpZO0FBQW9ZLHlCQUFrQixFQUF0WjtBQUF5Wix5QkFBa0IsRUFBM2E7QUFBOGEsNEJBQXFCLEVBQW5jO0FBQXNjLDhCQUF1QixFQUE3ZDtBQUFnZSxrQ0FBMkIsRUFBM2Y7QUFBOGYsdUJBQWdCO0FBQTlnQixLQXp1QytTO0FBOTdhNGEsR0FBelosRUF1cWRrTixFQXZxZGxOLEVBdXFkcU4sQ0FBQyxDQUFELENBdnFkck4sRUF3cWRuVSxDQXhxZG1VLENBQVA7QUF5cWQ1VCxDQXpxZEEsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFR1ZSwgMjEgSnVsIDIwMjAgMDI6NDI6MTIgR01UXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgY2Fubm9uLmpzIEF1dGhvcnNcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LFxyXG4gKiBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLkNBTk5PTj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwibmFtZVwiOiBcIkBjb2Nvcy9jYW5ub25cIixcclxuICBcInZlcnNpb25cIjogXCIxLjEuMS1leHAuM1wiLFxyXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpZ2h0d2VpZ2h0IDNEIHBoeXNpY3MgZW5naW5lIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cIixcclxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvY29zLWNyZWF0b3IvY2Fubm9uLmpzXCIsXHJcbiAgXCJhdXRob3JcIjogXCJTdGVmYW4gSGVkbWFuIDxzY2h0ZXBwZUBnbWFpbC5jb20+IChodHRwOi8vc3RlZmZlLnNlKSwgSmF5Y2VMYWlcIixcclxuICBcImtleXdvcmRzXCI6IFtcclxuICAgIFwiY2Fubm9uLmpzXCIsXHJcbiAgICBcImNvY29zXCIsXHJcbiAgICBcImNyZWF0b3JcIixcclxuICAgIFwicGh5c2ljc1wiLFxyXG4gICAgXCJlbmdpbmVcIixcclxuICAgIFwiM2RcIlxyXG4gIF0sXHJcbiAgXCJzY3JpcHRzXCI6IHtcclxuICAgIFwiYnVpbGRcIjpcImdydW50ICYmIG5wbSBydW4gcHJlcHJvY2VzcyAmJiBncnVudCBhZGRMaWNlbnNlICYmIGdydW50IGFkZERhdGVcIixcclxuICAgIFwicHJlcHJvY2Vzc1wiOlwibm9kZSBub2RlX21vZHVsZXMvdWdsaWZ5LWpzL2Jpbi91Z2xpZnlqcyBidWlsZC9jYW5ub24uanMgLW8gYnVpbGQvY2Fubm9uLm1pbi5qcyAtYyAtbVwiXHJcbiAgfSxcclxuICBcIm1haW5cIjogXCIuL2J1aWxkL2Nhbm5vbi5taW4uanNcIixcclxuICBcImVuZ2luZXNcIjoge1xyXG4gICAgXCJub2RlXCI6IFwiKlwiXHJcbiAgfSxcclxuICBcInJlcG9zaXRvcnlcIjoge1xyXG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXHJcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jb2Nvcy1jcmVhdG9yL2Nhbm5vbi5qcy5naXRcIlxyXG4gIH0sXHJcbiAgXCJidWdzXCI6IHtcclxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvY29zLWNyZWF0b3IvY2Fubm9uLmpzL2lzc3Vlc1wiXHJcbiAgfSxcclxuICBcImxpY2Vuc2VzXCI6IFtcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcclxuICAgIH1cclxuICBdLFxyXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcclxuICAgIFwianNoaW50XCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcInVnbGlmeS1qc1wiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJub2RldW5pdFwiOiBcIl4wLjkuMFwiLFxyXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxyXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjEuMVwiLFxyXG4gICAgXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6IFwiXjAuNC4xXCIsXHJcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwifjAuMS4zXCIsXHJcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwiXjAuNS4xXCIsXHJcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJeMi4xLjRcIixcclxuICAgIFwiZ3J1bnQtY29udHJpYi15dWlkb2NcIjogXCJeMC41LjJcIixcclxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIipcIlxyXG4gIH0sXHJcbiAgXCJkZXBlbmRlbmNpZXNcIjoge31cclxufVxyXG5cclxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIEV4cG9ydCBjbGFzc2VzXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxyXG5cclxuICAgIEFBQkIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQUFCQicpLFxyXG4gICAgQXJyYXlDb2xsaXNpb25NYXRyaXggOiAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeCcpLFxyXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxyXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9Cb3gnKSxcclxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxyXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcclxuICAgIENvbnRhY3RFcXVhdGlvbiA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyksXHJcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvTmFycm93cGhhc2UnKSxcclxuICAgIENvbmVUd2lzdENvbnN0cmFpbnQgOiAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25lVHdpc3RDb25zdHJhaW50JyksXHJcbiAgICBDb250YWN0TWF0ZXJpYWwgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyksXHJcbiAgICBDb252ZXhQb2x5aGVkcm9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcclxuICAgIEN5bGluZGVyIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ3lsaW5kZXInKSxcclxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcclxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcclxuICAgIEV2ZW50VGFyZ2V0IDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9FdmVudFRhcmdldCcpLFxyXG4gICAgRnJpY3Rpb25FcXVhdGlvbiA6ICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyksXHJcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXHJcbiAgICBHcmlkQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXHJcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXHJcbiAgICBIaW5nZUNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50JyksXHJcbiAgICBMb2NrQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKSxcclxuICAgIE1hdDMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL01hdDMnKSxcclxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxyXG4gICAgTmFpdmVCcm9hZHBoYXNlIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKSxcclxuICAgIE9iamVjdENvbGxpc2lvbk1hdHJpeCA6ICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4JyksXHJcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxyXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxyXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QbGFuZScpLFxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludCA6ICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcclxuICAgIFF1YXRlcm5pb24gOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1F1YXRlcm5pb24nKSxcclxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXHJcbiAgICBSYXljYXN0VmVoaWNsZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxyXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXHJcbiAgICBSaWdpZFZlaGljbGUgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SaWdpZFZlaGljbGUnKSxcclxuICAgIFJvdGF0aW9uYWxFcXVhdGlvbiA6ICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyksXHJcbiAgICBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA6ICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uJyksXHJcbiAgICBTQVBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKSxcclxuICAgIFNQSFN5c3RlbSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NQSFN5c3RlbScpLFxyXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxyXG4gICAgU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9Tb2x2ZXInKSxcclxuICAgIFNwaGVyZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU3BoZXJlJyksXHJcbiAgICBTcGxpdFNvbHZlciA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL1NwbGl0U29sdmVyJyksXHJcbiAgICBTcHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9TcHJpbmcnKSxcclxuICAgIFRyYW5zZm9ybSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1RyYW5zZm9ybScpLFxyXG4gICAgVHJpbWVzaCA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9UcmltZXNoJyksXHJcbiAgICBWZWMzIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0aC9WZWMzJyksXHJcbiAgICBWZWMzUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvVmVjM1Bvb2wnKSxcclxuICAgIFdvcmxkIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi93b3JsZC9Xb3JsZCcpLFxyXG4gICAgT2N0cmVlIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3V0aWxzL09jdHJlZScpLFxyXG4gICAgQ01hdGggOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvQ01hdGgnKSxcclxufTtcclxuXHJcbn0se1wiLi4vcGFja2FnZS5qc29uXCI6MSxcIi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXhcIjo0LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjUsXCIuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZVwiOjYsXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4XCI6OCxcIi4vY29sbGlzaW9uL1JheVwiOjEwLFwiLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjExLFwiLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjEyLFwiLi9jb25zdHJhaW50cy9Db25lVHdpc3RDb25zdHJhaW50XCI6MTMsXCIuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNCxcIi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTUsXCIuL2NvbnN0cmFpbnRzL0hpbmdlQ29uc3RyYWludFwiOjE2LFwiLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOjE3LFwiLi9jb25zdHJhaW50cy9Qb2ludFRvUG9pbnRDb25zdHJhaW50XCI6MTgsXCIuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMCxcIi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjEsXCIuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjIsXCIuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb25cIjoyMyxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6MjQsXCIuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI1LFwiLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI2LFwiLi9tYXRoL0NNYXRoXCI6MjcsXCIuL21hdGgvTWF0M1wiOjI5LFwiLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4vbWF0aC9UcmFuc2Zvcm1cIjozMSxcIi4vbWF0aC9WZWMzXCI6MzIsXCIuL29iamVjdHMvQm9keVwiOjMzLFwiLi9vYmplY3RzL1JheWNhc3RWZWhpY2xlXCI6MzQsXCIuL29iamVjdHMvUmlnaWRWZWhpY2xlXCI6MzUsXCIuL29iamVjdHMvU1BIU3lzdGVtXCI6MzYsXCIuL29iamVjdHMvU3ByaW5nXCI6MzcsXCIuL3NoYXBlcy9Cb3hcIjozOSxcIi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjo0MCxcIi4vc2hhcGVzL0N5bGluZGVyXCI6NDEsXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQyLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MyxcIi4vc2hhcGVzL1BsYW5lXCI6NDQsXCIuL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi9zaGFwZXMvU3BoZXJlXCI6NDYsXCIuL3NoYXBlcy9UcmltZXNoXCI6NDcsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ4LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDksXCIuL3NvbHZlci9TcGxpdFNvbHZlclwiOjUwLFwiLi91dGlscy9FdmVudFRhcmdldFwiOjUxLFwiLi91dGlscy9PY3RyZWVcIjo1MixcIi4vdXRpbHMvUG9vbFwiOjUzLFwiLi91dGlscy9WZWMzUG9vbFwiOjU2LFwiLi93b3JsZC9OYXJyb3dwaGFzZVwiOjU3LFwiLi93b3JsZC9Xb3JsZFwiOjU4fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFBQkI7XHJcblxyXG4vKipcclxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cclxuICogQGNsYXNzIEFBQkJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLnVwcGVyQm91bmRdXHJcbiAqIEBwYXJhbSB7VmVjM30gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxyXG4gKi9cclxuZnVuY3Rpb24gQUFCQihvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxyXG4gICAgICogQHR5cGUge1ZlYzN9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ZXJCb3VuZCA9IG5ldyBWZWMzKCk7XHJcbiAgICBpZihvcHRpb25zLmxvd2VyQm91bmQpe1xyXG4gICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KG9wdGlvbnMubG93ZXJCb3VuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckJvdW5kXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy51cHBlckJvdW5kID0gbmV3IFZlYzMoKTtcclxuICAgIGlmKG9wdGlvbnMudXBwZXJCb3VuZCl7XHJcbiAgICAgICAgdGhpcy51cHBlckJvdW5kLmNvcHkob3B0aW9ucy51cHBlckJvdW5kKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRtcCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cy5cclxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3MuXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBza2luU2l6ZVxyXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgc2VsZiBvYmplY3RcclxuICovXHJcbkFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSl7XHJcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcclxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kLFxyXG4gICAgICAgIHEgPSBxdWF0ZXJuaW9uO1xyXG5cclxuICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcclxuICAgIGwuY29weShwb2ludHNbMF0pO1xyXG4gICAgaWYocSl7XHJcbiAgICAgICAgcS52bXVsdChsLCBsKTtcclxuICAgIH1cclxuICAgIHUuY29weShsKTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XHJcblxyXG4gICAgICAgIGlmKHEpe1xyXG4gICAgICAgICAgICBxLnZtdWx0KHAsIHRtcCk7XHJcbiAgICAgICAgICAgIHAgPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihwLnggPiB1LngpeyB1LnggPSBwLng7IH1cclxuICAgICAgICBpZihwLnggPCBsLngpeyBsLnggPSBwLng7IH1cclxuICAgICAgICBpZihwLnkgPiB1LnkpeyB1LnkgPSBwLnk7IH1cclxuICAgICAgICBpZihwLnkgPCBsLnkpeyBsLnkgPSBwLnk7IH1cclxuICAgICAgICBpZihwLnogPiB1LnopeyB1LnogPSBwLno7IH1cclxuICAgICAgICBpZihwLnogPCBsLnopeyBsLnogPSBwLno7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgb2Zmc2V0XHJcbiAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICBwb3NpdGlvbi52YWRkKGwsIGwpO1xyXG4gICAgICAgIHBvc2l0aW9uLnZhZGQodSwgdSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoc2tpblNpemUpe1xyXG4gICAgICAgIGwueCAtPSBza2luU2l6ZTtcclxuICAgICAgICBsLnkgLT0gc2tpblNpemU7XHJcbiAgICAgICAgbC56IC09IHNraW5TaXplO1xyXG4gICAgICAgIHUueCArPSBza2luU2l6ZTtcclxuICAgICAgICB1LnkgKz0gc2tpblNpemU7XHJcbiAgICAgICAgdS56ICs9IHNraW5TaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHkgYm91bmRzIGZyb20gYW4gQUFCQiB0byB0aGlzIEFBQkJcclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmIgU291cmNlIHRvIGNvcHkgZnJvbVxyXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgdGhpcyBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHlcclxuICovXHJcbkFBQkIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KGFhYmIubG93ZXJCb3VuZCk7XHJcbiAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgYW4gQUFCQlxyXG4gKiBAbWV0aG9kIGNsb25lXHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHRoaXMubG93ZXJCb3VuZC54ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC54KTtcclxuICAgIHRoaXMudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC54KTtcclxuICAgIHRoaXMubG93ZXJCb3VuZC55ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnksIGFhYmIubG93ZXJCb3VuZC55KTtcclxuICAgIHRoaXMudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLnksIGFhYmIudXBwZXJCb3VuZC55KTtcclxuICAgIHRoaXMubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosIGFhYmIubG93ZXJCb3VuZC56KTtcclxuICAgIHRoaXMudXBwZXJCb3VuZC56ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLnosIGFhYmIudXBwZXJCb3VuZC56KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLlxyXG4gKiBAbWV0aG9kIG92ZXJsYXBzXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbkFBQkIucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYWFiYil7XHJcbiAgICB2YXIgbDEgPSB0aGlzLmxvd2VyQm91bmQsXHJcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXHJcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXHJcbiAgICAgICAgdTIgPSBhYWJiLnVwcGVyQm91bmQ7XHJcblxyXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcclxuICAgIC8vICAgICAgfC0tLS0tLS0tLXxcclxuICAgIC8vIHwtLS0tLS0tLXxcclxuICAgIC8vIGwxICAgICAgIHUxXHJcblxyXG4gICAgdmFyIG92ZXJsYXBzWCA9ICgobDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCkgfHwgKGwxLnggPD0gdTIueCAmJiB1Mi54IDw9IHUxLngpKTtcclxuICAgIHZhciBvdmVybGFwc1kgPSAoKGwyLnkgPD0gdTEueSAmJiB1MS55IDw9IHUyLnkpIHx8IChsMS55IDw9IHUyLnkgJiYgdTIueSA8PSB1MS55KSk7XHJcbiAgICB2YXIgb3ZlcmxhcHNaID0gKChsMi56IDw9IHUxLnogJiYgdTEueiA8PSB1Mi56KSB8fCAobDEueiA8PSB1Mi56ICYmIHUyLnogPD0gdTEueikpO1xyXG5cclxuICAgIHJldHVybiBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZICYmIG92ZXJsYXBzWjtcclxufTtcclxuXHJcbi8vIE1vc3RseSBmb3IgZGVidWdnaW5nXHJcbkFBQkIucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcclxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xyXG4gICAgcmV0dXJuICh1LnggLSBsLngpICogKHUueSAtIGwueSkgKiAodS56IC0gbC56KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGlzIEFBQkIuXHJcbiAqIEBtZXRob2QgY29udGFpbnNcclxuICogQHBhcmFtIHtBQUJCfSBhYWJiXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGFhYmIpe1xyXG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUxID0gdGhpcy51cHBlckJvdW5kLFxyXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xyXG5cclxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXHJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XHJcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgLy8gbDEgICAgICAgICAgICAgIHUxXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAobDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCkgJiZcclxuICAgICAgICAobDEueSA8PSBsMi55ICYmIHUxLnkgPj0gdTIueSkgJiZcclxuICAgICAgICAobDEueiA8PSBsMi56ICYmIHUxLnogPj0gdTIueilcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRDb3JuZXJzXHJcbiAqIEBwYXJhbSB7VmVjM30gYVxyXG4gKiBAcGFyYW0ge1ZlYzN9IGJcclxuICogQHBhcmFtIHtWZWMzfSBjXHJcbiAqIEBwYXJhbSB7VmVjM30gZFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGVcclxuICogQHBhcmFtIHtWZWMzfSBmXHJcbiAqIEBwYXJhbSB7VmVjM30gZ1xyXG4gKiBAcGFyYW0ge1ZlYzN9IGhcclxuICovXHJcbkFBQkIucHJvdG90eXBlLmdldENvcm5lcnMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKXtcclxuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XHJcblxyXG4gICAgYS5jb3B5KGwpO1xyXG4gICAgYi5zZXQoIHUueCwgbC55LCBsLnogKTtcclxuICAgIGMuc2V0KCB1LngsIHUueSwgbC56ICk7XHJcbiAgICBkLnNldCggbC54LCB1LnksIHUueiApO1xyXG4gICAgZS5zZXQoIHUueCwgbC55LCB1LnogKTtcclxuICAgIGYuc2V0KCBsLngsIHUueSwgbC56ICk7XHJcbiAgICBnLnNldCggbC54LCBsLnksIHUueiApO1xyXG4gICAgaC5jb3B5KHUpO1xyXG59O1xyXG5cclxudmFyIHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW1xyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKClcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS5cclxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxyXG4gKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcclxuICogQHJldHVybiB7QUFCQn0gVGhlIFwidGFyZ2V0XCIgQUFCQiBvYmplY3QuXHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgdGFyZ2V0KXtcclxuXHJcbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xyXG4gICAgdmFyIGEgPSBjb3JuZXJzWzBdO1xyXG4gICAgdmFyIGIgPSBjb3JuZXJzWzFdO1xyXG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xyXG4gICAgdmFyIGQgPSBjb3JuZXJzWzNdO1xyXG4gICAgdmFyIGUgPSBjb3JuZXJzWzRdO1xyXG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xyXG4gICAgdmFyIGcgPSBjb3JuZXJzWzZdO1xyXG4gICAgdmFyIGggPSBjb3JuZXJzWzddO1xyXG5cclxuICAgIC8vIEdldCBjb3JuZXJzIGluIGN1cnJlbnQgZnJhbWVcclxuICAgIHRoaXMuZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlbSB0byBuZXcgbG9jYWwgZnJhbWVcclxuICAgIGZvcih2YXIgaT0wOyBpICE9PSA4OyBpKyspe1xyXG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xyXG4gICAgICAgIGZyYW1lLnBvaW50VG9Mb2NhbChjb3JuZXIsIGNvcm5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYW4gQUFCQiBpbiB0aGUgZ2xvYmFsIGZyYW1lLlxyXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxyXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXHJcbiAqIEBwYXJhbSAge0FBQkJ9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cclxuICovXHJcbkFBQkIucHJvdG90eXBlLnRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lLCB0YXJnZXQpe1xyXG5cclxuICAgIHZhciBjb3JuZXJzID0gdHJhbnNmb3JtSW50b0ZyYW1lX2Nvcm5lcnM7XHJcbiAgICB2YXIgYSA9IGNvcm5lcnNbMF07XHJcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XHJcbiAgICB2YXIgYyA9IGNvcm5lcnNbMl07XHJcbiAgICB2YXIgZCA9IGNvcm5lcnNbM107XHJcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XHJcbiAgICB2YXIgZiA9IGNvcm5lcnNbNV07XHJcbiAgICB2YXIgZyA9IGNvcm5lcnNbNl07XHJcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XHJcblxyXG4gICAgLy8gR2V0IGNvcm5lcnMgaW4gY3VycmVudCBmcmFtZVxyXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZVxyXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XHJcbiAgICAgICAgZnJhbWUucG9pbnRUb1dvcmxkKGNvcm5lciwgY29ybmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldEZyb21Qb2ludHMoY29ybmVycyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIEFBQkIgaXMgaGl0IGJ5IGEgcmF5LlxyXG4gKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwc1JheSA9IGZ1bmN0aW9uKHJheSl7XHJcbiAgICB2YXIgdCA9IDA7XHJcblxyXG4gICAgLy8gcmF5LmRpcmVjdGlvbiBpcyB1bml0IGRpcmVjdGlvbiB2ZWN0b3Igb2YgcmF5XHJcbiAgICB2YXIgZGlyRnJhY1ggPSAxIC8gcmF5Ll9kaXJlY3Rpb24ueDtcclxuICAgIHZhciBkaXJGcmFjWSA9IDEgLyByYXkuX2RpcmVjdGlvbi55O1xyXG4gICAgdmFyIGRpckZyYWNaID0gMSAvIHJheS5fZGlyZWN0aW9uLno7XHJcblxyXG4gICAgLy8gdGhpcy5sb3dlckJvdW5kIGlzIHRoZSBjb3JuZXIgb2YgQUFCQiB3aXRoIG1pbmltYWwgY29vcmRpbmF0ZXMgLSBsZWZ0IGJvdHRvbSwgcnQgaXMgbWF4aW1hbCBjb3JuZXJcclxuICAgIHZhciB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIHJheS5mcm9tLngpICogZGlyRnJhY1g7XHJcbiAgICB2YXIgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSByYXkuZnJvbS54KSAqIGRpckZyYWNYO1xyXG4gICAgdmFyIHQzID0gKHRoaXMubG93ZXJCb3VuZC55IC0gcmF5LmZyb20ueSkgKiBkaXJGcmFjWTtcclxuICAgIHZhciB0NCA9ICh0aGlzLnVwcGVyQm91bmQueSAtIHJheS5mcm9tLnkpICogZGlyRnJhY1k7XHJcbiAgICB2YXIgdDUgPSAodGhpcy5sb3dlckJvdW5kLnogLSByYXkuZnJvbS56KSAqIGRpckZyYWNaO1xyXG4gICAgdmFyIHQ2ID0gKHRoaXMudXBwZXJCb3VuZC56IC0gcmF5LmZyb20ueikgKiBkaXJGcmFjWjtcclxuXHJcbiAgICAvLyB2YXIgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpKTtcclxuICAgIC8vIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpO1xyXG4gICAgdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSwgTWF0aC5taW4odDUsIHQ2KSk7XHJcbiAgICB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTtcclxuXHJcbiAgICAvLyBpZiB0bWF4IDwgMCwgcmF5IChsaW5lKSBpcyBpbnRlcnNlY3RpbmcgQUFCQiwgYnV0IHdob2xlIEFBQkIgaXMgYmVoaW5nIHVzXHJcbiAgICBpZiAodG1heCA8IDApe1xyXG4gICAgICAgIC8vdCA9IHRtYXg7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRtaW4gPiB0bWF4LCByYXkgZG9lc24ndCBpbnRlcnNlY3QgQUFCQlxyXG4gICAgaWYgKHRtaW4gPiB0bWF4KXtcclxuICAgICAgICAvL3QgPSB0bWF4O1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMixcIi4uL3V0aWxzL1V0aWxzXCI6NTV9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBBcnJheUNvbGxpc2lvbk1hdHJpeDtcclxuXHJcbi8qKlxyXG4gKiBDb2xsaXNpb24gXCJtYXRyaXhcIi4gSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcFxyXG4gKiBAY2xhc3MgQXJyYXlDb2xsaXNpb25NYXRyaXhcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBBcnJheUNvbGxpc2lvbk1hdHJpeCgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXRyaXggc3RvcmFnZVxyXG4gICAgICogQHByb3BlcnR5IG1hdHJpeFxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hdHJpeCA9IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGFuIGVsZW1lbnRcclxuICogQG1ldGhvZCBnZXRcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xyXG4gICAgaSA9IGkuaW5kZXg7XHJcbiAgICBqID0gai5pbmRleDtcclxuICAgIGlmIChqID4gaSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gajtcclxuICAgICAgICBqID0gaTtcclxuICAgICAgICBpID0gdGVtcDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV07XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGFuIGVsZW1lbnRcclxuICogQG1ldGhvZCBzZXRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXHJcbiAqL1xyXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcclxuICAgIGkgPSBpLmluZGV4O1xyXG4gICAgaiA9IGouaW5kZXg7XHJcbiAgICBpZiAoaiA+IGkpIHtcclxuICAgICAgICB2YXIgdGVtcCA9IGo7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgaSA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICB0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV0gPSB2YWx1ZSA/IDEgOiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgYWxsIGVsZW1lbnRzIHRvIHplcm9cclxuICogQG1ldGhvZCByZXNldFxyXG4gKi9cclxuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpPTAsIGw9dGhpcy5tYXRyaXgubGVuZ3RoOyBpIT09bDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhbaV09MDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBtYXggbnVtYmVyIG9mIG9iamVjdHNcclxuICogQG1ldGhvZCBzZXROdW1PYmplY3RzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAqL1xyXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHRoaXMubWF0cml4Lmxlbmd0aCA9IG4qKG4tMSk+PjE7XHJcbn07XHJcblxyXG59LHt9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcbnZhciBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCcm9hZHBoYXNlO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zXHJcbiAqIEBjbGFzcyBCcm9hZHBoYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqL1xyXG5mdW5jdGlvbiBCcm9hZHBoYXNlKCl7XHJcbiAgICAvKipcclxuICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBmb3IgY29sbGlzaW9ucyBpbi5cclxuICAgICogQHByb3BlcnR5IHdvcmxkXHJcbiAgICAqIEB0eXBlIHtXb3JsZH1cclxuICAgICovXHJcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgYnJvYWRwaGFzZSB1c2VzIGJvdW5kaW5nIGJveGVzIGZvciBpbnRlcnNlY3Rpb24gdGVzdCwgZWxzZSBpdCB1c2VzIGJvdW5kaW5nIHNwaGVyZXMuXHJcbiAgICAgKiBAcHJvcGVydHkgdXNlQm91bmRpbmdCb3hlc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBkaXJ0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY29sbGlzaW9uIHBhaXJzIGZyb20gdGhlIHdvcmxkXHJcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpblxyXG4gKiBAcGFyYW0ge0FycmF5fSBwMSBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcclxuICogQHBhcmFtIHtBcnJheX0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXHJcbiAqL1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkLHAxLHAyKXtcclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvblBhaXJzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBCcm9hZFBoYXNlIGNsYXNzIVwiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC5cclxuICogQG1ldGhvZCBuZWVkQnJvYWRwaGFzZUNvbGxpc2lvblxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHJldHVybiB7Ym9vbH1cclxuICovXHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xyXG5cclxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBmaWx0ZXIgbWFza3NcclxuICAgIGlmKCAoYm9keUEuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5Qi5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTAgfHwgKGJvZHlCLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUEuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaGFzIHRyaWdnZXJcclxuICAgIGlmKGJvZHlBLmhhc1RyaWdnZXIgfHwgYm9keUIuaGFzVHJpZ2dlcil7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgdHlwZXNcclxuICAgIGlmKCgoYm9keUEudHlwZSAmIEJvZHkuU1RBVElDKSE9PTAgfHwgYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgJiZcclxuICAgICAgICgoYm9keUIudHlwZSAmIEJvZHkuU1RBVElDKSE9PTAgfHwgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykpIHtcclxuICAgICAgICAvLyBCb3RoIGJvZGllcyBhcmUgc3RhdGljIG9yIHNsZWVwaW5nLiBTa2lwLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgdm9sdW1lcyBvZiB0d28gYm9kaWVzIGludGVyc2VjdC5cclxuICogQG1ldGhvZCBpbnRlcnNlY3Rpb25UZXN0XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge2FycmF5fSBwYWlyczFcclxuICogQHBhcmFtIHthcnJheX0gcGFpcnMyXHJcbiAgKi9cclxuQnJvYWRwaGFzZS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpe1xyXG4gICAgaWYodGhpcy51c2VCb3VuZGluZ0JveGVzKXtcclxuICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBib3VuZGluZyBzcGhlcmVzIG9mIHR3byBib2RpZXMgYXJlIGludGVyc2VjdGluZy5cclxuICogQG1ldGhvZCBkb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxIGJvZHlBIGlzIGFwcGVuZGVkIHRvIHRoaXMgYXJyYXkgaWYgaW50ZXJzZWN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxyXG4gKi9cclxudmFyIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfciA9IG5ldyBWZWMzKCksIC8vIFRlbXAgb2JqZWN0c1xyXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19ub3JtYWwgPSAgbmV3IFZlYzMoKSxcclxuICAgIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcXVhdCA9ICBuZXcgUXVhdGVybmlvbigpLFxyXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yZWxwb3MgID0gIG5ldyBWZWMzKCk7XHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlID0gZnVuY3Rpb24oYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMil7XHJcbiAgICB2YXIgciA9IEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcjtcclxuICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24scik7XHJcbiAgICB2YXIgYm91bmRpbmdSYWRpdXNTdW0yID0gTWF0aC5wb3coYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cywgMik7XHJcbiAgICB2YXIgbm9ybTIgPSByLm5vcm0yKCk7XHJcbiAgICBpZihub3JtMiA8IGJvdW5kaW5nUmFkaXVzU3VtMil7XHJcbiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpO1xyXG4gICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxyXG4gKiBAbWV0aG9kIGRvQm91bmRpbmdCb3hCcm9hZHBoYXNlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczFcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXHJcbiAqL1xyXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZSA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpe1xyXG4gICAgaWYoYm9keUEuYWFiYk5lZWRzVXBkYXRlKXtcclxuICAgICAgICBib2R5QS5jb21wdXRlQUFCQigpO1xyXG4gICAgfVxyXG4gICAgaWYoYm9keUIuYWFiYk5lZWRzVXBkYXRlKXtcclxuICAgICAgICBib2R5Qi5jb21wdXRlQUFCQigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIEFBQkIgLyBBQUJCXHJcbiAgICBpZihib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKXtcclxuICAgICAgICBwYWlyczEucHVzaChib2R5QSk7XHJcbiAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgZHVwbGljYXRlIHBhaXJzIGZyb20gdGhlIHBhaXIgYXJyYXlzLlxyXG4gKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczFcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXHJcbiAqL1xyXG52YXIgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfdGVtcCA9IHsga2V5czpbXSB9LFxyXG4gICAgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEgPSBbXSxcclxuICAgIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyID0gW107XHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLm1ha2VQYWlyc1VuaXF1ZSA9IGZ1bmN0aW9uKHBhaXJzMSxwYWlyczIpe1xyXG4gICAgdmFyIHQgPSBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wLFxyXG4gICAgICAgIHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEsXHJcbiAgICAgICAgcDIgPSBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMixcclxuICAgICAgICBOID0gcGFpcnMxLmxlbmd0aDtcclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgcDFbaV0gPSBwYWlyczFbaV07XHJcbiAgICAgICAgcDJbaV0gPSBwYWlyczJbaV07XHJcbiAgICB9XHJcblxyXG4gICAgcGFpcnMxLmxlbmd0aCA9IDA7XHJcbiAgICBwYWlyczIubGVuZ3RoID0gMDtcclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGlkMSA9IHAxW2ldLmlkLFxyXG4gICAgICAgICAgICBpZDIgPSBwMltpXS5pZDtcclxuICAgICAgICB2YXIga2V5ID0gaWQxIDwgaWQyID8gaWQxK1wiLFwiK2lkMiA6ICBpZDIrXCIsXCIraWQxO1xyXG4gICAgICAgIHRba2V5XSA9IGk7XHJcbiAgICAgICAgdC5rZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PXQua2V5cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGtleSA9IHQua2V5cy5wb3AoKSxcclxuICAgICAgICAgICAgcGFpckluZGV4ID0gdFtrZXldO1xyXG4gICAgICAgIHBhaXJzMS5wdXNoKHAxW3BhaXJJbmRleF0pO1xyXG4gICAgICAgIHBhaXJzMi5wdXNoKHAyW3BhaXJJbmRleF0pO1xyXG4gICAgICAgIGRlbGV0ZSB0W2tleV07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2Fzc2VzXHJcbiAqIEBtZXRob2Qgc2V0V29ybGRcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICovXHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBib3VuZGluZyBzcGhlcmVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cclxuICogQG1ldGhvZCBib3VuZGluZ1NwaGVyZUNoZWNrXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxudmFyIGJzY19kaXN0ID0gbmV3IFZlYzMoKTtcclxuQnJvYWRwaGFzZS5ib3VuZGluZ1NwaGVyZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xyXG4gICAgdmFyIGRpc3QgPSBic2NfZGlzdDtcclxuICAgIGJvZHlBLnBvc2l0aW9uLnZzdWIoYm9keUIucG9zaXRpb24sZGlzdCk7XHJcbiAgICByZXR1cm4gTWF0aC5wb3coYm9keUEuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBib2R5Qi5zaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cywyKSA+IGRpc3Qubm9ybTIoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiB0aGUgQUFCQi5cclxuICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcbkJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xyXG4gICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7XHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MzAsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4uL29iamVjdHMvQm9keVwiOjMzLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDQsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRCcm9hZHBoYXNlO1xyXG5cclxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuL0Jyb2FkcGhhc2UnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcblxyXG4vKipcclxuICogQXhpcyBhbGlnbmVkIHVuaWZvcm0gZ3JpZCBicm9hZHBoYXNlLlxyXG4gKiBAY2xhc3MgR3JpZEJyb2FkcGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcclxuICogQHRvZG8gTmVlZHMgc3VwcG9ydCBmb3IgbW9yZSB0aGFuIGp1c3QgcGxhbmVzIGFuZCBzcGhlcmVzLlxyXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNaW5cclxuICogQHBhcmFtIHtWZWMzfSBhYWJiTWF4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBueCBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnkgTnVtYmVyIG9mIGJveGVzIGFsb25nIHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG56IE51bWJlciBvZiBib3hlcyBhbG9uZyB6XHJcbiAqL1xyXG5mdW5jdGlvbiBHcmlkQnJvYWRwaGFzZShhYWJiTWluLGFhYmJNYXgsbngsbnksbnope1xyXG4gICAgQnJvYWRwaGFzZS5hcHBseSh0aGlzKTtcclxuICAgIHRoaXMubnggPSBueCB8fCAxMDtcclxuICAgIHRoaXMubnkgPSBueSB8fCAxMDtcclxuICAgIHRoaXMubnogPSBueiB8fCAxMDtcclxuICAgIHRoaXMuYWFiYk1pbiA9IGFhYmJNaW4gfHwgbmV3IFZlYzMoMTAwLDEwMCwxMDApO1xyXG4gICAgdGhpcy5hYWJiTWF4ID0gYWFiYk1heCB8fCBuZXcgVmVjMygtMTAwLC0xMDAsLTEwMCk7XHJcblx0dmFyIG5iaW5zID0gdGhpcy5ueCAqIHRoaXMubnkgKiB0aGlzLm56O1xyXG5cdGlmIChuYmlucyA8PSAwKSB7XHJcblx0XHR0aHJvdyBcIkdyaWRCcm9hZHBoYXNlOiBFYWNoIGRpbWVuc2lvbidzIG4gbXVzdCBiZSA+MFwiO1xyXG5cdH1cclxuICAgIHRoaXMuYmlucyA9IFtdO1xyXG5cdHRoaXMuYmluTGVuZ3RocyA9IFtdOyAvL1JhdGhlciB0aGFuIGNvbnRpbnVhbGx5IHJlc2l6aW5nIGFycmF5cyAodGhyYXNoaW5nIHRoZSBtZW1vcnkpLCBqdXN0IHJlY29yZCBsZW5ndGggYW5kIGFsbG93IHRoZW0gdG8gZ3Jvd1xyXG5cdHRoaXMuYmlucy5sZW5ndGggPSBuYmlucztcclxuXHR0aGlzLmJpbkxlbmd0aHMubGVuZ3RoID0gbmJpbnM7XHJcblx0Zm9yICh2YXIgaT0wO2k8bmJpbnM7aSsrKSB7XHJcblx0XHR0aGlzLmJpbnNbaV09W107XHJcblx0XHR0aGlzLmJpbkxlbmd0aHNbaV09MDtcclxuXHR9XHJcbn1cclxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcclxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZEJyb2FkcGhhc2U7XHJcblxyXG4vKipcclxuICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXHJcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxyXG4gKi9cclxudmFyIEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2QgPSBuZXcgVmVjMygpO1xyXG52YXIgR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfYmluUG9zID0gbmV3IFZlYzMoKTtcclxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscGFpcnMxLHBhaXJzMil7XHJcbiAgICB2YXIgTiA9IHdvcmxkLm51bU9iamVjdHMoKSxcclxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XHJcblxyXG4gICAgdmFyIG1heCA9IHRoaXMuYWFiYk1heCxcclxuICAgICAgICBtaW4gPSB0aGlzLmFhYmJNaW4sXHJcbiAgICAgICAgbnggPSB0aGlzLm54LFxyXG4gICAgICAgIG55ID0gdGhpcy5ueSxcclxuICAgICAgICBueiA9IHRoaXMubno7XHJcblxyXG5cdHZhciB4c3RlcCA9IG55Km56O1xyXG5cdHZhciB5c3RlcCA9IG56O1xyXG5cdHZhciB6c3RlcCA9IDE7XHJcblxyXG4gICAgdmFyIHhtYXggPSBtYXgueCxcclxuICAgICAgICB5bWF4ID0gbWF4LnksXHJcbiAgICAgICAgem1heCA9IG1heC56LFxyXG4gICAgICAgIHhtaW4gPSBtaW4ueCxcclxuICAgICAgICB5bWluID0gbWluLnksXHJcbiAgICAgICAgem1pbiA9IG1pbi56O1xyXG5cclxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbiksXHJcbiAgICAgICAgeW11bHQgPSBueSAvICh5bWF4LXltaW4pLFxyXG4gICAgICAgIHptdWx0ID0gbnogLyAoem1heC16bWluKTtcclxuXHJcbiAgICB2YXIgYmluc2l6ZVggPSAoeG1heCAtIHhtaW4pIC8gbngsXHJcbiAgICAgICAgYmluc2l6ZVkgPSAoeW1heCAtIHltaW4pIC8gbnksXHJcbiAgICAgICAgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XHJcblxyXG5cdHZhciBiaW5SYWRpdXMgPSBNYXRoLnNxcnQoYmluc2l6ZVgqYmluc2l6ZVggKyBiaW5zaXplWSpiaW5zaXplWSArIGJpbnNpemVaKmJpbnNpemVaKSAqIDAuNTtcclxuXHJcbiAgICB2YXIgdHlwZXMgPSBTaGFwZS50eXBlcztcclxuICAgIHZhciBTUEhFUkUgPSAgICAgICAgICAgIHR5cGVzLlNQSEVSRSxcclxuICAgICAgICBQTEFORSA9ICAgICAgICAgICAgIHR5cGVzLlBMQU5FLFxyXG4gICAgICAgIEJPWCA9ICAgICAgICAgICAgICAgdHlwZXMuQk9YLFxyXG4gICAgICAgIENPTVBPVU5EID0gICAgICAgICAgdHlwZXMuQ09NUE9VTkQsXHJcbiAgICAgICAgQ09OVkVYUE9MWUhFRFJPTiA9ICB0eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xyXG5cclxuICAgIHZhciBiaW5zPXRoaXMuYmlucyxcclxuXHRcdGJpbkxlbmd0aHM9dGhpcy5iaW5MZW5ndGhzLFxyXG4gICAgICAgIE5iaW5zPXRoaXMuYmlucy5sZW5ndGg7XHJcblxyXG4gICAgLy8gUmVzZXQgYmluc1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcclxuICAgICAgICBiaW5MZW5ndGhzW2ldID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcclxuXHR2YXIgbWluID0gTWF0aC5taW47XHJcblx0dmFyIG1heCA9IE1hdGgubWF4O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRCb3hUb0JpbnMoeDAseTAsejAseDEseTEsejEsYmkpIHtcclxuXHRcdHZhciB4b2ZmMCA9ICgoeDAgLSB4bWluKSAqIHhtdWx0KXwwLFxyXG5cdFx0XHR5b2ZmMCA9ICgoeTAgLSB5bWluKSAqIHltdWx0KXwwLFxyXG5cdFx0XHR6b2ZmMCA9ICgoejAgLSB6bWluKSAqIHptdWx0KXwwLFxyXG5cdFx0XHR4b2ZmMSA9IGNlaWwoKHgxIC0geG1pbikgKiB4bXVsdCksXHJcblx0XHRcdHlvZmYxID0gY2VpbCgoeTEgLSB5bWluKSAqIHltdWx0KSxcclxuXHRcdFx0em9mZjEgPSBjZWlsKCh6MSAtIHptaW4pICogem11bHQpO1xyXG5cclxuXHRcdGlmICh4b2ZmMCA8IDApIHsgeG9mZjAgPSAwOyB9IGVsc2UgaWYgKHhvZmYwID49IG54KSB7IHhvZmYwID0gbnggLSAxOyB9XHJcblx0XHRpZiAoeW9mZjAgPCAwKSB7IHlvZmYwID0gMDsgfSBlbHNlIGlmICh5b2ZmMCA+PSBueSkgeyB5b2ZmMCA9IG55IC0gMTsgfVxyXG5cdFx0aWYgKHpvZmYwIDwgMCkgeyB6b2ZmMCA9IDA7IH0gZWxzZSBpZiAoem9mZjAgPj0gbnopIHsgem9mZjAgPSBueiAtIDE7IH1cclxuXHRcdGlmICh4b2ZmMSA8IDApIHsgeG9mZjEgPSAwOyB9IGVsc2UgaWYgKHhvZmYxID49IG54KSB7IHhvZmYxID0gbnggLSAxOyB9XHJcblx0XHRpZiAoeW9mZjEgPCAwKSB7IHlvZmYxID0gMDsgfSBlbHNlIGlmICh5b2ZmMSA+PSBueSkgeyB5b2ZmMSA9IG55IC0gMTsgfVxyXG5cdFx0aWYgKHpvZmYxIDwgMCkgeyB6b2ZmMSA9IDA7IH0gZWxzZSBpZiAoem9mZjEgPj0gbnopIHsgem9mZjEgPSBueiAtIDE7IH1cclxuXHJcblx0XHR4b2ZmMCAqPSB4c3RlcDtcclxuXHRcdHlvZmYwICo9IHlzdGVwO1xyXG5cdFx0em9mZjAgKj0genN0ZXA7XHJcblx0XHR4b2ZmMSAqPSB4c3RlcDtcclxuXHRcdHlvZmYxICo9IHlzdGVwO1xyXG5cdFx0em9mZjEgKj0genN0ZXA7XHJcblxyXG5cdFx0Zm9yICh2YXIgeG9mZiA9IHhvZmYwOyB4b2ZmIDw9IHhvZmYxOyB4b2ZmICs9IHhzdGVwKSB7XHJcblx0XHRcdGZvciAodmFyIHlvZmYgPSB5b2ZmMDsgeW9mZiA8PSB5b2ZmMTsgeW9mZiArPSB5c3RlcCkge1xyXG5cdFx0XHRcdGZvciAodmFyIHpvZmYgPSB6b2ZmMDsgem9mZiA8PSB6b2ZmMTsgem9mZiArPSB6c3RlcCkge1xyXG5cdFx0XHRcdFx0dmFyIGlkeCA9IHhvZmYreW9mZit6b2ZmO1xyXG5cdFx0XHRcdFx0Ymluc1tpZHhdW2Jpbkxlbmd0aHNbaWR4XSsrXSA9IGJpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgICAvLyBQdXQgYWxsIGJvZGllcyBpbnRvIHRoZSBiaW5zXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgIHZhciBzaSA9IGJpLnNoYXBlO1xyXG5cclxuICAgICAgICBzd2l0Y2goc2kudHlwZSl7XHJcbiAgICAgICAgY2FzZSBTUEhFUkU6XHJcbiAgICAgICAgICAgIC8vIFB1dCBpbiBiaW5cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgb3ZlcmxhcCB3aXRoIG90aGVyIGJpbnNcclxuICAgICAgICAgICAgdmFyIHggPSBiaS5wb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgeSA9IGJpLnBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICB6ID0gYmkucG9zaXRpb24uejtcclxuICAgICAgICAgICAgdmFyIHIgPSBzaS5yYWRpdXM7XHJcblxyXG5cdFx0XHRhZGRCb3hUb0JpbnMoeC1yLCB5LXIsIHotciwgeCtyLCB5K3IsIHorciwgYmkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBQTEFORTpcclxuICAgICAgICAgICAgaWYoc2kud29ybGROb3JtYWxOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBzaS5jb21wdXRlV29ybGROb3JtYWwoYmkucXVhdGVybmlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBsYW5lTm9ybWFsID0gc2kud29ybGROb3JtYWw7XHJcblxyXG5cdFx0XHQvL1JlbGF0aXZlIHBvc2l0aW9uIGZyb20gb3JpZ2luIG9mIHBsYW5lIG9iamVjdCB0byB0aGUgZmlyc3QgYmluXHJcblx0XHRcdC8vSW5jcmVtZW50ZWQgYXMgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBiaW5zXHJcblx0XHRcdHZhciB4cmVzZXQgPSB4bWluICsgYmluc2l6ZVgqMC41IC0gYmkucG9zaXRpb24ueCxcclxuXHRcdFx0XHR5cmVzZXQgPSB5bWluICsgYmluc2l6ZVkqMC41IC0gYmkucG9zaXRpb24ueSxcclxuXHRcdFx0XHR6cmVzZXQgPSB6bWluICsgYmluc2l6ZVoqMC41IC0gYmkucG9zaXRpb24uejtcclxuXHJcbiAgICAgICAgICAgIHZhciBkID0gR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZDtcclxuXHRcdFx0ZC5zZXQoeHJlc2V0LCB5cmVzZXQsIHpyZXNldCk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciB4aSA9IDAsIHhvZmYgPSAwOyB4aSAhPT0gbng7IHhpKyssIHhvZmYgKz0geHN0ZXAsIGQueSA9IHlyZXNldCwgZC54ICs9IGJpbnNpemVYKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgeWkgPSAwLCB5b2ZmID0gMDsgeWkgIT09IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwLCBkLnogPSB6cmVzZXQsIGQueSArPSBiaW5zaXplWSkge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgemkgPSAwLCB6b2ZmID0gMDsgemkgIT09IG56OyB6aSsrLCB6b2ZmICs9IHpzdGVwLCBkLnogKz0gYmluc2l6ZVopIHtcclxuXHRcdFx0XHRcdFx0aWYgKGQuZG90KHBsYW5lTm9ybWFsKSA8IGJpblJhZGl1cykge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XHJcblx0XHRcdFx0XHRcdFx0Ymluc1tpZHhdW2Jpbkxlbmd0aHNbaWR4XSsrXSA9IGJpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG5cdFx0XHRpZiAoYmkuYWFiYk5lZWRzVXBkYXRlKSB7XHJcblx0XHRcdFx0YmkuY29tcHV0ZUFBQkIoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWRkQm94VG9CaW5zKFxyXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC54LFxyXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC55LFxyXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC56LFxyXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC54LFxyXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC55LFxyXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC56LFxyXG5cdFx0XHRcdGJpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGVhY2ggYmluXHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5iaW5zOyBpKyspe1xyXG5cdFx0dmFyIGJpbkxlbmd0aCA9IGJpbkxlbmd0aHNbaV07XHJcblx0XHQvL1NraXAgYmlucyB3aXRoIG5vIHBvdGVudGlhbCBjb2xsaXNpb25zXHJcblx0XHRpZiAoYmluTGVuZ3RoID4gMSkge1xyXG5cdFx0XHR2YXIgYmluID0gYmluc1tpXTtcclxuXHJcblx0XHRcdC8vIERvIE5eMiBicm9hZHBoYXNlIGluc2lkZVxyXG5cdFx0XHRmb3IodmFyIHhpPTA7IHhpIT09YmluTGVuZ3RoOyB4aSsrKXtcclxuXHRcdFx0XHR2YXIgYmkgPSBiaW5beGldO1xyXG5cdFx0XHRcdGZvcih2YXIgeWk9MDsgeWkhPT14aTsgeWkrKyl7XHJcblx0XHRcdFx0XHR2YXIgYmogPSBiaW5beWldO1xyXG5cdFx0XHRcdFx0aWYodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscGFpcnMxLHBhaXJzMik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4vL1x0Zm9yICh2YXIgemkgPSAwLCB6b2ZmPTA7IHppIDwgbno7IHppKyssIHpvZmYrPSB6c3RlcCkge1xyXG4vL1x0XHRjb25zb2xlLmxvZyhcImxheWVyIFwiK3ppKTtcclxuLy9cdFx0Zm9yICh2YXIgeWkgPSAwLCB5b2ZmPTA7IHlpIDwgbnk7IHlpKyssIHlvZmYgKz0geXN0ZXApIHtcclxuLy9cdFx0XHR2YXIgcm93ID0gJyc7XHJcbi8vXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmPTA7IHhpIDwgbng7IHhpKyssIHhvZmYgKz0geHN0ZXApIHtcclxuLy9cdFx0XHRcdHZhciBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XHJcbi8vXHRcdFx0XHRyb3cgKz0gJyAnICsgYmluTGVuZ3Roc1tpZHhdO1xyXG4vL1x0XHRcdH1cclxuLy9cdFx0XHRjb25zb2xlLmxvZyhyb3cpO1xyXG4vL1x0XHR9XHJcbi8vXHR9XHJcblxyXG4gICAgdGhpcy5tYWtlUGFpcnNVbmlxdWUocGFpcnMxLHBhaXJzMik7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuL0Jyb2FkcGhhc2VcIjo1fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xyXG5cclxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuL0Jyb2FkcGhhc2UnKTtcclxudmFyIEFBQkIgPSBfZGVyZXFfKCcuL0FBQkInKTtcclxuXHJcbi8qKlxyXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLCB1c2VkIGluIGxhY2sgb2YgYmV0dGVyIG9uZXMuXHJcbiAqIEBjbGFzcyBOYWl2ZUJyb2FkcGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBkZXNjcmlwdGlvbiBUaGUgbmFpdmUgYnJvYWRwaGFzZSBsb29rcyBhdCBhbGwgcG9zc2libGUgcGFpcnMgd2l0aG91dCByZXN0cmljdGlvbiwgdGhlcmVmb3JlIGl0IGhhcyBjb21wbGV4aXR5IE5eMiAod2hpY2ggaXMgYmFkKVxyXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcclxuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XHJcbn1cclxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XHJcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYWl2ZUJyb2FkcGhhc2U7XHJcblxyXG4vKipcclxuICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXHJcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxyXG4gKi9cclxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkLHBhaXJzMSxwYWlyczIpe1xyXG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcclxuICAgICAgICBuID0gYm9kaWVzLmxlbmd0aCxcclxuICAgICAgICBpLGosYmksYmo7XHJcblxyXG4gICAgLy8gTmFpdmUgTl4yIGZ0dyFcclxuICAgIGZvcihpPTA7IGkhPT1uOyBpKyspe1xyXG4gICAgICAgIGZvcihqPTA7IGohPT1pOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgYmkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGJqID0gYm9kaWVzW2pdO1xyXG5cclxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscGFpcnMxLHBhaXJzMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XHJcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcblxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGIgPSB3b3JsZC5ib2RpZXNbaV07XHJcblxyXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcclxuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVWdseSBoYWNrIHVudGlsIEJvZHkgZ2V0cyBhYWJiXHJcbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbn0se1wiLi9BQUJCXCI6MyxcIi4vQnJvYWRwaGFzZVwiOjV9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RDb2xsaXNpb25NYXRyaXg7XHJcblxyXG4vKipcclxuICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXJcclxuICogQGNsYXNzIE9iamVjdENvbGxpc2lvbk1hdHJpeFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE9iamVjdENvbGxpc2lvbk1hdHJpeCgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXRyaXggc3RvcmFnZVxyXG4gICAgICogQHByb3BlcnR5IG1hdHJpeFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG5cdHRoaXMubWF0cml4ID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGdldFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7TnVtYmVyfSBqXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xyXG5cdGkgPSBpLmlkO1xyXG5cdGogPSBqLmlkO1xyXG4gICAgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG5cdHJldHVybiBpKyctJytqIGluIHRoaXMubWF0cml4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXHJcbiAqL1xyXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XHJcblx0aSA9IGkuaWQ7XHJcblx0aiA9IGouaWQ7XHJcbiAgICBpZiAoaiA+IGkpIHtcclxuICAgICAgICB2YXIgdGVtcCA9IGo7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgaSA9IHRlbXA7XHJcblx0fVxyXG5cdGlmICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5tYXRyaXhbaSsnLScral0gPSB0cnVlO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdGRlbGV0ZSB0aGlzLm1hdHJpeFtpKyctJytqXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogRW1wdHkgdGhlIG1hdHJpeFxyXG4gKiBAbWV0aG9kIHJlc2V0XHJcbiAqL1xyXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5tYXRyaXggPSB7fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgbWF4IG51bWJlciBvZiBvYmplY3RzXHJcbiAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xyXG4gKiBAcGFyYW0ge051bWJlcn0gblxyXG4gKi9cclxuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXROdW1PYmplY3RzID0gZnVuY3Rpb24obikge1xyXG59O1xyXG5cclxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcEtlZXBlcjtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XHJcbiAgICB0aGlzLmN1cnJlbnQgPSBbXTtcclxuICAgIHRoaXMucHJldmlvdXMgPSBbXTtcclxufVxyXG5cclxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oaSwgaikge1xyXG4gICAgaWYgKGogPCBpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChpIDw8IDE2KSB8IGo7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXHJcbiAqL1xyXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqKSB7XHJcbiAgICAvLyBJbnNlcnRpb24gc29ydC4gVGhpcyB3YXkgdGhlIGRpZmYgd2lsbCBoYXZlIGxpbmVhciBjb21wbGV4aXR5LlxyXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xyXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgd2hpbGUoa2V5ID4gY3VycmVudFtpbmRleF0pe1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICB9XHJcbiAgICBpZihrZXkgPT09IGN1cnJlbnRbaW5kZXhdKXtcclxuICAgICAgICByZXR1cm47IC8vIFBhaXIgd2FzIGFscmVhZHkgYWRkZWRcclxuICAgIH1cclxuICAgIGZvcih2YXIgaj1jdXJyZW50Lmxlbmd0aC0xOyBqPj1pbmRleDsgai0tKXtcclxuICAgICAgICBjdXJyZW50W2ogKyAxXSA9IGN1cnJlbnRbal07XHJcbiAgICB9XHJcbiAgICBjdXJyZW50W2luZGV4XSA9IGtleTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHRpY2tcclxuICovXHJcbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0bXAgPSB0aGlzLmN1cnJlbnQ7XHJcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnByZXZpb3VzO1xyXG4gICAgdGhpcy5wcmV2aW91cyA9IHRtcDtcclxuICAgIHRoaXMuY3VycmVudC5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrQW5kUHVzaChhcnJheSwga2V5KXtcclxuICAgIGFycmF5LnB1c2goKGtleSAmIDB4RkZGRjAwMDApID4+IDE2LCBrZXkgJiAweDAwMDBGRkZGKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0RGlmZlxyXG4gKiBAcGFyYW0gIHthcnJheX0gYWRkaXRpb25zXHJcbiAqIEBwYXJhbSAge2FycmF5fSByZW1vdmFsc1xyXG4gKi9cclxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RGlmZiA9IGZ1bmN0aW9uKGFkZGl0aW9ucywgcmVtb3ZhbHMpIHtcclxuICAgIHZhciBhID0gdGhpcy5jdXJyZW50O1xyXG4gICAgdmFyIGIgPSB0aGlzLnByZXZpb3VzO1xyXG4gICAgdmFyIGFsID0gYS5sZW5ndGg7XHJcbiAgICB2YXIgYmwgPSBiLmxlbmd0aDtcclxuXHJcbiAgICB2YXIgaj0wO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGtleUEgPSBhW2ldO1xyXG4gICAgICAgIHdoaWxlKGtleUEgPiBiW2pdKXtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3VuZCA9IGtleUEgPT09IGJbal07XHJcblxyXG4gICAgICAgIGlmKCFmb3VuZCl7XHJcbiAgICAgICAgICAgIHVucGFja0FuZFB1c2goYWRkaXRpb25zLCBrZXlBKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBqID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmw7IGkrKykge1xyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBrZXlCID0gYltpXTtcclxuICAgICAgICB3aGlsZShrZXlCID4gYVtqXSl7XHJcbiAgICAgICAgICAgIGorKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm91bmQgPSBhW2pdID09PSBrZXlCO1xyXG5cclxuICAgICAgICBpZighZm91bmQpe1xyXG4gICAgICAgICAgICB1bnBhY2tBbmRQdXNoKHJlbW92YWxzLCBrZXlCKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbn0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBSYXk7XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcclxudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvbicpO1xyXG52YXIgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xyXG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xyXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XHJcblxyXG4vKipcclxuICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuXHJcbiAqIEBjbGFzcyBSYXlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXHJcbiAqL1xyXG5mdW5jdGlvbiBSYXkoZnJvbSwgdG8pe1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGZyb21cclxuICAgICAqL1xyXG4gICAgdGhpcy5mcm9tID0gZnJvbSA/IGZyb20uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHRvXHJcbiAgICAgKi9cclxuICAgIHRoaXMudG8gPSB0byA/IHRvLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gX2RpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZWNpc2lvbiA9IDAuMDAwMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBSYXkgdG8gdGFrZSAuY29sbGlzaW9uUmVzcG9uc2UgZmxhZ3MgaW50byBhY2NvdW50IG9uIGJvZGllcyBhbmQgc2hhcGVzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcclxuICAgICAqL1xyXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xyXG4gICAgICogQGRlZmF1bHQgLTFcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcclxuICAgICAqIEBkZWZhdWx0IC0xXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIFJheS5BTlksIFJheS5BTEwgb3IgUmF5LkNMT1NFU1QuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LlxyXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2lsbCBiZSBzZXQgdG8gdHJ1ZSBkdXJpbmcgaW50ZXJzZWN0V29ybGQoKSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50LCB1c2VyLXByb3ZpZGVkIHJlc3VsdCBjYWxsYmFjay4gV2lsbCBiZSB1c2VkIGlmIG1vZGUgaXMgUmF5LkFMTC5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbihyZXN1bHQpe307XHJcbn1cclxuUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcclxuXHJcblJheS5DTE9TRVNUID0gMTtcclxuUmF5LkFOWSA9IDI7XHJcblJheS5BTEwgPSA0O1xyXG5cclxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xyXG52YXIgdG1wQXJyYXkgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLlxyXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XHJcbiAgICB0aGlzLnJlc3VsdCA9IG9wdGlvbnMucmVzdWx0IHx8IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcclxuICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9ICEhb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XHJcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAtMTtcclxuICAgIGlmKG9wdGlvbnMuZnJvbSl7XHJcbiAgICAgICAgdGhpcy5mcm9tLmNvcHkob3B0aW9ucy5mcm9tKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMudG8pe1xyXG4gICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTtcclxuICAgIH1cclxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcclxuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xyXG5cclxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcclxuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xyXG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmhhc0hpdDtcclxufTtcclxuXHJcbnZhciB2MSA9IG5ldyBWZWMzKCksXHJcbiAgICB2MiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKlxyXG4gKiBBcyBwZXIgXCJCYXJ5Y2VudHJpYyBUZWNobmlxdWVcIiBhcyBuYW1lZCBoZXJlIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWwgQnV0IHdpdGhvdXQgdGhlIGRpdmlzaW9uXHJcbiAqL1xyXG5SYXkucG9pbnRJblRyaWFuZ2xlID0gcG9pbnRJblRyaWFuZ2xlO1xyXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUocCwgYSwgYiwgYykge1xyXG4gICAgYy52c3ViKGEsdjApO1xyXG4gICAgYi52c3ViKGEsdjEpO1xyXG4gICAgcC52c3ViKGEsdjIpO1xyXG5cclxuICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcclxuICAgIHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcclxuICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcclxuXHJcbiAgICB2YXIgdSx2O1xyXG5cclxuICAgIHJldHVybiAgKCAodSA9IGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSA+PSAwICkgJiZcclxuICAgICAgICAgICAgKCAodiA9IGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSA+PSAwICkgJiZcclxuICAgICAgICAgICAgKCB1ICsgdiA8ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKSApO1xyXG59XHJcblxyXG4vKipcclxuICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxyXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZHlcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cclxuICovXHJcbnZhciBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdEJvZHlfcWkgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XHJcbiAgICBpZihyZXN1bHQpe1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XHJcblxyXG4gICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCh0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTAgfHwgKGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4aSA9IGludGVyc2VjdEJvZHlfeGk7XHJcbiAgICB2YXIgcWkgPSBpbnRlcnNlY3RCb2R5X3FpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XHJcblxyXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcclxuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJvZHkucXVhdGVybmlvbi5tdWx0KGJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTtcclxuICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTtcclxuICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShcclxuICAgICAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgICAgIHFpLFxyXG4gICAgICAgICAgICB4aSxcclxuICAgICAgICAgICAgYm9keVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAoYm9kaWVzLCByZXN1bHQpIHtcclxuICAgIGlmKHJlc3VsdCl7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBsOyBpICsrICkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIF91cGRhdGVEaXJlY3Rpb25cclxuICovXHJcblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnRvLnZzdWIodGhpcy5mcm9tLCB0aGlzLl9kaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqL1xyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG5cclxuXHJcbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxyXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgaWYgKCBkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJzZWN0TWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcclxuICAgIGlmKGludGVyc2VjdE1ldGhvZCl7XHJcbiAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCBzaGFwZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdmVjdG9yID0gbmV3IFZlYzMoKTtcclxudmFyIG5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7XHJcblxyXG52YXIgYSA9IG5ldyBWZWMzKCk7XHJcbnZhciBiID0gbmV3IFZlYzMoKTtcclxudmFyIGMgPSBuZXcgVmVjMygpO1xyXG52YXIgZCA9IG5ldyBWZWMzKCk7XHJcblxyXG52YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RCb3hcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb3ggPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpO1xyXG59O1xyXG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEJveDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICovXHJcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xyXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xyXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcclxuXHJcbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXHJcbiAgICB2YXIgd29ybGROb3JtYWwgPSBuZXcgVmVjMygwLCAwLCAxKTtcclxuICAgIHF1YXQudm11bHQod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuXHJcbiAgICB2YXIgbGVuID0gbmV3IFZlYzMoKTtcclxuICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTtcclxuICAgIHZhciBwbGFuZVRvRnJvbSA9IGxlbi5kb3Qod29ybGROb3JtYWwpO1xyXG4gICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcclxuICAgIHZhciBwbGFuZVRvVG8gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTtcclxuXHJcbiAgICBpZihwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApe1xyXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuX2RvdF9kaXIgPSB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcclxuXHJcbiAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7XHJcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciBkaXJfc2NhbGVkX3dpdGhfdCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcclxuICAgIHZhciB0ID0gLXdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcclxuICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XHJcbiAgICBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XHJcbn07XHJcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHdvcmxkIEFBQkIgb2YgdGhlIHJheS5cclxuICogQG1ldGhvZCBnZXRBQUJCXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICovXHJcblJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xyXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICByZXN1bHQubG93ZXJCb3VuZC54ID0gTWF0aC5taW4odG8ueCwgZnJvbS54KTtcclxuICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xyXG4gICAgcmVzdWx0Lmxvd2VyQm91bmQueiA9IE1hdGgubWluKHRvLnosIGZyb20ueik7XHJcbiAgICByZXN1bHQudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodG8ueCwgZnJvbS54KTtcclxuICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xyXG4gICAgcmVzdWx0LnVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRvLnosIGZyb20ueik7XHJcbn07XHJcblxyXG52YXIgaW50ZXJzZWN0Q29udmV4T3B0aW9ucyA9IHtcclxuICAgIGZhY2VMaXN0OiBbMF1cclxufTtcclxudmFyIHdvcmxkUGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5ID0gbmV3IFJheSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX21pbk1heCA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSl7XHJcbiAgICB2YXIgZGF0YSA9IHNoYXBlLmRhdGEsXHJcbiAgICAgICAgdyA9IHNoYXBlLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdGhlIHJheSB0byBsb2NhbCBoZWlnaHRmaWVsZCBjb29yZGluYXRlc1xyXG4gICAgdmFyIGxvY2FsUmF5ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXk7IC8vbmV3IFJheSh0aGlzLmZyb20sIHRoaXMudG8pO1xyXG4gICAgbG9jYWxSYXkuZnJvbS5jb3B5KHRoaXMuZnJvbSk7XHJcbiAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS5mcm9tLCBsb2NhbFJheS5mcm9tKTtcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkudG8sIGxvY2FsUmF5LnRvKTtcclxuICAgIGxvY2FsUmF5Ll91cGRhdGVEaXJlY3Rpb24oKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciBpbmRleCA9IGludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4O1xyXG4gICAgdmFyIGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZO1xyXG5cclxuICAgIC8vIFNldCB0byBtYXhcclxuICAgIGlNaW5YID0gaU1pblkgPSAwO1xyXG4gICAgaU1heFggPSBpTWF4WSA9IHNoYXBlLmRhdGEubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XHJcbiAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpO1xyXG5cclxuICAgIHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihhYWJiLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnksIGluZGV4LCB0cnVlKTtcclxuICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTtcclxuICAgIGlNaW5ZID0gTWF0aC5tYXgoaU1pblksIGluZGV4WzFdKTtcclxuICAgIHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihhYWJiLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnksIGluZGV4LCB0cnVlKTtcclxuICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7XHJcbiAgICBpTWF4WSA9IE1hdGgubWluKGlNYXhZLCBpbmRleFsxXSArIDEpO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2hhcGUuZ2V0QWFiYkF0SW5kZXgoaSwgaiwgYWFiYik7XHJcbiAgICAgICAgICAgIGlmKCFhYWJiLm92ZXJsYXBzUmF5KGxvY2FsUmF5KSl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcclxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBwZXIgdHJpYW5nbGVcclxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkO1xyXG5cclxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjMygpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW50ZXJzZWN0U3BoZXJlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICovXHJcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxyXG4gICAgICAgIHRvID0gdGhpcy50byxcclxuICAgICAgICByID0gc2hhcGUucmFkaXVzO1xyXG5cclxuICAgIHZhciBhID0gTWF0aC5wb3codG8ueCAtIGZyb20ueCwgMikgKyBNYXRoLnBvdyh0by55IC0gZnJvbS55LCAyKSArIE1hdGgucG93KHRvLnogLSBmcm9tLnosIDIpO1xyXG4gICAgdmFyIGIgPSAyICogKCh0by54IC0gZnJvbS54KSAqIChmcm9tLnggLSBwb3NpdGlvbi54KSArICh0by55IC0gZnJvbS55KSAqIChmcm9tLnkgLSBwb3NpdGlvbi55KSArICh0by56IC0gZnJvbS56KSAqIChmcm9tLnogLSBwb3NpdGlvbi56KSk7XHJcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xyXG5cclxuICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xyXG5cclxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XHJcbiAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XHJcblxyXG4gICAgaWYoZGVsdGEgPCAwKXtcclxuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfSBlbHNlIGlmKGRlbHRhID09PSAwKXtcclxuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgZnJvbS5sZXJwKHRvLCBkZWx0YSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG5cclxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xyXG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcclxuICAgICAgICB2YXIgZDIgPSAoLSBiICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xyXG5cclxuICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xyXG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQxLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihkMiA+PSAwICYmIGQyIDw9IDEpe1xyXG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmU7XHJcblxyXG5cclxudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X3ZlY3RvciA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RDb252ZXhcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcclxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtICB7Qm9keX0gYm9keVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmZhY2VMaXN0XVxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDb252ZXggPSBmdW5jdGlvbiBpbnRlcnNlY3RDb252ZXgoXHJcbiAgICBzaGFwZSxcclxuICAgIHF1YXQsXHJcbiAgICBwb3NpdGlvbixcclxuICAgIGJvZHksXHJcbiAgICByZXBvcnRlZFNoYXBlLFxyXG4gICAgb3B0aW9uc1xyXG4pe1xyXG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcclxuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsO1xyXG4gICAgdmFyIHZlY3RvciA9IGludGVyc2VjdENvbnZleF92ZWN0b3I7XHJcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xyXG4gICAgdmFyIGZhY2VMaXN0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCkgfHwgbnVsbDtcclxuXHJcbiAgICAvLyBDaGVja2luZyBmYWNlc1xyXG4gICAgdmFyIGZhY2VzID0gc2hhcGUuZmFjZXMsXHJcbiAgICAgICAgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlcyxcclxuICAgICAgICBub3JtYWxzID0gc2hhcGUuZmFjZU5vcm1hbHM7XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xyXG5cclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgdmFyIHRvID0gdGhpcy50bztcclxuICAgIHZhciBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7XHJcblxyXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcclxuICAgIHZhciBOZmFjZXMgPSBmYWNlTGlzdCA/IGZhY2VMaXN0Lmxlbmd0aCA6IGZhY2VzLmxlbmd0aDtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICBmb3IgKHZhciBqID0gMDsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBqIDwgTmZhY2VzOyBqKyspIHtcclxuICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajtcclxuXHJcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tmaV07XHJcbiAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTtcclxuICAgICAgICB2YXIgcSA9IHF1YXQ7XHJcbiAgICAgICAgdmFyIHggPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZVxyXG4gICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxyXG5cclxuICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi5cclxuICAgICAgICB2ZWN0b3IuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XHJcbiAgICAgICAgcS52bXVsdCh2ZWN0b3IsdmVjdG9yKTtcclxuICAgICAgICB2ZWN0b3IudmFkZCh4LHZlY3Rvcik7XHJcblxyXG4gICAgICAgIC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXHJcbiAgICAgICAgdmVjdG9yLnZzdWIoZnJvbSx2ZWN0b3IpO1xyXG5cclxuICAgICAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXHJcbiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLG5vcm1hbCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgICAgICAgdmFyIGRvdCA9IGRpcmVjdGlvbi5kb3Qobm9ybWFsKTtcclxuXHJcbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcclxuICAgICAgICBpZiAoIE1hdGguYWJzKCBkb3QgKSA8IHRoaXMucHJlY2lzaW9uICl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxyXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XHJcblxyXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcclxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKGRvdCA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcclxuICAgICAgICBkaXJlY3Rpb24ubXVsdChzY2FsYXIsaW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQoZnJvbSxpbnRlcnNlY3RQb2ludCk7XHJcblxyXG4gICAgICAgIC8vIGEgaXMgdGhlIHBvaW50IHdlIGNvbXBhcmUgcG9pbnRzIGIgYW5kIGMgd2l0aC5cclxuICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xyXG4gICAgICAgIHEudm11bHQoYSxhKTtcclxuICAgICAgICB4LnZhZGQoYSxhKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpIDwgZmFjZS5sZW5ndGggLSAxOyBpKyspe1xyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gMyB2ZXJ0aWNlcyB0byB3b3JsZCBjb29yZHNcclxuICAgICAgICAgICAgYi5jb3B5KHZlcnRpY2VzW2ZhY2VbaV1dKTtcclxuICAgICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSsxXV0pO1xyXG4gICAgICAgICAgICBxLnZtdWx0KGIsYik7XHJcbiAgICAgICAgICAgIHEudm11bHQoYyxjKTtcclxuICAgICAgICAgICAgeC52YWRkKGIsYik7XHJcbiAgICAgICAgICAgIHgudmFkZChjLGMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpKSB8fCBkaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q29udmV4O1xyXG5cclxudmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb24gPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb20gPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfd29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcclxudmFyIGludGVyc2VjdFRyaW1lc2hfdHJpYW5nbGVzID0gW107XHJcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbnRlcnNlY3RUcmltZXNoXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxyXG4gKiBAdG9kbyBVc2UgT2N0cmVlIGxvb2t1cFxyXG4gKi9cclxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcclxuICAgIG1lc2gsXHJcbiAgICBxdWF0LFxyXG4gICAgcG9zaXRpb24sXHJcbiAgICBib2R5LFxyXG4gICAgcmVwb3J0ZWRTaGFwZSxcclxuICAgIG9wdGlvbnNcclxuKXtcclxuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX25vcm1hbDtcclxuICAgIHZhciB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcztcclxuICAgIHZhciB0cmVlVHJhbnNmb3JtID0gaW50ZXJzZWN0VHJpbWVzaF90cmVlVHJhbnNmb3JtO1xyXG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcclxuICAgIHZhciB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yO1xyXG4gICAgdmFyIG1pbkRpc3RJbnRlcnNlY3QgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdDtcclxuICAgIHZhciBsb2NhbEFBQkIgPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQjtcclxuICAgIHZhciBsb2NhbERpcmVjdGlvbiA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb247XHJcbiAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb207XHJcbiAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcclxuICAgIHZhciB3b3JsZEludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50O1xyXG4gICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbDtcclxuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XHJcblxyXG4gICAgLy8gQ2hlY2tpbmcgZmFjZXNcclxuICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLFxyXG4gICAgICAgIHZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcyxcclxuICAgICAgICBub3JtYWxzID0gbWVzaC5mYWNlTm9ybWFscztcclxuXHJcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcclxuICAgIHZhciB0byA9IHRoaXMudG87XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xyXG5cclxuICAgIHZhciBtaW5EaXN0ID0gLTE7XHJcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xyXG4gICAgdHJlZVRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkocXVhdCk7XHJcblxyXG4gICAgLy8gVHJhbnNmb3JtIHJheSB0byBsb2NhbCBzcGFjZSFcclxuICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGRpcmVjdGlvbiwgbG9jYWxEaXJlY3Rpb24pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBmcm9tLCBsb2NhbEZyb20pO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7XHJcblxyXG4gICAgbG9jYWxUby54ICo9IG1lc2guc2NhbGUueDtcclxuICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7XHJcbiAgICBsb2NhbFRvLnogKj0gbWVzaC5zY2FsZS56O1xyXG4gICAgbG9jYWxGcm9tLnggKj0gbWVzaC5zY2FsZS54O1xyXG4gICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55O1xyXG4gICAgbG9jYWxGcm9tLnogKj0gbWVzaC5zY2FsZS56O1xyXG5cclxuICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTtcclxuICAgIGxvY2FsRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIHZhciBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xyXG5cclxuICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gdHJpYW5nbGVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHZhciB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTtcclxuXHJcbiAgICAgICAgbWVzaC5nZXROb3JtYWwodHJpYW5nbGVzSW5kZXgsIG5vcm1hbCk7XHJcblxyXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcclxuICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWxcclxuXHJcbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDNdLCBhKTtcclxuXHJcbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cclxuICAgICAgICBhLnZzdWIobG9jYWxGcm9tLHZlY3Rvcik7XHJcblxyXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgICAgICAgdmFyIGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpO1xyXG5cclxuICAgICAgICAvLyBCYWlsIG91dCBpZiByYXkgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxyXG4gICAgICAgIC8vIGlmIChNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbil7XHJcbiAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxyXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XHJcblxyXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcclxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcclxuICAgICAgICBsb2NhbERpcmVjdGlvbi5zY2FsZShzY2FsYXIsaW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLGludGVyc2VjdFBvaW50KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRyaWFuZ2xlIHZlcnRpY2VzXHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAxXSwgYik7XHJcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XHJcblxyXG4gICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTtcclxuXHJcbiAgICAgICAgaWYoIShwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpIHx8IHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykpIHx8IHNxdWFyZWREaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGludGVyc2VjdHBvaW50IGFuZCBub3JtYWwgdG8gd29ybGRcclxuICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXQsIG5vcm1hbCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgaW50ZXJzZWN0UG9pbnQsIHdvcmxkSW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCB3b3JsZEludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCB0cmlhbmdsZXNJbmRleCk7XHJcbiAgICB9XHJcbiAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcclxufTtcclxuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5UUklNRVNIXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZXBvcnRJbnRlcnNlY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7VmVjM30gbm9ybWFsXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGhpdFBvaW50V29ybGRcclxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcclxuICovXHJcblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcclxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgdmFyIHRvID0gdGhpcy50bztcclxuICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XHJcbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgbm9ybWFsLmRvdCh0aGlzLl9kaXJlY3Rpb24pID4gMCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC5oaXRGYWNlSW5kZXggPSB0eXBlb2YoaGl0RmFjZUluZGV4KSAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTtcclxuXHJcbiAgICBzd2l0Y2godGhpcy5tb2RlKXtcclxuICAgIGNhc2UgUmF5LkFMTDpcclxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XHJcbiAgICAgICAgcmVzdWx0LnNldChcclxuICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcclxuICAgICAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGRpc3RhbmNlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSBSYXkuQ0xPU0VTVDpcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XHJcbiAgICAgICAgaWYoZGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2UgfHwgIXJlc3VsdC5oYXNIaXQpe1xyXG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcclxuICAgICAgICAgICAgICAgIHNoYXBlLFxyXG4gICAgICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgUmF5LkFOWTpcclxuXHJcbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxyXG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICBzaGFwZSxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgZGlzdGFuY2VcclxuICAgICAgICApO1xyXG4gICAgICAgIHJlc3VsdC5fc2hvdWxkU3RvcCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdjAgPSBuZXcgVmVjMygpLFxyXG4gICAgaW50ZXJzZWN0ID0gbmV3IFZlYzMoKTtcclxuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcclxuXHJcbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXHJcbiAgICBwb3NpdGlvbi52c3ViKGZyb20sdjApO1xyXG4gICAgdmFyIGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pO1xyXG5cclxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbipkb3QgKyBmcm9tXHJcbiAgICBkaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcclxuICAgIGludGVyc2VjdC52YWRkKGZyb20saW50ZXJzZWN0KTtcclxuXHJcbiAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XHJcblxyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG59XHJcblxyXG5cclxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjExLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MzAsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjMxLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuLi9zaGFwZXMvQm94XCI6MzksXCIuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvblwiOjQwLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDV9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XHJcblxyXG4vKipcclxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cclxuICogQGNsYXNzIFJheWNhc3RSZXN1bHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBSYXljYXN0UmVzdWx0KCl7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcmF5RnJvbVdvcmxkXHJcblx0ICovXHJcblx0dGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheVRvV29ybGRcclxuXHQgKi9cclxuXHR0aGlzLnJheVRvV29ybGQgPSBuZXcgVmVjMygpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IGhpdE5vcm1hbFdvcmxkXHJcblx0ICovXHJcblx0dGhpcy5oaXROb3JtYWxXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0UG9pbnRXb3JsZFxyXG5cdCAqL1xyXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XHJcblx0ICovXHJcblx0dGhpcy5oYXNIaXQgPSBmYWxzZTtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGhpdCBzaGFwZSwgb3IgbnVsbC5cclxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxyXG5cdCAqL1xyXG5cdHRoaXMuc2hhcGUgPSBudWxsO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaGl0IGJvZHksIG9yIG51bGwuXHJcblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XHJcblx0ICovXHJcblx0dGhpcy5ib2R5ID0gbnVsbDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XHJcblx0ICogQGRlZmF1bHQgLTFcclxuXHQgKi9cclxuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxyXG5cdCAqIEBkZWZhdWx0IC0xXHJcblx0ICovXHJcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xyXG5cclxuXHQvKipcclxuXHQgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3BcclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqL1xyXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cclxuICogQG1ldGhvZCByZXNldFxyXG4gKi9cclxuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhpcy5yYXlGcm9tV29ybGQuc2V0WmVybygpO1xyXG5cdHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7XHJcblx0dGhpcy5oaXROb3JtYWxXb3JsZC5zZXRaZXJvKCk7XHJcblx0dGhpcy5oaXRQb2ludFdvcmxkLnNldFplcm8oKTtcclxuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xyXG5cdHRoaXMuc2hhcGUgPSBudWxsO1xyXG5cdHRoaXMuYm9keSA9IG51bGw7XHJcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gLTE7XHJcblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWJvcnRcclxuICovXHJcblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcclxuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJheUZyb21Xb3JsZFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcclxuICogQHBhcmFtIHtWZWMzfSBoaXROb3JtYWxXb3JsZFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGhpdFBvaW50V29ybGRcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxyXG4gKi9cclxuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oXHJcblx0cmF5RnJvbVdvcmxkLFxyXG5cdHJheVRvV29ybGQsXHJcblx0aGl0Tm9ybWFsV29ybGQsXHJcblx0aGl0UG9pbnRXb3JsZCxcclxuXHRzaGFwZSxcclxuXHRib2R5LFxyXG5cdGRpc3RhbmNlXHJcbil7XHJcblx0dGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpO1xyXG5cdHRoaXMucmF5VG9Xb3JsZC5jb3B5KHJheVRvV29ybGQpO1xyXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuY29weShoaXROb3JtYWxXb3JsZCk7XHJcblx0dGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7XHJcblx0dGhpcy5zaGFwZSA9IHNoYXBlO1xyXG5cdHRoaXMuYm9keSA9IGJvZHk7XHJcblx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG59O1xyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMyfV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcclxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xyXG5cclxuLyoqXHJcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxyXG4gKlxyXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtXb3JsZH0gW3dvcmxkXVxyXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKHdvcmxkKXtcclxuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXHJcbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cclxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxyXG4gICAgICogQHR5cGUge1dvcmxkfVxyXG4gICAgICovXHJcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF4aXMgdG8gc29ydCB0aGUgYm9kaWVzIGFsb25nLiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLiBGb3IgYmVzdCBwZXJmb3JtYW5jZSwgY2hvb3NlIGFuIGF4aXMgdGhhdCB0aGUgYm9kaWVzIGFyZSBzcHJlYWQgb3V0IG1vcmUgb24uXHJcbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XHJcblxyXG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcclxuXHJcbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGF4aXNMaXN0LnB1c2goZS5ib2R5KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcclxuICAgICAgICB2YXIgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xyXG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xyXG4gICAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYod29ybGQpe1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGQod29ybGQpO1xyXG4gICAgfVxyXG59XHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXHJcbiAqIEBtZXRob2Qgc2V0V29ybGRcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxyXG4gICAgdGhpcy5heGlzTGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxyXG4gICAgZm9yKHZhciBpPTA7IGk8d29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB0aGlzLmF4aXNMaXN0LnB1c2god29ybGQuYm9kaWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcclxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcclxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcclxuXHJcbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcclxuXHJcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFhcclxuICogQHBhcmFtICB7QXJyYXl9IGFcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRYID0gZnVuY3Rpb24oYSkge1xyXG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XHJcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xyXG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xyXG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpe1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYVtqKzFdID0gdjtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkgPSBmdW5jdGlvbihhKSB7XHJcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcclxuICAgICAgICB2YXIgdiA9IGFbaV07XHJcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XHJcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnkgPD0gdi5hYWJiLmxvd2VyQm91bmQueSl7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2orMV0gPSB2O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRaXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xyXG4gICAgICAgIHZhciB2ID0gYVtpXTtcclxuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcclxuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueiA8PSB2LmFhYmIubG93ZXJCb3VuZC56KXtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFbaisxXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcclxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xyXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtICB7QXJyYXl9IHAxXHJcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XHJcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcclxuICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcclxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleCxcclxuICAgICAgICBpLCBqO1xyXG5cclxuICAgIGlmKHRoaXMuZGlydHkpe1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vayB0aHJvdWdoIHRoZSBsaXN0XHJcbiAgICBmb3IoaT0wOyBpICE9PSBOOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgZm9yKGo9aSsxOyBqIDwgTjsgaisrKXtcclxuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xyXG5cclxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSxiaixheGlzSW5kZXgpKXtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscDEscDIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XHJcbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XHJcbiAgICB2YXIgTiA9IGF4aXNMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAvLyBVcGRhdGUgQUFCQnNcclxuICAgIGZvcih2YXIgaSA9IDA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGF4aXNMaXN0W2ldO1xyXG4gICAgICAgIGlmKGJpLmFhYmJOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIGJpLmNvbXB1dGVBQUJCKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgdGhlIGxpc3RcclxuICAgIGlmKGF4aXNJbmRleCA9PT0gMCl7XHJcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WChheGlzTGlzdCk7XHJcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAxKXtcclxuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZKGF4aXNMaXN0KTtcclxuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xyXG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBib3VuZHMgb2YgdHdvIGJvZGllcyBvdmVybGFwLCBhbG9uZyB0aGUgZ2l2ZW4gU0FQIGF4aXMuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0JvdW5kc1xyXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSBialxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uKGJpLCBiaiwgYXhpc0luZGV4KXtcclxuICAgIHZhciBiaVBvcztcclxuICAgIHZhciBialBvcztcclxuXHJcbiAgICBpZihheGlzSW5kZXggPT09IDApe1xyXG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24ueDtcclxuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLng7XHJcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAxKXtcclxuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55O1xyXG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMil7XHJcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi56O1xyXG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcclxuICAgICAgICByaiA9IGJqLmJvdW5kaW5nUmFkaXVzLFxyXG4gICAgICAgIGJvdW5kQTEgPSBiaVBvcyAtIHJpLFxyXG4gICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxyXG4gICAgICAgIGJvdW5kQjEgPSBialBvcyAtIHJqLFxyXG4gICAgICAgIGJvdW5kQjIgPSBialBvcyArIHJqO1xyXG5cclxuICAgIHJldHVybiBib3VuZEIxIDwgYm91bmRBMjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgdmFyaWFuY2Ugb2YgdGhlIGJvZHkgcG9zaXRpb25zIGFuZCBlc3RpbWF0ZXMgdGhlIGJlc3RcclxuICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cclxuICogQG1ldGhvZCBhdXRvRGV0ZWN0QXhpc1xyXG4gKi9cclxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHN1bVg9MCxcclxuICAgICAgICBzdW1YMj0wLFxyXG4gICAgICAgIHN1bVk9MCxcclxuICAgICAgICBzdW1ZMj0wLFxyXG4gICAgICAgIHN1bVo9MCxcclxuICAgICAgICBzdW1aMj0wLFxyXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXHJcbiAgICAgICAgTiA9IGJvZGllcy5sZW5ndGgsXHJcbiAgICAgICAgaW52Tj0xL047XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWCA9IGIucG9zaXRpb24ueDtcclxuICAgICAgICBzdW1YICs9IGNlbnRlclg7XHJcbiAgICAgICAgc3VtWDIgKz0gY2VudGVyWCpjZW50ZXJYO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWSA9IGIucG9zaXRpb24ueTtcclxuICAgICAgICBzdW1ZICs9IGNlbnRlclk7XHJcbiAgICAgICAgc3VtWTIgKz0gY2VudGVyWSpjZW50ZXJZO1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyWiA9IGIucG9zaXRpb24uejtcclxuICAgICAgICBzdW1aICs9IGNlbnRlclo7XHJcbiAgICAgICAgc3VtWjIgKz0gY2VudGVyWipjZW50ZXJaO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVgqc3VtWCppbnZOLFxyXG4gICAgICAgIHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSpzdW1ZKmludk4sXHJcbiAgICAgICAgdmFyaWFuY2VaID0gc3VtWjIgLSBzdW1aKnN1bVoqaW52TjtcclxuXHJcbiAgICBpZih2YXJpYW5jZVggPiB2YXJpYW5jZVkpe1xyXG4gICAgICAgIGlmKHZhcmlhbmNlWCA+IHZhcmlhbmNlWil7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcclxuICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYodmFyaWFuY2VZID4gdmFyaWFuY2VaKXtcclxuICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDE7XHJcbiAgICB9IGVsc2V7XHJcbiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG5cclxuICAgIGlmKHRoaXMuZGlydHkpe1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xyXG4gICAgaWYoYXhpc0luZGV4ID09PSAxKXsgYXhpcyA9ICd5JzsgfVxyXG4gICAgaWYoYXhpc0luZGV4ID09PSAyKXsgYXhpcyA9ICd6JzsgfVxyXG5cclxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XHJcbiAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XHJcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XHJcblxyXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcclxuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo1LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDV9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29uZVR3aXN0Q29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XHJcbnZhciBDb25lRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29uZUVxdWF0aW9uJyk7XHJcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIENvbmVUd2lzdENvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEFdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XHJcbiAqL1xyXG5mdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xyXG5cclxuICAgIC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuXHJcbiAgICB2YXIgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuICAgIHZhciBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XHJcblxyXG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZihvcHRpb25zLmFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29uZUVxdWF0aW9ufSBjb25lRXF1YXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIGMgPSB0aGlzLmNvbmVFcXVhdGlvbiA9IG5ldyBDb25lRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gdHdpc3RFcXVhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcbiAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Yob3B0aW9ucy50d2lzdEFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnR3aXN0QW5nbGUgOiAwO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxyXG4gICAgYy5tYXhGb3JjZSA9IDA7XHJcbiAgICBjLm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uXHJcbiAgICB0Lm1heEZvcmNlID0gMDtcclxuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcblxyXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTtcclxufVxyXG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XHJcbkNvbmVUd2lzdENvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBDb25lVHdpc3RDb25zdHJhaW50O1xyXG5cclxudmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgQ29uZVR3aXN0Q29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcclxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXHJcbiAgICAgICAgY29uZSA9IHRoaXMuY29uZUVxdWF0aW9uLFxyXG4gICAgICAgIHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgYXhlcyB0byB0aGUgY29uZSBjb25zdHJhaW50XHJcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQSwgY29uZS5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQiwgY29uZS5heGlzQik7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSB3b3JsZCBheGVzIGluIHRoZSB0d2lzdCBjb25zdHJhaW50XHJcbiAgICB0aGlzLmF4aXNBLnRhbmdlbnRzKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7XHJcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcclxuXHJcbiAgICB0aGlzLmF4aXNCLnRhbmdlbnRzKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcclxuXHJcbiAgICBjb25lLmFuZ2xlID0gdGhpcy5hbmdsZTtcclxuICAgIHR3aXN0Lm1heEFuZ2xlID0gdGhpcy50d2lzdEFuZ2xlO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbmVFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL0NvbnN0cmFpbnRcIjoxNCxcIi4vUG9pbnRUb1BvaW50Q29uc3RyYWludFwiOjE4fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XHJcblxyXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnQgYmFzZSBjbGFzc1xyXG4gKiBAY2xhc3MgQ29uc3RyYWludFxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53YWtlVXBCb2RpZXM9dHJ1ZV1cclxuICovXHJcbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcclxuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcclxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxyXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC5cclxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xyXG5cclxuICAgIGlmKG9wdGlvbnMud2FrZVVwQm9kaWVzKXtcclxuICAgICAgICBpZihib2R5QSl7XHJcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihib2R5Qil7XHJcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuXHJcbiAqIEBtZXRob2QgdXBkYXRlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmFibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXHJcbiAqIEBtZXRob2QgZW5hYmxlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8ZXFzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGlzYWJsZXMgYWxsIGVxdWF0aW9ucyBpbiB0aGUgY29uc3RyYWludC5cclxuICogQG1ldGhvZCBkaXNhYmxlXHJcbiAqL1xyXG5Db25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZXFzW2ldLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbkNvbnN0cmFpbnQuaWRDb3VudGVyID0gMDtcclxuXHJcbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1NX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XHJcblxyXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnMgdHdvIGJvZGllcyB0byBiZSBhdCBhIGNvbnN0YW50IGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlcnMgY2VudGVyIG9mIG1hc3MuXHJcbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGlzdGFuY2VdIFRoZSBkaXN0YW5jZSB0byBrZWVwLiBJZiB1bmRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAqL1xyXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsZGlzdGFuY2UsbWF4Rm9yY2Upe1xyXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xyXG5cclxuICAgIGlmKHR5cGVvZihkaXN0YW5jZSk9PT1cInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgZGlzdGFuY2UgPSBib2R5QS5wb3NpdGlvbi5kaXN0YW5jZVRvKGJvZHlCLnBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIG1heEZvcmNlID0gMWU2O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBkaXN0YW5jZUVxdWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTtcclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG5cclxuICAgIC8vIE1ha2UgaXQgYmlkaXJlY3Rpb25hbFxyXG4gICAgZXEubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcbiAgICBlcS5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcclxufVxyXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcclxuXHJcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XHJcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xyXG4gICAgdmFyIGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uO1xyXG4gICAgdmFyIGhhbGZEaXN0ID0gdGhpcy5kaXN0YW5jZSAqIDAuNTtcclxuICAgIHZhciBub3JtYWwgPSBlcS5uaTtcclxuXHJcbiAgICBib2R5Qi5wb3NpdGlvbi52c3ViKGJvZHlBLnBvc2l0aW9uLCBub3JtYWwpO1xyXG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgbm9ybWFsLm11bHQoaGFsZkRpc3QsIGVxLnJpKTtcclxuICAgIG5vcm1hbC5tdWx0KC1oYWxmRGlzdCwgZXEucmopO1xyXG59O1xyXG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMCxcIi4vQ29uc3RyYWludFwiOjE0fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEhpbmdlQ29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XHJcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XHJcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG5cclxuLyoqXHJcbiAqIEhpbmdlIGNvbnN0cmFpbnQuIFRoaW5rIG9mIGl0IGFzIGEgZG9vciBoaW5nZS4gSXQgdHJpZXMgdG8ga2VlcCB0aGUgZG9vciBpbiB0aGUgY29ycmVjdCBwbGFjZSBhbmQgd2l0aCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cclxuICogQGNsYXNzIEhpbmdlQ29uc3RyYWludFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV0gQSBwb2ludCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuIFRoaXMgZGVmaW5lcyB0aGUgb2Zmc2V0IG9mIGF4aXNBLlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXSBBbiBheGlzIHRoYXQgYm9keUEgY2FuIHJvdGF0ZSBhcm91bmQsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXHJcbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcclxuICovXHJcbmZ1bmN0aW9uIEhpbmdlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcclxuICAgIHZhciBwaXZvdEEgPSBvcHRpb25zLnBpdm90QSA/IG9wdGlvbnMucGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xyXG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5jYWxsKHRoaXMsIGJvZHlBLCBwaXZvdEEsIGJvZHlCLCBwaXZvdEIsIG1heEZvcmNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcclxuICAgICAqL1xyXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XHJcbiAgICBheGlzQS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcclxuICAgICAqL1xyXG4gICAgdmFyIGF4aXNCID0gdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XHJcbiAgICBheGlzQi5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXHJcbiAgICAgKi9cclxuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxyXG4gICAgICovXHJcbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsTW90b3JFcXVhdGlvbn0gbW90b3JFcXVhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgbW90b3IgPSB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsYm9keUIsbWF4Rm9yY2UpO1xyXG4gICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0XHJcblxyXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXHJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKFxyXG4gICAgICAgIHIxLCAvLyByb3RhdGlvbmFsMVxyXG4gICAgICAgIHIyLCAvLyByb3RhdGlvbmFsMlxyXG4gICAgICAgIG1vdG9yXHJcbiAgICApO1xyXG59XHJcbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xyXG5IaW5nZUNvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBIaW5nZUNvbnN0cmFpbnQ7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICovXHJcbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRNb3RvclNwZWVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpe1xyXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5ID0gc3BlZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRNb3Rvck1heEZvcmNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZVxyXG4gKi9cclxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3Rvck1heEZvcmNlID0gZnVuY3Rpb24obWF4Rm9yY2Upe1xyXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLm1heEZvcmNlID0gbWF4Rm9yY2U7XHJcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XHJcbn07XHJcblxyXG52YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcclxudmFyIEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxyXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcclxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcclxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcclxuICAgICAgICByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMixcclxuICAgICAgICB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxyXG4gICAgICAgIHdvcmxkQXhpc0IgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XHJcblxyXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQTtcclxuICAgIHZhciBheGlzQiA9IHRoaXMuYXhpc0I7XHJcblxyXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLy8gR2V0IHdvcmxkIGF4ZXNcclxuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQoYXhpc0EsIHdvcmxkQXhpc0EpO1xyXG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7XHJcblxyXG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xyXG4gICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcclxuICAgIHIyLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XHJcblxyXG4gICAgaWYodGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQpe1xyXG4gICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpO1xyXG4gICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4vQ29uc3RyYWludFwiOjE0LFwiLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50XCI6MTh9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XHJcblxyXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xyXG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xyXG52YXIgUm90YXRpb25hbEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpO1xyXG52YXIgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKTtcclxudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxuXHJcbi8qKlxyXG4gKiBMb2NrIGNvbnN0cmFpbnQuIFdpbGwgcmVtb3ZlIGFsbCBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYm9kaWVzLlxyXG4gKiBAY2xhc3MgTG9ja0NvbnN0cmFpbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cclxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKi9cclxuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XHJcblxyXG4gICAgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cclxuICAgIHZhciBwaXZvdEEgPSBuZXcgVmVjMygpO1xyXG4gICAgdmFyIHBpdm90QiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgaGFsZldheSA9IG5ldyBWZWMzKCk7XHJcbiAgICBib2R5QS5wb3NpdGlvbi52YWRkKGJvZHlCLnBvc2l0aW9uLCBoYWxmV2F5KTtcclxuICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTtcclxuICAgIGJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90Qik7XHJcbiAgICBib2R5QS5wb2ludFRvTG9jYWxGcmFtZShoYWxmV2F5LCBwaXZvdEEpO1xyXG5cclxuICAgIC8vIFRoZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50IHdpbGwga2VlcCBhIHBvaW50IHNoYXJlZCBiZXR3ZWVuIHRoZSBib2RpZXNcclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgLy8gU3RvcmUgaW5pdGlhbCByb3RhdGlvbiBvZiB0aGUgYm9kaWVzIGFzIHVuaXQgdmVjdG9ycyBpbiB0aGUgbG9jYWwgYm9keSBzcGFjZXNcclxuICAgIHRoaXMueEEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpO1xyXG4gICAgdGhpcy54QiA9IGJvZHlCLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWCk7XHJcbiAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcclxuICAgIHRoaXMueUIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1kpO1xyXG4gICAgdGhpcy56QSA9IGJvZHlBLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWik7XHJcbiAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTtcclxuXHJcbiAgICAvLyAuLi5hbmQgdGhlIGZvbGxvd2luZyByb3RhdGlvbmFsIGVxdWF0aW9ucyB3aWxsIGtlZXAgYWxsIHJvdGF0aW9uYWwgRE9GJ3MgaW4gcGxhY2VcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXHJcbiAgICAgKi9cclxuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxyXG4gICAgICovXHJcbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjNcclxuICAgICAqL1xyXG4gICAgdmFyIHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpO1xyXG59XHJcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XHJcbkxvY2tDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XHJcblxyXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xyXG5cclxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxyXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcclxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcclxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcclxuICAgICAgICByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMixcclxuICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcclxuICAgICAgICB3b3JsZEF4aXNBID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEsXHJcbiAgICAgICAgd29ybGRBeGlzQiA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyO1xyXG5cclxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIFRoZXNlIHZlY3RvciBwYWlycyBtdXN0IGJlIG9ydGhvZ29uYWxcclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhBLCByMS5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QiwgcjEuYXhpc0IpO1xyXG5cclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnlBLCByMi5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QiwgcjIuYXhpc0IpO1xyXG5cclxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpBLCByMy5heGlzQSk7XHJcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4vQ29uc3RyYWludFwiOjE0LFwiLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50XCI6MTh9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb1BvaW50Q29uc3RyYWludDtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLlxyXG4gKiBAY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC5cclxuICogQHBhcmFtIHtWZWMzfSBwaXZvdEIgU2VlIHBpdm90QS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAqICAgICBib2R5QS5wb3NpdGlvbi5zZXQoLTEsIDAsIDApO1xyXG4gKiAgICAgYm9keUIucG9zaXRpb24uc2V0KDEsIDAsIDApO1xyXG4gKiAgICAgYm9keUEuYWRkU2hhcGUoc2hhcGVBKTtcclxuICogICAgIGJvZHlCLmFkZFNoYXBlKHNoYXBlQik7XHJcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcclxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpO1xyXG4gKiAgICAgdmFyIGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCk7XHJcbiAqICAgICB2YXIgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCk7XHJcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLCBsb2NhbFBpdm90QSwgYm9keUIsIGxvY2FsUGl2b3RCKTtcclxuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLHBpdm90QSxib2R5QixwaXZvdEIsbWF4Rm9yY2Upe1xyXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xyXG5cclxuICAgIG1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpdm90LCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBpdm90QSA9IHBpdm90QSA/IHBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpdm90LCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUIuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QlxyXG4gICAgICovXHJcbiAgICB0aGlzLnBpdm90QiA9IHBpdm90QiA/IHBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblhcclxuICAgICAqL1xyXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWVxyXG4gICAgICovXHJcbiAgICB2YXIgeSA9IHRoaXMuZXF1YXRpb25ZID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25aXHJcbiAgICAgKi9cclxuICAgIHZhciB6ID0gdGhpcy5lcXVhdGlvblogPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcclxuXHJcbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7XHJcblxyXG4gICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcclxuICAgIHgubWluRm9yY2UgPSB5Lm1pbkZvcmNlID0gei5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcclxuICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcclxuXHJcbiAgICB4Lm5pLnNldCgxLCAwLCAwKTtcclxuICAgIHkubmkuc2V0KDAsIDEsIDApO1xyXG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XHJcbn1cclxuUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xyXG5cclxuUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XHJcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xyXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWDtcclxuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblk7XHJcbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aO1xyXG5cclxuICAgIC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlXHJcbiAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHgucmkpO1xyXG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90Qix4LnJqKTtcclxuXHJcbiAgICB5LnJpLmNvcHkoeC5yaSk7XHJcbiAgICB5LnJqLmNvcHkoeC5yaik7XHJcbiAgICB6LnJpLmNvcHkoeC5yaSk7XHJcbiAgICB6LnJqLmNvcHkoeC5yaik7XHJcbn07XHJcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBDb25lRXF1YXRpb247XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcbnZhciBDTWF0aCA9IF9kZXJlcV8oJy4uL21hdGgvQ01hdGgnKTtcclxuXHJcbi8qKlxyXG4gKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci5cclxuICogQGNsYXNzIENvbmVFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV0gTG9jYWwgYXhpcyBpbiBBXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdIExvY2FsIGF4aXMgaW4gQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ2xlXSBUaGUgXCJjb25lIGFuZ2xlXCIgdG8ga2VlcFxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gQ29uZUVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xyXG5cclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtbWF4Rm9yY2UsIG1heEZvcmNlKTtcclxuXHJcbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xyXG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25lIGFuZ2xlIHRvIGtlZXBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xyXG59XHJcblxyXG5Db25lRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XHJcbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lRXF1YXRpb247XHJcblxyXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcclxuXHJcbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcclxuICAgIHZhciBhID0gdGhpcy5hLFxyXG4gICAgICAgIGIgPSB0aGlzLmIsXHJcblxyXG4gICAgICAgIG5pID0gdGhpcy5heGlzQSxcclxuICAgICAgICBuaiA9IHRoaXMuYXhpc0IsXHJcblxyXG4gICAgICAgIG5peG5qID0gdG1wVmVjMSxcclxuICAgICAgICBuanhuaSA9IHRtcFZlYzIsXHJcblxyXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xyXG5cclxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xyXG4gICAgbmkuY3Jvc3MobmosIG5peG5qKTtcclxuICAgIG5qLmNyb3NzKG5pLCBuanhuaSk7XHJcblxyXG4gICAgLy8gVGhlIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvciBpczpcclxuICAgIC8vIGNvcyh0aGV0YSkgPSBhICogYiAvIChsZW5ndGgoYSkgKiBsZW5ndGgoYikgPSB7IGxlbihhKSA9IGxlbihiKSA9IDEgfSA9IGEgKiBiXHJcblxyXG4gICAgLy8gZyA9IGEgKiBiXHJcbiAgICAvLyBnZG90ID0gKGIgeCBhKSAqIHdpICsgKGEgeCBiKSAqIHdqXHJcbiAgICAvLyBHID0gWzAgYnhhIDAgYXhiXVxyXG4gICAgLy8gVyA9IFt2aSB3aSB2aiB3al1cclxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XHJcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkobml4bmopO1xyXG5cclxuICAgIHZhciBnID0gQ01hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKSxcclxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXHJcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuXHJcbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcblxyXG59LHtcIi4uL21hdGgvQ01hdGhcIjoyNyxcIi4uL21hdGgvTWF0M1wiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL0VxdWF0aW9uXCI6MjF9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xyXG5cclxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG5cclxuLyoqXHJcbiAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cclxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQGV4dGVuZHMgRXF1YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKXtcclxuICAgIG1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgc2lcclxuICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgc2pcclxuICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaiA9IG51bGw7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMC4wOyAvLyBcImJvdW5jaW5lc3NcIjogdTEgPSAtZSp1MFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgZ29lcyBmcm9tIHRoZSBjZW50ZXIgb2YgYmkgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgc3RhcnRzIGluIGJvZHkgaiBwb3NpdGlvbiBhbmQgZ29lcyB0byB0aGUgY29udGFjdCBwb2ludC5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcclxuICAgICAqL1xyXG4gICAgdGhpcy5yaiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWN0IG5vcm1hbCwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcclxuICAgICAqL1xyXG4gICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7XHJcbn1cclxuXHJcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcclxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcclxuXHJcbnZhciBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnNcclxudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpO1xyXG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcbiAgICAgICAgcmkgPSB0aGlzLnJpLFxyXG4gICAgICAgIHJqID0gdGhpcy5yaixcclxuICAgICAgICByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxyXG4gICAgICAgIHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXHJcblxyXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXHJcbiAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXHJcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcclxuICAgICAgICB0YXVpID0gYmkudG9ycXVlLFxyXG5cclxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxyXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5LFxyXG4gICAgICAgIGZqID0gYmouZm9yY2UsXHJcbiAgICAgICAgdGF1aiA9IGJqLnRvcnF1ZSxcclxuXHJcbiAgICAgICAgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMsXHJcblxyXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxyXG5cclxuICAgICAgICBuID0gdGhpcy5uaTtcclxuXHJcbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgIHJpLmNyb3NzKG4scml4bik7XHJcbiAgICByai5jcm9zcyhuLHJqeG4pO1xyXG5cclxuICAgIC8vIGcgPSB4aityaiAtKHhpK3JpKVxyXG4gICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXVxyXG4gICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7XHJcbiAgICByaXhuLm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcclxuICAgIEdCLnNwYXRpYWwuY29weShuKTtcclxuICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBlbmV0cmF0aW9uIHZlY3RvclxyXG4gICAgcGVuZXRyYXRpb25WZWMuY29weShiai5wb3NpdGlvbik7XHJcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLHBlbmV0cmF0aW9uVmVjKTtcclxuICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24scGVuZXRyYXRpb25WZWMpO1xyXG4gICAgcGVuZXRyYXRpb25WZWMudnN1YihyaSxwZW5ldHJhdGlvblZlYyk7XHJcblxyXG4gICAgdmFyIGcgPSBuLmRvdChwZW5ldHJhdGlvblZlYyk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cclxuICAgIHZhciBlUGx1c09uZSA9IHRoaXMucmVzdGl0dXRpb24gKyAxO1xyXG4gICAgdmFyIEdXID0gZVBsdXNPbmUgKiB2ai5kb3QobikgLSBlUGx1c09uZSAqIHZpLmRvdChuKSArIHdqLmRvdChyanhuKSAtIHdpLmRvdChyaXhuKTtcclxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGgqR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aSA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aiA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCByZWxhdGl2ZSB2ZWxvY2l0eSBpbiB0aGUgY29udGFjdCBwb2ludC5cclxuICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTtcclxuICAgIHZhciB2aiA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqO1xyXG4gICAgdmFyIHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XHJcbiAgICB2YXIgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajtcclxuICAgIHZhciByZWxWZWwgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWw7XHJcblxyXG4gICAgdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIHhpKTtcclxuICAgIHRoaXMuYmoucG9zaXRpb24udmFkZCh0aGlzLnJqLCB4aik7XHJcblxyXG4gICAgdGhpcy5iaS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aSwgdmkpO1xyXG4gICAgdGhpcy5iai5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aiwgdmopO1xyXG5cclxuICAgIHZpLnZzdWIodmosIHJlbFZlbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7XHJcbn07XHJcblxyXG5cclxufSx7XCIuLi9tYXRoL01hdDNcIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi9FcXVhdGlvblwiOjIxfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xyXG5cclxudmFyIEphY29iaWFuRWxlbWVudCA9IF9kZXJlcV8oJy4uL21hdGgvSmFjb2JpYW5FbGVtZW50JyksXHJcbiAgICBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogRXF1YXRpb24gYmFzZSBjbGFzc1xyXG4gKiBAY2xhc3MgRXF1YXRpb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBiaVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Gb3JjZSBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBFcXVhdGlvbihiaSxiaixtaW5Gb3JjZSxtYXhGb3JjZSl7XHJcbiAgICB0aGlzLmlkID0gRXF1YXRpb24uaWQrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5Gb3JjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mKG1pbkZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAtMWU2IDogbWluRm9yY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gMWU2IDogbWF4Rm9yY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYmlcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJpID0gYmk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYmpcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJqID0gYmo7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYSA9IDAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNQT09LIHBhcmFtZXRlclxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJcclxuICAgICAqL1xyXG4gICAgdGhpcy5iID0gMC4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZXBzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXBzID0gMC4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEFcclxuICAgICAqL1xyXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEJcclxuICAgICAqL1xyXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG51bWJlciwgcHJvcG9ydGlvbmFsIHRvIHRoZSBmb3JjZSBhZGRlZCB0byB0aGUgYm9kaWVzLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG11bHRpcGxpZXJcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xyXG5cclxuICAgIC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xyXG4gICAgdGhpcy5zZXRTcG9va1BhcmFtcygxZTcsNCwxLzYwKTtcclxufVxyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcclxuXHJcbkVxdWF0aW9uLmlkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBSZWNhbGN1bGF0ZXMgYSxiLGVwcy5cclxuICogQG1ldGhvZCBzZXRTcG9va1BhcmFtc1xyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLnNldFNwb29rUGFyYW1zID0gZnVuY3Rpb24oc3RpZmZuZXNzLHJlbGF4YXRpb24sdGltZVN0ZXApe1xyXG4gICAgdmFyIGQgPSByZWxheGF0aW9uLFxyXG4gICAgICAgIGsgPSBzdGlmZm5lc3MsXHJcbiAgICAgICAgaCA9IHRpbWVTdGVwO1xyXG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XHJcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcclxuICAgIHRoaXMuZXBzID0gNC4wIC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxyXG4gKiBAbWV0aG9kIGNvbXB1dGVCXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcclxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXHJcbiAgICAgICAgR3EgPSB0aGlzLmNvbXB1dGVHcSgpLFxyXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XHJcbiAgICByZXR1cm4gLSBHcSAqIGEgLSBHVyAqIGIgLSBHaU1mKmg7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xyXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXHJcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcclxuICAgIHJldHVybiBHQS5zcGF0aWFsLmRvdCh4aSkgKyBHQi5zcGF0aWFsLmRvdCh4aik7XHJcbn07XHJcblxyXG52YXIgemVybyA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRypXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXHJcbiAqIEBtZXRob2QgY29tcHV0ZUdXXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcbiAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcclxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxyXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxyXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgcmV0dXJuIEdBLm11bHRpcGx5VmVjdG9ycyh2aSx3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosd2opO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcclxuICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXHJcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXHJcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxyXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcclxuICAgICAgICB3aiA9IGJqLndsYW1iZGE7XHJcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aix3aik7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgRyppbnYoTSkqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cclxuICogQG1ldGhvZCBjb21wdXRlR2lNZlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG52YXIgaU1maSA9IG5ldyBWZWMzKCksXHJcbiAgICBpTWZqID0gbmV3IFZlYzMoKSxcclxuICAgIGludklpX3ZtdWx0X3RhdWkgPSBuZXcgVmVjMygpLFxyXG4gICAgaW52SWpfdm11bHRfdGF1aiA9IG5ldyBWZWMzKCk7XHJcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXHJcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxyXG4gICAgICAgIHRpID0gYmkudG9ycXVlLFxyXG4gICAgICAgIGZqID0gYmouZm9yY2UsXHJcbiAgICAgICAgdGogPSBiai50b3JxdWUsXHJcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXHJcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XHJcblxyXG4gICAgZmkuc2NhbGUoaW52TWFzc2ksaU1maSk7XHJcbiAgICBmai5zY2FsZShpbnZNYXNzaixpTWZqKTtcclxuXHJcbiAgICBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdCh0aSxpbnZJaV92bXVsdF90YXVpKTtcclxuICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRqLGludklqX3ZtdWx0X3RhdWopO1xyXG5cclxuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnMoaU1maSxpbnZJaV92bXVsdF90YXVpKSArIEdCLm11bHRpcGx5VmVjdG9ycyhpTWZqLGludklqX3ZtdWx0X3RhdWopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIEcqaW52KE0pKkcnXHJcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbnZhciB0bXAgPSBuZXcgVmVjMygpO1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxyXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxyXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVdvcmxkU29sdmUsXHJcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhV29ybGRTb2x2ZSxcclxuICAgICAgICByZXN1bHQgPSBpbnZNYXNzaSArIGludk1hc3NqO1xyXG5cclxuICAgIGludklpLnZtdWx0KEdBLnJvdGF0aW9uYWwsdG1wKTtcclxuICAgIHJlc3VsdCArPSB0bXAuZG90KEdBLnJvdGF0aW9uYWwpO1xyXG5cclxuICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsdG1wKTtcclxuICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpO1xyXG5cclxuICAgIHJldHVybiAgcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIGFkZFRvV2xhbWJkYV90ZW1wID0gbmV3IFZlYzMoKSxcclxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXHJcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSBuZXcgVmVjMygpLFxyXG4gICAgYWRkVG9XbGFtYmRhX3JpID0gbmV3IFZlYzMoKSxcclxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXHJcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXHJcbiAqIEBtZXRob2QgYWRkVG9XbGFtYmRhXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxyXG4gKi9cclxuRXF1YXRpb24ucHJvdG90eXBlLmFkZFRvV2xhbWJkYSA9IGZ1bmN0aW9uKGRlbHRhbGFtYmRhKXtcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcclxuICAgICAgICBiaSA9IHRoaXMuYmksXHJcbiAgICAgICAgYmogPSB0aGlzLmJqLFxyXG4gICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcDtcclxuXHJcbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XHJcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcclxuICAgIGJpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJpLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQS5zcGF0aWFsLCBiaS52bGFtYmRhKTtcclxuICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTtcclxuXHJcbiAgICAvLyBBZGQgdG8gYW5ndWxhciB2ZWxvY2l0eVxyXG4gICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCx0ZW1wKTtcclxuICAgIGJpLndsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGRlbHRhbGFtYmRhLCB0ZW1wLCBiaS53bGFtYmRhKTtcclxuXHJcbiAgICBiai5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChHQi5yb3RhdGlvbmFsLHRlbXApO1xyXG4gICAgYmoud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IoZGVsdGFsYW1iZGEsIHRlbXAsIGJqLndsYW1iZGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHNcclxuICogQG1ldGhvZCBjb21wdXRlSW52Q1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwcztcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9KYWNvYmlhbkVsZW1lbnRcIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMyfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEZyaWN0aW9uRXF1YXRpb247XHJcblxyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XHJcblxyXG4vKipcclxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxyXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXHJcbiAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcclxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XHJcbiAgICB0aGlzLnJpID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy50ID0gbmV3IFZlYzMoKTsgLy8gdGFuZ2VudFxyXG59XHJcblxyXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xyXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyaWN0aW9uRXF1YXRpb247XHJcblxyXG52YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTtcclxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcclxuICAgIHZhciBhID0gdGhpcy5hLFxyXG4gICAgICAgIGIgPSB0aGlzLmIsXHJcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxyXG4gICAgICAgIGJqID0gdGhpcy5iaixcclxuICAgICAgICByaSA9IHRoaXMucmksXHJcbiAgICAgICAgcmogPSB0aGlzLnJqLFxyXG4gICAgICAgIHJpeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxyXG4gICAgICAgIHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxyXG4gICAgICAgIHQgPSB0aGlzLnQ7XHJcblxyXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXHJcbiAgICByaS5jcm9zcyh0LHJpeHQpO1xyXG4gICAgcmouY3Jvc3ModCxyanh0KTtcclxuXHJcbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cclxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcclxuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcclxuICAgIHQubmVnYXRlKEdBLnNwYXRpYWwpO1xyXG4gICAgcml4dC5uZWdhdGUoR0Eucm90YXRpb25hbCk7XHJcbiAgICBHQi5zcGF0aWFsLmNvcHkodCk7XHJcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkocmp4dCk7XHJcblxyXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcclxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcclxuXHJcbiAgICByZXR1cm4gQjtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9NYXQzXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4vRXF1YXRpb25cIjoyMX1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRXF1YXRpb247XHJcblxyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJyk7XHJcbnZhciBDTWF0aCA9IF9kZXJlcV8oJy4uL21hdGgvQ01hdGgnKTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLlxyXG4gKiBAY2xhc3MgUm90YXRpb25hbEVxdWF0aW9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2VdXHJcbiAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XHJcblxyXG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xyXG5cclxuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7XHJcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xyXG5cclxuICAgIHRoaXMubWF4QW5nbGUgPSBNYXRoLlBJIC8gMjtcclxufVxyXG5cclxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xyXG5Sb3RhdGlvbmFsRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbEVxdWF0aW9uO1xyXG5cclxudmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcblxyXG5Sb3RhdGlvbmFsRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG5cclxuICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXHJcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxyXG5cclxuICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXHJcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxyXG5cclxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcclxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcclxuXHJcbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XHJcbiAgICBuai5jcm9zcyhuaSwgbmp4bmkpO1xyXG5cclxuICAgIC8vIGcgPSBuaSAqIG5qXHJcbiAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3alxyXG4gICAgLy8gRyA9IFswIG5qeG5pIDAgbml4bmpdXHJcbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxyXG4gICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTtcclxuICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7XHJcblxyXG4gICAgdmFyIGcgPSBDTWF0aC5jb3ModGhpcy5tYXhBbmdsZSkgLSBuaS5kb3QobmopLFxyXG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKSxcclxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG5cclxuICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xyXG5cclxuICAgIHJldHVybiBCO1xyXG59O1xyXG5cclxuXHJcbn0se1wiLi4vbWF0aC9DTWF0aFwiOjI3LFwiLi4vbWF0aC9NYXQzXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4vRXF1YXRpb25cIjoyMX1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbjtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XHJcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLlxyXG4gKiBAY2xhc3MgUm90YXRpb25hbE1vdG9yRXF1YXRpb25cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XHJcbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkhPT0ndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xyXG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGlzQiA9IG5ldyBWZWMzKCk7IC8vIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW90b3IgdmVsb2NpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YXJnZXRWZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDtcclxufVxyXG5cclxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XHJcblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xyXG5cclxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XHJcbiAgICB2YXIgYSA9IHRoaXMuYSxcclxuICAgICAgICBiID0gdGhpcy5iLFxyXG4gICAgICAgIGJpID0gdGhpcy5iaSxcclxuICAgICAgICBiaiA9IHRoaXMuYmosXHJcblxyXG4gICAgICAgIGF4aXNBID0gdGhpcy5heGlzQSxcclxuICAgICAgICBheGlzQiA9IHRoaXMuYXhpc0IsXHJcblxyXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxyXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xyXG5cclxuICAgIC8vIGcgPSAwXHJcbiAgICAvLyBnZG90ID0gYXhpc0EgKiB3aSAtIGF4aXNCICogd2pcclxuICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdXHJcbiAgICAvLyA9PlxyXG4gICAgLy8gRyA9IFswIGF4aXNBIDAgLWF4aXNCXVxyXG5cclxuICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7XHJcbiAgICBheGlzQi5uZWdhdGUoR0Iucm90YXRpb25hbCk7XHJcblxyXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSAtIHRoaXMudGFyZ2V0VmVsb2NpdHksXHJcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuXHJcbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCAqIEdpTWY7XHJcblxyXG4gICAgcmV0dXJuIEI7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvTWF0M1wiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL0VxdWF0aW9uXCI6MjF9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC5cclxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb249MC4zXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzdGl0dXRpb249MC4zXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb249M11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M9MWU3XVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cclxuICovXHJcbmZ1bmN0aW9uIENvbnRhY3RNYXRlcmlhbChtMSwgbTIsIG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuICAgICAgICBmcmljdGlvbjogMC4zLFxyXG4gICAgICAgIHJlc3RpdHV0aW9uOiAwLjMsXHJcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXHJcbiAgICAgICAgY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjogMyxcclxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXHJcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWRlbnRpZmllciBvZiB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBtYXRlcmlhbHNcclxuICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0ZXJpYWxzID0gW20xLCBtMl07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb24gPSBvcHRpb25zLmZyaWN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdGl0dXRpb24gY29lZmZpY2llbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gb3B0aW9ucy5yZXN0aXR1dGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MgPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MgPSBvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxheGF0aW9uIHRpbWUgb2YgdGhlIHByb2R1Y2VkIGZyaWN0aW9uIGVxdWF0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uO1xyXG59XHJcblxyXG5Db250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcclxuXHJcbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1NX1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbDtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cclxuICogQGNsYXNzIE1hdGVyaWFsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIE1hdGVyaWFsKG9wdGlvbnMpe1xyXG4gICAgdmFyIG5hbWUgPSAnJztcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeFxyXG4gICAgaWYodHlwZW9mKG9wdGlvbnMpID09PSAnc3RyaW5nJyl7XHJcbiAgICAgICAgbmFtZSA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfSBlbHNlIGlmKHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBuYW1lID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIG1hdGVyaWFsIGlkLlxyXG4gICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gTWF0ZXJpYWwuaWRDb3VudGVyKys7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4gSWYgbm9uLW5lZ2F0aXZlLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZnJpY3Rpb24gZ2l2ZW4gYnkgQ29udGFjdE1hdGVyaWFscy4gSWYgdGhlcmUncyBubyBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIHRoZSB2YWx1ZSBmcm9tIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZyaWN0aW9uIDogLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0aXR1dGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4gSWYgbm9uLW5lZ2F0aXZlLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgcmVzdGl0dXRpb24gZ2l2ZW4gYnkgQ29udGFjdE1hdGVyaWFscy4gSWYgdGhlcmUncyBubyBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIHRoZSB2YWx1ZSBmcm9tIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzdGl0dXRpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogLTE7XHJcbn1cclxuXHJcbk1hdGVyaWFsLmlkQ291bnRlciA9IDA7XHJcblxyXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcblxyXG5cclxudmFyIHJhZDJhbmcgPSAxODAgLyBNYXRoLlBJO1xyXG5mdW5jdGlvbiByYWRpYW4yYW5nbGUgKHJhZCkge1xyXG4gICAgcmV0dXJuIHJhZCAqIHJhZDJhbmc7XHJcbn1cclxuXHJcbnZhciBzaW5BcnIgPSB7fTtcclxuZnVuY3Rpb24gY2FsY3VsYXRlU2luQnlEaWdpdCAoZGlnaXQpIHtcclxuICAgIGlmIChzaW5BcnIuZGlnaXQgPT0gZGlnaXQpIHJldHVybjtcclxuICAgIHZhciBzdGVwID0gMSAvIE1hdGgucG93KDEwLCBkaWdpdCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA5MDsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgc2luQXJyW2kudG9GaXhlZChkaWdpdCldID0gTWF0aC5zaW4oaSAvIHJhZDJhbmcpO1xyXG4gICAgfVxyXG4gICAgc2luQXJyLmRpZ2l0ID0gZGlnaXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbjM2MCAoYW5nbGUsIGRpZ2l0KSB7XHJcbiAgICBpZiAoYW5nbGUgPD0gOTApIHtcclxuICAgICAgICByZXR1cm4gc2luQXJyW2FuZ2xlLnRvRml4ZWQoZGlnaXQpXTtcclxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPD0gMTgwKSB7XHJcbiAgICAgICAgYW5nbGUgPSAxODAgLSBhbmdsZTtcclxuICAgICAgICByZXR1cm4gc2luQXJyW2FuZ2xlLnRvRml4ZWQoZGlnaXQpXTtcclxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPD0gMjcwKSB7XHJcbiAgICAgICAgYW5nbGUgPSBhbmdsZSAtIDE4MDtcclxuICAgICAgICByZXR1cm4gLXNpbkFyclthbmdsZS50b0ZpeGVkKGRpZ2l0KV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFuZ2xlID0gMzYwIC0gYW5nbGU7XHJcbiAgICAgICAgcmV0dXJuIC1zaW5BcnJbYW5nbGUudG9GaXhlZChkaWdpdCldO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaW4gKHJhZCkge1xyXG4gICAgdmFyIGFuZ2xlID0gcmFkaWFuMmFuZ2xlKHJhZCkgJSAzNjA7XHJcbiAgICBpZiAoYW5nbGUgPCAwKSB7IGFuZ2xlICs9IDM2MDsgfVxyXG4gICAgcmV0dXJuIHNpbjM2MChhbmdsZSwgQ01hdGguX2RpZ2l0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29zIChyYWQpIHtcclxuICAgIHZhciBhbmdsZSA9IChyYWRpYW4yYW5nbGUocmFkKSArIDkwKSAlIDM2MDtcclxuICAgIGlmIChhbmdsZSA8IDApIHsgYW5nbGUgKz0gMzYwOyB9XHJcbiAgICByZXR1cm4gc2luMzYwKGFuZ2xlLCBDTWF0aC5fZGlnaXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW5OYXRpdmUgKHJhZCkge1xyXG4gICAgcmV0dXJuIE1hdGguc2luKHJhZCkudG9GaXhlZChDTWF0aC5kaWdpdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvc05hdGl2ZSAocmFkKSB7XHJcbiAgICByZXR1cm4gTWF0aC5jb3MocmFkKS50b0ZpeGVkKENNYXRoLmRpZ2l0KTtcclxufVxyXG5cclxudmFyIENNYXRoID0ge1xyXG4gICAgc2luOiBNYXRoLnNpbixcclxuICAgIGNvczogTWF0aC5jb3MsXHJcbiAgICBhdGFuMjogTWF0aC5hdGFuMixcclxufVxyXG5cclxuQ01hdGguX3NpbiA9IHNpbjtcclxuQ01hdGguX2NvcyA9IGNvcztcclxuQ01hdGguX3NpbkFyciA9IHNpbkFycjtcclxuQ01hdGguX3NpbjM2MCA9IHNpbjM2MDtcclxuQ01hdGguX3Npbk5hdGl2ZSA9IHNpbk5hdGl2ZTtcclxuQ01hdGguX2Nvc05hdGl2ZSA9IGNvc05hdGl2ZTtcclxuQ01hdGguX3JhZGlhbjJhbmdsZSA9IHJhZGlhbjJhbmdsZTtcclxuQ01hdGguX2NhbGN1bGF0ZVNpbkJ5RGlnaXQgPSBjYWxjdWxhdGVTaW5CeURpZ2l0O1xyXG5cclxuQ01hdGguX2RpZ2l0ID0gMTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENNYXRoLCAnZGlnaXQnLCB7XHJcbiAgICAnZ2V0JzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlnaXQ7IH0sXHJcbiAgICAnc2V0JzogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB0aGlzLl9kaWdpdCA9IHY7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gMSkgY2FsY3VsYXRlU2luQnlEaWdpdCh2KTtcclxuICAgIH1cclxufSk7XHJcblxyXG5DTWF0aC5fbW9kZSA9IDA7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDTWF0aCwgJ21vZGUnLCB7XHJcbiAgICAnZ2V0JzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbW9kZTsgfSxcclxuICAgICdzZXQnOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb2RlICE9IHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IHY7XHJcbiAgICAgICAgICAgIGlmICh2ID09IDApIHtcclxuICAgICAgICAgICAgICAgIENNYXRoLnNpbiA9IE1hdGguc2luO1xyXG4gICAgICAgICAgICAgICAgQ01hdGguY29zID0gTWF0aC5jb3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBDTWF0aC5kaWdpdCA9IENNYXRoLl9kaWdpdDtcclxuICAgICAgICAgICAgICAgIENNYXRoLnNpbiA9IHNpbjtcclxuICAgICAgICAgICAgICAgIENNYXRoLmNvcyA9IGNvcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ID09IDIpIHtcclxuICAgICAgICAgICAgICAgIENNYXRoLnNpbiA9IHNpbk5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIENNYXRoLmNvcyA9IGNvc05hdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENNYXRoO1xyXG5cclxufSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEphY29iaWFuRWxlbWVudDtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQW4gZWxlbWVudCBjb250YWluaW5nIDYgZW50cmllcywgMyBzcGF0aWFsIGFuZCAzIHJvdGF0aW9uYWwgZGVncmVlcyBvZiBmcmVlZG9tLlxyXG4gKiBAY2xhc3MgSmFjb2JpYW5FbGVtZW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSmFjb2JpYW5FbGVtZW50KCl7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNwYXRpYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5zcGF0aWFsID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcm90YXRpb25hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvdGF0aW9uYWwgPSBuZXcgVmVjMygpO1xyXG59XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgd2l0aCBvdGhlciBKYWNvYmlhbkVsZW1lbnRcclxuICogQG1ldGhvZCBtdWx0aXBseUVsZW1lbnRcclxuICogQHBhcmFtICB7SmFjb2JpYW5FbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkphY29iaWFuRWxlbWVudC5wcm90b3R5cGUubXVsdGlwbHlFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XHJcbiAgICByZXR1cm4gZWxlbWVudC5zcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgZWxlbWVudC5yb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnNcclxuICogQG1ldGhvZCBtdWx0aXBseVZlY3RvcnNcclxuICogQHBhcmFtICB7VmVjM30gc3BhdGlhbFxyXG4gKiBAcGFyYW0gIHtWZWMzfSByb3RhdGlvbmFsXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkphY29iaWFuRWxlbWVudC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3JzID0gZnVuY3Rpb24oc3BhdGlhbCxyb3RhdGlvbmFsKXtcclxuICAgIHJldHVybiBzcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgcm90YXRpb25hbC5kb3QodGhpcy5yb3RhdGlvbmFsKTtcclxufTtcclxuXHJcbn0se1wiLi9WZWMzXCI6MzJ9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gTWF0MztcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQSAzeDMgbWF0cml4LlxyXG4gKiBAY2xhc3MgTWF0M1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIGFycmF5IGVsZW1lbnRzIEFycmF5IG9mIG5pbmUgZWxlbWVudHMuIE9wdGlvbmFsLlxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cDovL2dpdGh1Yi5jb20vc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIE1hdDMoZWxlbWVudHMpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBpZihlbGVtZW50cyl7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gWzAsMCwwLDAsMCwwLDAsMCwwXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eVxyXG4gKiBAbWV0aG9kIGlkZW50aXR5XHJcbiAqIEB0b2RvIFNob3VsZCBwZXJoYXBzIGJlIHJlbmFtZWQgdG8gc2V0SWRlbnRpdHkoKSB0byBiZSBtb3JlIGNsZWFyLlxyXG4gKiBAdG9kbyBDcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0aGF0IGltbWVkaWF0ZWx5IGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4IGVnLiBleWUoKVxyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuaWRlbnRpdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgZVswXSA9IDE7XHJcbiAgICBlWzFdID0gMDtcclxuICAgIGVbMl0gPSAwO1xyXG5cclxuICAgIGVbM10gPSAwO1xyXG4gICAgZVs0XSA9IDE7XHJcbiAgICBlWzVdID0gMDtcclxuXHJcbiAgICBlWzZdID0gMDtcclxuICAgIGVbN10gPSAwO1xyXG4gICAgZVs4XSA9IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGFsbCBlbGVtZW50cyB0byB6ZXJvXHJcbiAqIEBtZXRob2Qgc2V0WmVyb1xyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuc2V0WmVybyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICBlWzBdID0gMDtcclxuICAgIGVbMV0gPSAwO1xyXG4gICAgZVsyXSA9IDA7XHJcbiAgICBlWzNdID0gMDtcclxuICAgIGVbNF0gPSAwO1xyXG4gICAgZVs1XSA9IDA7XHJcbiAgICBlWzZdID0gMDtcclxuICAgIGVbN10gPSAwO1xyXG4gICAgZVs4XSA9IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzIGZyb20gYSBWZWMzXHJcbiAqIEBtZXRob2Qgc2V0VHJhY2VcclxuICogQHBhcmFtIHtWZWMzfSB2ZWMzXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zZXRUcmFjZSA9IGZ1bmN0aW9uKHZlYzMpe1xyXG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgZVswXSA9IHZlYzMueDtcclxuICAgIGVbNF0gPSB2ZWMzLnk7XHJcbiAgICBlWzhdID0gdmVjMy56O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50c1xyXG4gKiBAbWV0aG9kIGdldFRyYWNlXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5nZXRUcmFjZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICB0YXJnZXQueCA9IGVbMF07XHJcbiAgICB0YXJnZXQueSA9IGVbNF07XHJcbiAgICB0YXJnZXQueiA9IGVbOF07XHJcbn07XHJcblxyXG4vKipcclxuICogTWF0cml4LVZlY3RvciBtdWx0aXBsaWNhdGlvblxyXG4gKiBAbWV0aG9kIHZtdWx0XHJcbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGhcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwsIHRhcmdldCB0byBzYXZlIHRoZSByZXN1bHQgaW4uXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS52bXVsdCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG5cclxuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cyxcclxuICAgICAgICB4ID0gdi54LFxyXG4gICAgICAgIHkgPSB2LnksXHJcbiAgICAgICAgeiA9IHYuejtcclxuICAgIHRhcmdldC54ID0gZVswXSp4ICsgZVsxXSp5ICsgZVsyXSp6O1xyXG4gICAgdGFyZ2V0LnkgPSBlWzNdKnggKyBlWzRdKnkgKyBlWzVdKno7XHJcbiAgICB0YXJnZXQueiA9IGVbNl0qeCArIGVbN10qeSArIGVbOF0qejtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hdHJpeC1zY2FsYXIgbXVsdGlwbGljYXRpb25cclxuICogQG1ldGhvZCBzbXVsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc1xyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuc211bHQgPSBmdW5jdGlvbihzKXtcclxuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0gKj0gcztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXRyaXggbXVsdGlwbGljYXRpb25cclxuICogQG1ldGhvZCBtbXVsdFxyXG4gKiBAcGFyYW0ge01hdDN9IG0gTWF0cml4IHRvIG11bHRpcGx5IHdpdGggZnJvbSBsZWZ0IHNpZGUuXHJcbiAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5tbXVsdCA9IGZ1bmN0aW9uKG0sdGFyZ2V0KXtcclxuICAgIHZhciByID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XHJcbiAgICBmb3IodmFyIGk9MDsgaTwzOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDM7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPDM7IGsrKyl7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gbS5lbGVtZW50c1tpK2sqM10gKiB0aGlzLmVsZW1lbnRzW2sraiozXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByLmVsZW1lbnRzW2kraiozXSA9IHN1bTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2FsZSBlYWNoIGNvbHVtbiBvZiB0aGUgbWF0cml4XHJcbiAqIEBtZXRob2Qgc2NhbGVcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xyXG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzLFxyXG4gICAgICAgIHQgPSB0YXJnZXQuZWxlbWVudHM7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PTM7IGkrKyl7XHJcbiAgICAgICAgdFszKmkgKyAwXSA9IHYueCAqIGVbMyppICsgMF07XHJcbiAgICAgICAgdFszKmkgKyAxXSA9IHYueSAqIGVbMyppICsgMV07XHJcbiAgICAgICAgdFszKmkgKyAyXSA9IHYueiAqIGVbMyppICsgMl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNvbHZlIEF4PWJcclxuICogQG1ldGhvZCBzb2x2ZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IGIgVGhlIHJpZ2h0IGhhbmQgc2lkZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHZlY3RvciB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgc29sdXRpb24geFxyXG4gKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzXHJcbiAqL1xyXG5NYXQzLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGIsdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnNcclxuICAgIHZhciBuciA9IDM7IC8vIG51bSByb3dzXHJcbiAgICB2YXIgbmMgPSA0OyAvLyBudW0gY29sc1xyXG4gICAgdmFyIGVxbnMgPSBbXTtcclxuICAgIGZvcih2YXIgaT0wOyBpPG5yKm5jOyBpKyspe1xyXG4gICAgICAgIGVxbnMucHVzaCgwKTtcclxuICAgIH1cclxuICAgIHZhciBpLGo7XHJcbiAgICBmb3IoaT0wOyBpPDM7IGkrKyl7XHJcbiAgICAgICAgZm9yKGo9MDsgajwzOyBqKyspe1xyXG4gICAgICAgICAgICBlcW5zW2krbmMqal0gPSB0aGlzLmVsZW1lbnRzW2krMypqXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcW5zWzMrNCowXSA9IGIueDtcclxuICAgIGVxbnNbMys0KjFdID0gYi55O1xyXG4gICAgZXFuc1szKzQqMl0gPSBiLno7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSByaWdodCB1cHBlciB0cmlhbmd1bGFyIHZlcnNpb24gb2YgdGhlIG1hdHJpeCAtIEdhdXNzIGVsaW1pbmF0aW9uXHJcbiAgICB2YXIgbiA9IDMsIGsgPSBuLCBucDtcclxuICAgIHZhciBrcCA9IDQ7IC8vIG51bSByb3dzXHJcbiAgICB2YXIgcCwgZWxzO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGkgPSBrIC0gbjtcclxuICAgICAgICBpZiAoZXFuc1tpK25jKmldID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXHJcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXFuc1tpK25jKmpdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7ICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XHJcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xyXG4gICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGsgKSA9IGxpZ25lKCBrICkgLSBtdWx0aXBsaWVyICogbGlnbmUoIGkgKVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xyXG4gICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYypqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3ArbmMqal0gLSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSB3aGlsZSAoLS1uKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHNvbHV0aW9uXHJcbiAgICB0YXJnZXQueiA9IGVxbnNbMipuYyszXSAvIGVxbnNbMipuYysyXTtcclxuICAgIHRhcmdldC55ID0gKGVxbnNbMSpuYyszXSAtIGVxbnNbMSpuYysyXSp0YXJnZXQueikgLyBlcW5zWzEqbmMrMV07XHJcbiAgICB0YXJnZXQueCA9IChlcW5zWzAqbmMrM10gLSBlcW5zWzAqbmMrMl0qdGFyZ2V0LnogLSBlcW5zWzAqbmMrMV0qdGFyZ2V0LnkpIC8gZXFuc1swKm5jKzBdO1xyXG5cclxuICAgIGlmKGlzTmFOKHRhcmdldC54KSB8fCBpc05hTih0YXJnZXQueSkgfHwgaXNOYU4odGFyZ2V0LnopIHx8IHRhcmdldC54PT09SW5maW5pdHkgfHwgdGFyZ2V0Lnk9PT1JbmZpbml0eSB8fCB0YXJnZXQuej09PUluZmluaXR5KXtcclxuICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9W1wiK3RhcmdldC50b1N0cmluZygpK1wiXSwgYj1bXCIrYi50b1N0cmluZygpK1wiXSwgQT1bXCIrdGhpcy50b1N0cmluZygpK1wiXVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFuIGVsZW1lbnQgaW4gdGhlIG1hdHJpeCBieSBpbmRleC4gSW5kZXggc3RhcnRzIGF0IDAsIG5vdCAxISEhXHJcbiAqIEBtZXRob2QgZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcm93XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE9wdGlvbmFsLiBJZiBwcm92aWRlZCwgdGhlIG1hdHJpeCBlbGVtZW50IHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbk1hdDMucHJvdG90eXBlLmUgPSBmdW5jdGlvbiggcm93ICwgY29sdW1uICx2YWx1ZSl7XHJcbiAgICBpZih2YWx1ZT09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbY29sdW1uKzMqcm93XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gU2V0IHZhbHVlXHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tjb2x1bW4rMypyb3ddID0gdmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weSBhbm90aGVyIG1hdHJpeCBpbnRvIHRoaXMgbWF0cml4IG9iamVjdC5cclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSB7TWF0M30gc291cmNlXHJcbiAqIEByZXR1cm4ge01hdDN9IHRoaXNcclxuICovXHJcbk1hdDMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xyXG4gICAgZm9yKHZhciBpPTA7IGkgPCBzb3VyY2UuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSBzb3VyY2UuZWxlbWVudHNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXguXHJcbiAqIEBtZXRob2QgdG9TdHJpbmdcclxuICogQHJldHVybiBzdHJpbmdcclxuICovXHJcbk1hdDMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciByID0gXCJcIjtcclxuICAgIHZhciBzZXAgPSBcIixcIjtcclxuICAgIGZvcih2YXIgaT0wOyBpPDk7IGkrKyl7XHJcbiAgICAgICAgciArPSB0aGlzLmVsZW1lbnRzW2ldICsgc2VwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG4vKipcclxuICogcmV2ZXJzZSB0aGUgbWF0cml4XHJcbiAqIEBtZXRob2QgcmV2ZXJzZVxyXG4gKiBAcGFyYW0ge01hdDN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IG1hdHJpeCB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgc29sdXRpb24geFxyXG4gKi9cclxuTWF0My5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcblxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xyXG4gICAgdmFyIG5yID0gMzsgLy8gbnVtIHJvd3NcclxuICAgIHZhciBuYyA9IDY7IC8vIG51bSBjb2xzXHJcbiAgICB2YXIgZXFucyA9IFtdO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8bnIqbmM7IGkrKyl7XHJcbiAgICAgICAgZXFucy5wdXNoKDApO1xyXG4gICAgfVxyXG4gICAgdmFyIGksajtcclxuICAgIGZvcihpPTA7IGk8MzsgaSsrKXtcclxuICAgICAgICBmb3Ioaj0wOyBqPDM7IGorKyl7XHJcbiAgICAgICAgICAgIGVxbnNbaStuYypqXSA9IHRoaXMuZWxlbWVudHNbaSszKmpdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxbnNbMys2KjBdID0gMTtcclxuICAgIGVxbnNbMys2KjFdID0gMDtcclxuICAgIGVxbnNbMys2KjJdID0gMDtcclxuICAgIGVxbnNbNCs2KjBdID0gMDtcclxuICAgIGVxbnNbNCs2KjFdID0gMTtcclxuICAgIGVxbnNbNCs2KjJdID0gMDtcclxuICAgIGVxbnNbNSs2KjBdID0gMDtcclxuICAgIGVxbnNbNSs2KjFdID0gMDtcclxuICAgIGVxbnNbNSs2KjJdID0gMTtcclxuXHJcbiAgICAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb25cclxuICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xyXG4gICAgdmFyIGtwID0gbmM7IC8vIG51bSByb3dzXHJcbiAgICB2YXIgcDtcclxuICAgIGRvIHtcclxuICAgICAgICBpID0gayAtIG47XHJcbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lc1xyXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxbnNbaStuYypqXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8geyAvLyBkbyBsaW5lKCBpICkgPSBsaW5lKCBpICkgKyBsaW5lKCBrIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XHJcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xyXG4gICAgICAgICAgICAgICAgZG8geyAvLyBkbyBsaW5lKCBrICkgPSBsaW5lKCBrICkgLSBtdWx0aXBsaWVyICogbGluZSggaSApXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlICgtLW4pO1xyXG5cclxuICAgIC8vIGVsaW1pbmF0ZSB0aGUgdXBwZXIgbGVmdCB0cmlhbmdsZSBvZiB0aGUgbWF0cml4XHJcbiAgICBpID0gMjtcclxuICAgIGRvIHtcclxuICAgICAgICBqID0gaS0xO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XHJcbiAgICAgICAgICAgIG5wID0gbmM7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xyXG4gICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gIGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xyXG4gICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcclxuICAgICAgICB9IHdoaWxlIChqLS0pO1xyXG4gICAgfSB3aGlsZSAoLS1pKTtcclxuXHJcbiAgICAvLyBvcGVyYXRpb25zIG9uIHRoZSBkaWFnb25hbFxyXG4gICAgaSA9IDI7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSAxIC8gZXFuc1tpK25jKmldO1xyXG4gICAgICAgIG5wID0gbmM7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwID0gbmMgLSBucDtcclxuICAgICAgICAgICAgZXFuc1twK25jKmldID0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XHJcbiAgICAgICAgfSB3aGlsZSAoLS1ucCk7XHJcbiAgICB9IHdoaWxlIChpLS0pO1xyXG5cclxuICAgIGkgPSAyO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGogPSAyO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcCA9IGVxbnNbbnIraituYyppXTtcclxuICAgICAgICAgICAgaWYoIGlzTmFOKCBwICkgfHwgcCA9PT1JbmZpbml0eSApe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgcmV2ZXJzZSEgQT1bXCIrdGhpcy50b1N0cmluZygpK1wiXVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5lKCBpICwgaiAsIHAgKTtcclxuICAgICAgICB9IHdoaWxlIChqLS0pO1xyXG4gICAgfSB3aGlsZSAoaS0tKTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgbWF0cml4IGZyb20gYSBxdWF0ZXJpb25cclxuICogQG1ldGhvZCBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxyXG4gKi9cclxuTWF0My5wcm90b3R5cGUuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uKCBxICkge1xyXG4gICAgdmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLncsXHJcbiAgICAgICAgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgeixcclxuICAgICAgICB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyLFxyXG4gICAgICAgIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejIsXHJcbiAgICAgICAgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MixcclxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICBlWzMqMCArIDBdID0gMSAtICggeXkgKyB6eiApO1xyXG4gICAgZVszKjAgKyAxXSA9IHh5IC0gd3o7XHJcbiAgICBlWzMqMCArIDJdID0geHogKyB3eTtcclxuXHJcbiAgICBlWzMqMSArIDBdID0geHkgKyB3ejtcclxuICAgIGVbMyoxICsgMV0gPSAxIC0gKCB4eCArIHp6ICk7XHJcbiAgICBlWzMqMSArIDJdID0geXogLSB3eDtcclxuXHJcbiAgICBlWzMqMiArIDBdID0geHogLSB3eTtcclxuICAgIGVbMyoyICsgMV0gPSB5eiArIHd4O1xyXG4gICAgZVszKjIgKyAyXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIG1hdHJpeFxyXG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxyXG4gKiBAcGFyYW0gIHtNYXQzfSB0YXJnZXQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdC5cclxuICogQHJldHVybiB7TWF0M30gVGhlIHRhcmdldCBNYXQzLCBvciBhIG5ldyBNYXQzIGlmIHRhcmdldCB3YXMgb21pdHRlZC5cclxuICovXHJcbk1hdDMucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcclxuXHJcbiAgICB2YXIgTXQgPSB0YXJnZXQuZWxlbWVudHMsXHJcbiAgICAgICAgTSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT0zOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MzsgaisrKXtcclxuICAgICAgICAgICAgTXRbMyppICsgal0gPSBNWzMqaiArIGldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxufSx7XCIuL1ZlYzNcIjozMn1dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBRdWF0ZXJuaW9uO1xyXG5cclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcclxudmFyIENNYXRoID0gX2RlcmVxXygnLi9DTWF0aCcpO1xyXG5cclxuLyoqXHJcbiAqIEEgUXVhdGVybmlvbiBkZXNjcmliZXMgYSByb3RhdGlvbiBpbiAzRCBzcGFjZS4gVGhlIFF1YXRlcm5pb24gaXMgbWF0aGVtYXRpY2FsbHkgZGVmaW5lZCBhcyBRID0geCppICsgeSpqICsgeiprICsgdywgd2hlcmUgKGksaixrKSBhcmUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvcnMuICh4LHkseikgY2FuIGJlIHNlZW4gYXMgYSB2ZWN0b3IgcmVsYXRlZCB0byB0aGUgYXhpcyBvZiByb3RhdGlvbiwgd2hpbGUgdGhlIHJlYWwgbXVsdGlwbGllciwgdywgaXMgcmVsYXRlZCB0byB0aGUgYW1vdW50IG9mIHJvdGF0aW9uLlxyXG4gKiBAY2xhc3MgUXVhdGVybmlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLlxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGouXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igay5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LlxyXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvblxyXG4gKi9cclxuZnVuY3Rpb24gUXVhdGVybmlvbih4LHkseix3KXtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHhcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCE9PXVuZGVmaW5lZCA/IHggOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHlcclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geSE9PXVuZGVmaW5lZCA/IHkgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHpcclxuICAgICAqL1xyXG4gICAgdGhpcy56ID0geiE9PXVuZGVmaW5lZCA/IHogOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG11bHRpcGxpZXIgb2YgdGhlIHJlYWwgcXVhdGVybmlvbiBiYXNpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gd1xyXG4gICAgICovXHJcbiAgICB0aGlzLncgPSB3IT09dW5kZWZpbmVkID8gdyA6IDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBxdWF0ZXJuaW9uLlxyXG4gKiBAbWV0aG9kIHNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcGFyYW0ge051bWJlcn0gelxyXG4gKiBAcGFyYW0ge051bWJlcn0gd1xyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHosdyl7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMueiA9IHo7XHJcbiAgICB0aGlzLncgPSB3O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCB0byBhIHJlYWRhYmxlIGZvcm1hdFxyXG4gKiBAbWV0aG9kIHRvU3RyaW5nXHJcbiAqIEByZXR1cm4gc3RyaW5nXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy54K1wiLFwiK3RoaXMueStcIixcIit0aGlzLnorXCIsXCIrdGhpcy53O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdG8gYW4gQXJyYXlcclxuICogQG1ldGhvZCB0b0FycmF5XHJcbiAqIEByZXR1cm4gQXJyYXlcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlLlxyXG4gKiBAbWV0aG9kIHNldEZyb21BeGlzQW5nbGVcclxuICogQHBhcmFtIHtWZWMzfSBheGlzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcyxhbmdsZSl7XHJcbiAgICB2YXIgcyA9IENNYXRoLnNpbihhbmdsZSowLjUpO1xyXG4gICAgdGhpcy54ID0gYXhpcy54ICogcztcclxuICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XHJcbiAgICB0aGlzLnogPSBheGlzLnogKiBzO1xyXG4gICAgdGhpcy53ID0gQ01hdGguY29zKGFuZ2xlKjAuNSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgcXVhdGVybmlvbiB0byBheGlzL2FuZ2xlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAbWV0aG9kIHRvQXhpc0FuZ2xlXHJcbiAqIEBwYXJhbSB7VmVjM30gW3RhcmdldEF4aXNdIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy5cclxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5LCBmaXJzdCBlbGVtbnQgaXMgdGhlIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0F4aXNBbmdsZSA9IGZ1bmN0aW9uKHRhcmdldEF4aXMpe1xyXG4gICAgdGFyZ2V0QXhpcyA9IHRhcmdldEF4aXMgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkXHJcbiAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5hY29zKHRoaXMudyk7XHJcbiAgICB2YXIgcyA9IE1hdGguc3FydCgxLXRoaXMudyp0aGlzLncpOyAvLyBhc3N1bWluZyBxdWF0ZXJuaW9uIG5vcm1hbGlzZWQgdGhlbiB3IGlzIGxlc3MgdGhhbiAxLCBzbyB0ZXJtIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIGlmIChzIDwgMC4wMDEpIHsgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnRcclxuICAgICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50XHJcbiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54OyAvLyBpZiBpdCBpcyBpbXBvcnRhbnQgdGhhdCBheGlzIGlzIG5vcm1hbGlzZWQgdGhlbiByZXBsYWNlIHdpdGggeD0xOyB5PXo9MDtcclxuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnk7XHJcbiAgICAgICAgdGFyZ2V0QXhpcy56ID0gdGhpcy56O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpc1xyXG4gICAgICAgIHRhcmdldEF4aXMueSA9IHRoaXMueSAvIHM7XHJcbiAgICAgICAgdGFyZ2V0QXhpcy56ID0gdGhpcy56IC8gcztcclxuICAgIH1cclxuICAgIHJldHVybiBbdGFyZ2V0QXhpcyxhbmdsZV07XHJcbn07XHJcblxyXG52YXIgc2Z2X3QxID0gbmV3IFZlYzMoKSxcclxuICAgIHNmdl90MiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBxdWF0ZXJuaW9uIHZhbHVlIGdpdmVuIHR3byB2ZWN0b3JzLiBUaGUgcmVzdWx0aW5nIHJvdGF0aW9uIHdpbGwgYmUgdGhlIG5lZWRlZCByb3RhdGlvbiB0byByb3RhdGUgdSB0byB2LlxyXG4gKiBAbWV0aG9kIHNldEZyb21WZWN0b3JzXHJcbiAqIEBwYXJhbSB7VmVjM30gdVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21WZWN0b3JzID0gZnVuY3Rpb24odSx2KXtcclxuICAgIGlmKHUuaXNBbnRpcGFyYWxsZWxUbyh2KSl7XHJcbiAgICAgICAgdmFyIHQxID0gc2Z2X3QxO1xyXG4gICAgICAgIHZhciB0MiA9IHNmdl90MjtcclxuXHJcbiAgICAgICAgdS50YW5nZW50cyh0MSx0Mik7XHJcbiAgICAgICAgdGhpcy5zZXRGcm9tQXhpc0FuZ2xlKHQxLE1hdGguUEkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgYSA9IHUuY3Jvc3Modik7XHJcbiAgICAgICAgdGhpcy54ID0gYS54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueTtcclxuICAgICAgICB0aGlzLnogPSBhLno7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KE1hdGgucG93KHUubm9ybSgpLDIpICogTWF0aC5wb3codi5ub3JtKCksMikpICsgdS5kb3Qodik7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFF1YXRlcm5pb24gbXVsdGlwbGljYXRpb25cclxuICogQG1ldGhvZCBtdWx0XHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldCBPcHRpb25hbC5cclxuICogQHJldHVybiB7UXVhdGVybmlvbn1cclxuICovXHJcbnZhciBRdWF0ZXJuaW9uX211bHRfdmEgPSBuZXcgVmVjMygpO1xyXG52YXIgUXVhdGVybmlvbl9tdWx0X3ZiID0gbmV3IFZlYzMoKTtcclxudmFyIFF1YXRlcm5pb25fbXVsdF92YXh2YiA9IG5ldyBWZWMzKCk7XHJcblF1YXRlcm5pb24ucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbihxLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICB2YXIgYXggPSB0aGlzLngsIGF5ID0gdGhpcy55LCBheiA9IHRoaXMueiwgYXcgPSB0aGlzLncsXHJcbiAgICAgICAgYnggPSBxLngsIGJ5ID0gcS55LCBieiA9IHEueiwgYncgPSBxLnc7XHJcblxyXG4gICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xyXG4gICAgdGFyZ2V0LnkgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xyXG4gICAgdGFyZ2V0LnogPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xyXG4gICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBpbnZlcnNlIHF1YXRlcm5pb24gcm90YXRpb24uXHJcbiAqIEBtZXRob2QgaW52ZXJzZVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuICAgIHRoaXMuY29uanVnYXRlKHRhcmdldCk7XHJcbiAgICB2YXIgaW5vcm0yID0gMS8oeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcclxuICAgIHRhcmdldC54ICo9IGlub3JtMjtcclxuICAgIHRhcmdldC55ICo9IGlub3JtMjtcclxuICAgIHRhcmdldC56ICo9IGlub3JtMjtcclxuICAgIHRhcmdldC53ICo9IGlub3JtMjtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcXVhdGVybmlvbiBjb25qdWdhdGVcclxuICogQG1ldGhvZCBjb25qdWdhdGVcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSB0YXJnZXRcclxuICogQHJldHVybiB7UXVhdGVybmlvbn1cclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICB0YXJnZXQueCA9IC10aGlzLng7XHJcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XHJcbiAgICB0YXJnZXQueiA9IC10aGlzLno7XHJcbiAgICB0YXJnZXQudyA9IHRoaXMudztcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbi4gTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBxdWF0ZXJuaW9uLlxyXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBsID0gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpO1xyXG4gICAgaWYgKCBsID09PSAwICkge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgIHRoaXMudyA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGwgPSAxIC8gbDtcclxuICAgICAgICB0aGlzLnggKj0gbDtcclxuICAgICAgICB0aGlzLnkgKj0gbDtcclxuICAgICAgICB0aGlzLnogKj0gbDtcclxuICAgICAgICB0aGlzLncgKj0gbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwcHJveGltYXRpb24gb2YgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBXb3JrcyBiZXN0IHdoZW4gcXVhdCBpcyBhbHJlYWR5IGFsbW9zdC1ub3JtYWxpemVkLlxyXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZUZhc3RcclxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9mYXN0LXF1YXRlcm5pb24tbm9ybWFsaXphdGlvblxyXG4gKiBAYXV0aG9yIHVucGhhc2VkLCBodHRwczovL2dpdGh1Yi5jb20vdW5waGFzZWRcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLm5vcm1hbGl6ZUZhc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZiA9ICgzLjAtKHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpKS8yLjA7XHJcbiAgICBpZiAoIGYgPT09IDAgKSB7XHJcbiAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgIHRoaXMueiA9IDA7XHJcbiAgICAgICAgdGhpcy53ID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy54ICo9IGY7XHJcbiAgICAgICAgdGhpcy55ICo9IGY7XHJcbiAgICAgICAgdGhpcy56ICo9IGY7XHJcbiAgICAgICAgdGhpcy53ICo9IGY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvclxyXG4gKiBAbWV0aG9kIHZtdWx0XHJcbiAqIEBwYXJhbSB7VmVjM30gdlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuXHJcbiAgICB2YXIgeCA9IHYueCxcclxuICAgICAgICB5ID0gdi55LFxyXG4gICAgICAgIHogPSB2Lno7XHJcblxyXG4gICAgdmFyIHF4ID0gdGhpcy54LFxyXG4gICAgICAgIHF5ID0gdGhpcy55LFxyXG4gICAgICAgIHF6ID0gdGhpcy56LFxyXG4gICAgICAgIHF3ID0gdGhpcy53O1xyXG5cclxuICAgIC8vIHEqdlxyXG4gICAgdmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcclxuICAgIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcclxuICAgIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcclxuICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcclxuXHJcbiAgICB0YXJnZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XHJcbiAgICB0YXJnZXQueSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XHJcbiAgICB0YXJnZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3BpZXMgdmFsdWUgb2Ygc291cmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gc291cmNlXHJcbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IHRoaXNcclxuICovXHJcblF1YXRlcm5pb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xyXG4gICAgdGhpcy54ID0gc291cmNlLng7XHJcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcclxuICAgIHRoaXMueiA9IHNvdXJjZS56O1xyXG4gICAgdGhpcy53ID0gc291cmNlLnc7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHRoZSBxdWF0ZXJuaW9uIHRvIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uLiBPcmRlcjogWVpYLCBhcyB0aGlzIHBhZ2UgZGVzY3JpYmVzOiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9zdGFuZGFyZHMvaW5kZXguaHRtXHJcbiAqIEBtZXRob2QgdG9FdWxlclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKiBAcGFyYW0gc3RyaW5nIG9yZGVyIFRocmVlLWNoYXJhY3RlciBzdHJpbmcgZS5nLiBcIllaWFwiLCB3aGljaCBhbHNvIGlzIGRlZmF1bHQuXHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24odGFyZ2V0LG9yZGVyKXtcclxuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJZWlhcIjtcclxuXHJcbiAgICB2YXIgaGVhZGluZywgYXR0aXR1ZGUsIGJhbms7XHJcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcclxuXHJcbiAgICBzd2l0Y2gob3JkZXIpe1xyXG4gICAgY2FzZSBcIllaWFwiOlxyXG4gICAgICAgIHZhciB0ZXN0ID0geCp5ICsgeip3O1xyXG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxyXG4gICAgICAgICAgICBoZWFkaW5nID0gMiAqIENNYXRoLmF0YW4yKHgsdyk7XHJcbiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5QSS8yO1xyXG4gICAgICAgICAgICBiYW5rID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZVxyXG4gICAgICAgICAgICBoZWFkaW5nID0gLTIgKiBDTWF0aC5hdGFuMih4LHcpO1xyXG4gICAgICAgICAgICBhdHRpdHVkZSA9IC0gTWF0aC5QSS8yO1xyXG4gICAgICAgICAgICBiYW5rID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNOYU4oaGVhZGluZykpe1xyXG4gICAgICAgICAgICB2YXIgc3F4ID0geCp4O1xyXG4gICAgICAgICAgICB2YXIgc3F5ID0geSp5O1xyXG4gICAgICAgICAgICB2YXIgc3F6ID0geip6O1xyXG4gICAgICAgICAgICBoZWFkaW5nID0gQ01hdGguYXRhbjIoMip5KncgLSAyKngqeiAsIDEgLSAyKnNxeSAtIDIqc3F6KTsgLy8gSGVhZGluZ1xyXG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguYXNpbigyKnRlc3QpOyAvLyBhdHRpdHVkZVxyXG4gICAgICAgICAgICBiYW5rID0gQ01hdGguYXRhbjIoMip4KncgLSAyKnkqeiAsIDEgLSAyKnNxeCAtIDIqc3F6KTsgLy8gYmFua1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXVsZXIgb3JkZXIgXCIrb3JkZXIrXCIgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldC55ID0gaGVhZGluZztcclxuICAgIHRhcmdldC56ID0gYXR0aXR1ZGU7XHJcbiAgICB0YXJnZXQueCA9IGJhbms7XHJcbn07XHJcblxyXG4vKipcclxuICogU2VlIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cclxuICogQG1ldGhvZCBzZXRGcm9tRXVsZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHpcclxuICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIFRoZSBvcmRlciB0byBhcHBseSBhbmdsZXM6ICdYWVonIG9yICdZWFonIG9yIGFueSBvdGhlciBjb21iaW5hdGlvblxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0RnJvbUV1bGVyID0gZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcclxuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcclxuXHJcbiAgICB2YXIgYzEgPSBDTWF0aC5jb3MoIHggLyAyICk7XHJcbiAgICB2YXIgYzIgPSBDTWF0aC5jb3MoIHkgLyAyICk7XHJcbiAgICB2YXIgYzMgPSBDTWF0aC5jb3MoIHogLyAyICk7XHJcbiAgICB2YXIgczEgPSBDTWF0aC5zaW4oIHggLyAyICk7XHJcbiAgICB2YXIgczIgPSBDTWF0aC5zaW4oIHkgLyAyICk7XHJcbiAgICB2YXIgczMgPSBDTWF0aC5zaW4oIHogLyAyICk7XHJcblxyXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjbG9uZVxyXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxyXG4gKlxyXG4gKiBAbWV0aG9kIHNsZXJwXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdG9RdWF0IHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHNlbGYgcXVhdGVybmlvbiBhbmQgdG9RdWF0XHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW3RhcmdldF0gQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybnMge1F1YXRlcm5pb259IFRoZSBcInRhcmdldFwiIG9iamVjdFxyXG4gKi9cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuc2xlcnAgPSBmdW5jdGlvbiAodG9RdWF0LCB0LCB0YXJnZXQpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuICAgIHZhciBheCA9IHRoaXMueCxcclxuICAgICAgICBheSA9IHRoaXMueSxcclxuICAgICAgICBheiA9IHRoaXMueixcclxuICAgICAgICBhdyA9IHRoaXMudyxcclxuICAgICAgICBieCA9IHRvUXVhdC54LFxyXG4gICAgICAgIGJ5ID0gdG9RdWF0LnksXHJcbiAgICAgICAgYnogPSB0b1F1YXQueixcclxuICAgICAgICBidyA9IHRvUXVhdC53O1xyXG5cclxuICAgIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcclxuXHJcbiAgICAvLyBjYWxjIGNvc2luZVxyXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xyXG5cclxuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxyXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcclxuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcclxuICAgICAgICBieCA9IC0gYng7XHJcbiAgICAgICAgYnkgPSAtIGJ5O1xyXG4gICAgICAgIGJ6ID0gLSBiejtcclxuICAgICAgICBidyA9IC0gYnc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xyXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XHJcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXHJcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcclxuICAgICAgICBzaW5vbSAgPSBDTWF0aC5zaW4ob21lZ2EpO1xyXG4gICAgICAgIHNjYWxlMCA9IENNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcclxuICAgICAgICBzY2FsZTEgPSBDTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXHJcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XHJcbiAgICAgICAgc2NhbGUxID0gdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXHJcbiAgICB0YXJnZXQueCA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XHJcbiAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XHJcbiAgICB0YXJnZXQueiA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XHJcbiAgICB0YXJnZXQudyA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC5cclxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhclZlbG9jaXR5XHJcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcclxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhckZhY3RvclxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSB0YXJnZXRcclxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIFwidGFyZ2V0XCIgb2JqZWN0XHJcbiAqL1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihhbmd1bGFyVmVsb2NpdHksIGR0LCBhbmd1bGFyRmFjdG9yLCB0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgdmFyIGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsXHJcbiAgICAgICAgYXkgPSBhbmd1bGFyVmVsb2NpdHkueSAqIGFuZ3VsYXJGYWN0b3IueSxcclxuICAgICAgICBheiA9IGFuZ3VsYXJWZWxvY2l0eS56ICogYW5ndWxhckZhY3Rvci56LFxyXG4gICAgICAgIGJ4ID0gdGhpcy54LFxyXG4gICAgICAgIGJ5ID0gdGhpcy55LFxyXG4gICAgICAgIGJ6ID0gdGhpcy56LFxyXG4gICAgICAgIGJ3ID0gdGhpcy53O1xyXG5cclxuICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XHJcblxyXG4gICAgdGFyZ2V0LnggKz0gaGFsZl9kdCAqIChheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnkpO1xyXG4gICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopO1xyXG4gICAgdGFyZ2V0LnogKz0gaGFsZl9kdCAqIChheiAqIGJ3ICsgYXggKiBieSAtIGF5ICogYngpO1xyXG4gICAgdGFyZ2V0LncgKz0gaGFsZl9kdCAqICgtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxufSx7XCIuL0NNYXRoXCI6MjcsXCIuL1ZlYzNcIjozMn1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuL1F1YXRlcm5pb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcG9zaXRpb25cclxuXHQgKi9cclxuXHR0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXHJcblx0ICovXHJcblx0dGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwb2ludFRvTG9jYUZyYW1lXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRQb2ludFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB3b3JsZFBvaW50LnZzdWIocG9zaXRpb24sIHJlc3VsdCk7XHJcbiAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0KTtcclxuICAgIHRtcFF1YXQudm11bHQocmVzdWx0LCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBnbG9iYWwgcG9pbnQgaW4gbG9jYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxyXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbFxyXG4gKiBAcGFyYW0gIHtWZWMzfSBwb2ludFxyXG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcclxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxyXG4gKi9cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5wb2ludFRvTG9jYWwgPSBmdW5jdGlvbih3b3JsZFBvaW50LCByZXN1bHQpe1xyXG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cclxuICogQHBhcmFtIHtWZWMzfSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7VmVjM30gbG9jYWxQb2ludFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsUG9pbnQsIHJlc3VsdCk7XHJcbiAgICByZXN1bHQudmFkZChwb3NpdGlvbiwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy5cclxuICogQG1ldGhvZCBwb2ludFRvV29ybGRcclxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInJlc3VsdFwiIHZlY3RvciBvYmplY3RcclxuICovXHJcblRyYW5zZm9ybS5wcm90b3R5cGUucG9pbnRUb1dvcmxkID0gZnVuY3Rpb24obG9jYWxQb2ludCwgcmVzdWx0KXtcclxuICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpO1xyXG59O1xyXG5cclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxWZWN0b3IsIHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQpe1xyXG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkVmVjdG9yLCByZXN1bHQpe1xyXG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xyXG4gICAgcXVhdGVybmlvbi53ICo9IC0xO1xyXG4gICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG59LHtcIi4vUXVhdGVybmlvblwiOjMwLFwiLi9WZWMzXCI6MzJ9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gVmVjMztcclxuXHJcbnZhciBNYXQzID0gX2RlcmVxXygnLi9NYXQzJyk7XHJcblxyXG4vKipcclxuICogMy1kaW1lbnNpb25hbCB2ZWN0b3JcclxuICogQGNsYXNzIFZlYzNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGV4YW1wbGVcclxuICogICAgIHZhciB2ID0gbmV3IFZlYzMoMSwgMiwgMyk7XHJcbiAqICAgICBjb25zb2xlLmxvZygneD0nICsgdi54KTsgLy8geD0xXHJcbiAqL1xyXG5mdW5jdGlvbiBWZWMzKHgseSx6KXtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHhcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHh8fDAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5fHwwLjA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgelxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy56ID0genx8MC4wO1xyXG59XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkge1ZlYzN9IFpFUk9cclxuICovXHJcblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xyXG5cclxuLyoqXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1hcclxuICovXHJcblZlYzMuVU5JVF9YID0gbmV3IFZlYzMoMSwgMCwgMCk7XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWVxyXG4gKi9cclxuVmVjMy5VTklUX1kgPSBuZXcgVmVjMygwLCAxLCAwKTtcclxuXHJcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9aXHJcbiAqL1xyXG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xyXG5cclxuLyoqXHJcbiAqIFZlY3RvciBjcm9zcyBwcm9kdWN0XHJcbiAqIEBtZXRob2QgY3Jvc3NcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgdmFyIHZ4PXYueCwgdnk9di55LCB2ej12LnosIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuXHJcbiAgICB0YXJnZXQueCA9ICh5ICogdnopIC0gKHogKiB2eSk7XHJcbiAgICB0YXJnZXQueSA9ICh6ICogdngpIC0gKHggKiB2eik7XHJcbiAgICB0YXJnZXQueiA9ICh4ICogdnkpIC0gKHkgKiB2eCk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHNcclxuICogQG1ldGhvZCBzZXRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHpcclxuICogQHJldHVybiBWZWMzXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LHkseil7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMueiA9IHo7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxyXG4gKiBAbWV0aG9kIHNldFplcm9cclxuICovXHJcblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZWN0b3IgYWRkaXRpb25cclxuICogQG1ldGhvZCB2YWRkXHJcbiAqIEBwYXJhbSB7VmVjM30gdlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLnZhZGQgPSBmdW5jdGlvbih2LHRhcmdldCl7XHJcbiAgICBpZih0YXJnZXQpe1xyXG4gICAgICAgIHRhcmdldC54ID0gdi54ICsgdGhpcy54O1xyXG4gICAgICAgIHRhcmdldC55ID0gdi55ICsgdGhpcy55O1xyXG4gICAgICAgIHRhcmdldC56ID0gdi56ICsgdGhpcy56O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ICsgdi56KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZWN0b3Igc3VidHJhY3Rpb25cclxuICogQG1ldGhvZCB2c3ViXHJcbiAqIEBwYXJhbSB7VmVjM30gdlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHRvIHNhdmUgaW4uXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS52c3ViID0gZnVuY3Rpb24odix0YXJnZXQpe1xyXG4gICAgaWYodGFyZ2V0KXtcclxuICAgICAgICB0YXJnZXQueCA9IHRoaXMueCAtIHYueDtcclxuICAgICAgICB0YXJnZXQueSA9IHRoaXMueSAtIHYueTtcclxuICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHYuejtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueC12LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnktdi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LXYueik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG1hdHJpeCBhX2Nyb3NzIGZyb20gYSB2ZWN0b3IsIHN1Y2ggdGhhdCBhIHggYiA9IGFfY3Jvc3MgKiBiID0gY1xyXG4gKiBAbWV0aG9kIGNyb3NzbWF0XHJcbiAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGZcclxuICogQHJldHVybiB7TWF0M31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmNyb3NzbWF0ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBuZXcgTWF0MyhbICAgICAwLCAgLXRoaXMueiwgICB0aGlzLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosICAgICAgICAwLCAgLXRoaXMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgICB0aGlzLngsICAgICAgICAwXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLlxyXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xyXG4gICAgdmFyIG4gPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcclxuICAgIGlmKG4+MC4wKXtcclxuICAgICAgICB2YXIgaW52TiA9IDEvbjtcclxuICAgICAgICB0aGlzLnggKj0gaW52TjtcclxuICAgICAgICB0aGlzLnkgKj0gaW52TjtcclxuICAgICAgICB0aGlzLnogKj0gaW52TjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTWFrZSBzb21ldGhpbmcgdXBcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmVyc2lvbiBvZiB0aGlzIHZlY3RvciB0aGF0IGlzIG9mIGxlbmd0aCAxLlxyXG4gKiBAbWV0aG9kIHVuaXRcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cclxuICogQHJldHVybiB7VmVjM30gUmV0dXJucyB0aGUgdW5pdCB2ZWN0b3JcclxuICovXHJcblZlYzMucHJvdG90eXBlLnVuaXQgPSBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHZhciBuaW52ID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XHJcbiAgICBpZihuaW52PjAuMCl7XHJcbiAgICAgICAgbmludiA9IDEuMC9uaW52O1xyXG4gICAgICAgIHRhcmdldC54ID0geCAqIG5pbnY7XHJcbiAgICAgICAgdGFyZ2V0LnkgPSB5ICogbmludjtcclxuICAgICAgICB0YXJnZXQueiA9IHogKiBuaW52O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXQueCA9IDE7XHJcbiAgICAgICAgdGFyZ2V0LnkgPSAwO1xyXG4gICAgICAgIHRhcmdldC56ID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIG5vcm1cclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmxlbmd0aCgpIGluc3RlYWRcclxuICovXHJcblZlYzMucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIGxlbmd0aFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZW5ndGggPSBWZWMzLnByb3RvdHlwZS5ub3JtO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIG5vcm0yXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGhTcXVhcmVkKCkgaW5zdGVhZC5cclxuICovXHJcblZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXHJcbiAqIEBtZXRob2QgbGVuZ3RoU3F1YXJlZFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gVmVjMy5wcm90b3R5cGUubm9ybTI7XHJcblxyXG4vKipcclxuICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XHJcbiAqIEBtZXRob2QgZGlzdGFuY2VUb1xyXG4gKiBAcGFyYW0gIHtWZWMzfSBwXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcblZlYzMucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbihwKXtcclxuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xyXG4gICAgdmFyIHB4PXAueCwgcHk9cC55LCBwej1wLno7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChweC14KSoocHgteCkrXHJcbiAgICAgICAgICAgICAgICAgICAgIChweS15KSoocHkteSkrXHJcbiAgICAgICAgICAgICAgICAgICAgIChwei16KSoocHoteikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XHJcbiAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24ocCl7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xyXG4gICAgcmV0dXJuIChweC14KSoocHgteCkgKyAocHkteSkqKHB5LXkpICsgKHB6LXopKihwei16KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcclxuICogQG1ldGhvZCBtdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqIEBkZXByZWNhdGVkIFVzZSAuc2NhbGUoKSBpbnN0ZWFkXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24oc2NhbGFyLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHZhciB4ID0gdGhpcy54LFxyXG4gICAgICAgIHkgPSB0aGlzLnksXHJcbiAgICAgICAgeiA9IHRoaXMuejtcclxuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcclxuICAgIHRhcmdldC55ID0gc2NhbGFyICogeTtcclxuICAgIHRhcmdldC56ID0gc2NhbGFyICogejtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoIGFuIG90aGVyIHZlY3RvciwgY29tcG9uZW50LXdpc2UuXHJcbiAqIEBtZXRob2QgbXVsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmVjdG9yXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB2ZWN0b3IgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUudm11bCA9IGZ1bmN0aW9uKHZlY3RvciwgdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgdGFyZ2V0LnggPSB2ZWN0b3IueCAqIHRoaXMueDtcclxuICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKiB0aGlzLnk7XHJcbiAgICB0YXJnZXQueiA9IHZlY3Rvci56ICogdGhpcy56O1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXHJcbiAqIEBtZXRob2Qgc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuc2NhbGUgPSBWZWMzLnByb3RvdHlwZS5tdWx0O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIGEgdmVjdG9yIGFuZCBhZGQgaXQgdG8gdGhpcyB2ZWN0b3IuIFNhdmUgdGhlIHJlc3VsdCBpbiBcInRhcmdldFwiLiAodGFyZ2V0ID0gdGhpcyArIHZlY3RvciAqIHNjYWxhcilcclxuICogQG1ldGhvZCBhZGRTY2FsZWRWZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZlY3RvclxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLmFkZFNjYWxlZFZlY3RvciA9IGZ1bmN0aW9uKHNjYWxhciwgdmVjdG9yLCB0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54O1xyXG4gICAgdGFyZ2V0LnkgPSB0aGlzLnkgKyBzY2FsYXIgKiB2ZWN0b3IueTtcclxuICAgIHRhcmdldC56ID0gdGhpcy56ICsgc2NhbGFyICogdmVjdG9yLno7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBkb3QgcHJvZHVjdFxyXG4gKiBAbWV0aG9kIGRvdFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24odil7XHJcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaXNaZXJvXHJcbiAqIEByZXR1cm4gYm9vbFxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLng9PT0wICYmIHRoaXMueT09PTAgJiYgdGhpcy56PT09MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIHRoZSB2ZWN0b3IgcG9pbnQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cclxuICogQG1ldGhvZCBuZWdhdGVcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblZlYzMucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRhcmdldC54ID0gLXRoaXMueDtcclxuICAgIHRhcmdldC55ID0gLXRoaXMueTtcclxuICAgIHRhcmdldC56ID0gLXRoaXMuejtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yXHJcbiAqIEBtZXRob2QgdGFuZ2VudHNcclxuICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cclxuICogQHBhcmFtIHtWZWMzfSB0MiBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIHNlY29uZCB0YW5nZW50IGluXHJcbiAqL1xyXG52YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcclxudmFyIFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7XHJcblZlYzMucHJvdG90eXBlLnRhbmdlbnRzID0gZnVuY3Rpb24odDEsdDIpe1xyXG4gICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcclxuICAgIGlmKG5vcm0+MC4wKXtcclxuICAgICAgICB2YXIgbiA9IFZlYzNfdGFuZ2VudHNfbjtcclxuICAgICAgICB2YXIgaW5vcm0gPSAxL25vcm07XHJcbiAgICAgICAgbi5zZXQodGhpcy54Kmlub3JtLHRoaXMueSppbm9ybSx0aGlzLnoqaW5vcm0pO1xyXG4gICAgICAgIHZhciByYW5kVmVjID0gVmVjM190YW5nZW50c19yYW5kVmVjO1xyXG4gICAgICAgIGlmKE1hdGguYWJzKG4ueCkgPCAwLjkpe1xyXG4gICAgICAgICAgICByYW5kVmVjLnNldCgxLDAsMCk7XHJcbiAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYyx0MSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMCwxLDApO1xyXG4gICAgICAgICAgICBuLmNyb3NzKHJhbmRWZWMsdDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuLmNyb3NzKHQxLHQyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIG5vcm1hbCBsZW5ndGggaXMgemVybywgbWFrZSBzb21ldGhpbmcgdXBcclxuICAgICAgICB0MS5zZXQoMSwgMCwgMCk7XHJcbiAgICAgICAgdDIuc2V0KDAsIDEsIDApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRvIGEgbW9yZSByZWFkYWJsZSBmb3JtYXRcclxuICogQG1ldGhvZCB0b1N0cmluZ1xyXG4gKiBAcmV0dXJuIHN0cmluZ1xyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRvIGFuIGFycmF5XHJcbiAqIEBtZXRob2QgdG9BcnJheVxyXG4gKiBAcmV0dXJuIEFycmF5XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHZlY3Rvci5cclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSB7VmVjM30gc291cmNlXHJcbiAqIEByZXR1cm4ge1ZlYzN9IHRoaXNcclxuICovXHJcblZlYzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xyXG4gICAgdGhpcy54ID0gc291cmNlLng7XHJcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcclxuICAgIHRoaXMueiA9IHNvdXJjZS56O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG4gKiBAbWV0aG9kIGxlcnBcclxuICogQHBhcmFtIHtWZWMzfSB2XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24odix0LHRhcmdldCl7XHJcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcclxuICAgIHRhcmdldC54ID0geCArICh2LngteCkqdDtcclxuICAgIHRhcmdldC55ID0geSArICh2LnkteSkqdDtcclxuICAgIHRhcmdldC56ID0geiArICh2LnoteikqdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlY3RvciBlcXVhbHMgaXMgYWxtb3N0IGVxdWFsIHRvIGFub3RoZXIgb25lLlxyXG4gKiBAbWV0aG9kIGFsbW9zdEVxdWFsc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHZcclxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gKiBAcmV0dXJuIGJvb2xcclxuICovXHJcblZlYzMucHJvdG90eXBlLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHYscHJlY2lzaW9uKXtcclxuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcclxuICAgIH1cclxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngtdi54KT5wcmVjaXNpb24gfHxcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnktdi55KT5wcmVjaXNpb24gfHxcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnotdi56KT5wcmVjaXNpb24pe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXHJcbiAqIEBtZXRob2QgYWxtb3N0WmVyb1xyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5hbG1vc3RaZXJvID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcclxuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcclxuICAgIH1cclxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngpPnByZWNpc2lvbiB8fFxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMueSk+cHJlY2lzaW9uIHx8XHJcbiAgICAgICAgTWF0aC5hYnModGhpcy56KT5wcmVjaXNpb24pe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxudmFyIGFudGlwX25lZyA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLlxyXG4gKiBAbWV0aG9kIGlzQW50aXBhcmFsbGVsVG9cclxuICogQHBhcmFtICB7VmVjM30gIHZcclxuICogQHBhcmFtICB7TnVtYmVyfSAgcHJlY2lzaW9uIFNldCB0byB6ZXJvIGZvciBleGFjdCBjb21wYXJpc29uc1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuVmVjMy5wcm90b3R5cGUuaXNBbnRpcGFyYWxsZWxUbyA9IGZ1bmN0aW9uKHYscHJlY2lzaW9uKXtcclxuICAgIHRoaXMubmVnYXRlKGFudGlwX25lZyk7XHJcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2LHByZWNpc2lvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIGNsb25lXHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5WZWMzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7XHJcbn07XHJcbn0se1wiLi9NYXQzXCI6Mjl9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcclxuXHJcbnZhciBFdmVudFRhcmdldCA9IF9kZXJlcV8oJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XHJcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XHJcbnZhciBXb3JsZCA9IF9kZXJlcV8oJy4uL3dvcmxkL1dvcmxkJyk7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXHJcbiAqIEBjbGFzcyBCb2R5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucG9zaXRpb25dXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5XVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IFtvcHRpb25zLnF1YXRlcm5pb25dXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxyXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR5cGVdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjAxXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXA9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdD0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5saW5lYXJGYWN0b3JdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhckZhY3Rvcl1cclxuICogQHBhcmFtIHtTaGFwZX0gW29wdGlvbnMuc2hhcGVdXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcclxuICogICAgICAgICBtYXNzOiAxXHJcbiAqICAgICB9KTtcclxuICogICAgIHZhciBzaGFwZSA9IG5ldyBTcGhlcmUoMSk7XHJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcclxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHdvcmxkIHRoZSBib2R5IGlzIGxpdmluZyBpblxyXG4gICAgICogQHByb3BlcnR5IHdvcmxkXHJcbiAgICAgKiBAdHlwZSB7V29ybGR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEJFRk9SRSBzdGVwcGluZyB0aGUgc3lzdGVtLiBVc2UgaXQgdG8gYXBwbHkgZm9yY2VzLCBmb3IgZXhhbXBsZS4gSW5zaWRlIHRoZSBmdW5jdGlvbiwgXCJ0aGlzXCIgd2lsbCByZWZlciB0byB0aGlzIEJvZHkgb2JqZWN0LlxyXG4gICAgICogQHByb3BlcnR5IHByZVN0ZXBcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBXb3JsZCBldmVudHMgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZVN0ZXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEFGVEVSIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cclxuICAgICAqIEBwcm9wZXJ0eSBwb3N0U3RlcFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQgc3BhY2UgcG9zaXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwb2xhdGVkIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnRlcnBvbGF0ZWRQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGJvZHlcclxuICAgICAqIEBwcm9wZXJ0eSBpbml0UG9zaXRpb25cclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmluaXRQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV29ybGQgc3BhY2UgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5LmNvcHkob3B0aW9ucy52ZWxvY2l0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgaW5pdFZlbG9jaXR5XHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5IGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICogQHByb3BlcnR5IGZvcmNlXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgdmFyIG1hc3MgPSB0eXBlb2Yob3B0aW9ucy5tYXNzKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1hc3MgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IG1hc3NcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFzcyA9IG1hc3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxyXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmxpbmVhckRhbXBpbmcpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZWFyRGFtcGluZyA6IDAuMDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IChtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDKTtcclxuICAgIGlmKHR5cGVvZihvcHRpb25zLnR5cGUpID09PSB0eXBlb2YoQm9keS5TVEFUSUMpKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC5cclxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXHJcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXHJcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTcGVlZExpbWl0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxyXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBUaW1lTGltaXQpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxO1xyXG5cclxuICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xyXG5cclxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmxkIHNwYWNlIHJvdGF0aW9uYWwgZm9yY2Ugb24gdGhlIGJvZHksIGFyb3VuZCBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gdG9ycXVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmxkIHNwYWNlIG9yaWVudGF0aW9uIG9mIHRoZSBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IHF1YXRlcm5pb25cclxuICAgICAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluaXRRdWF0ZXJuaW9uXHJcbiAgICAgKiBAdHlwZSB7UXVhdGVybmlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IHByZXZpb3VzUXVhdGVybmlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnBvbGF0ZWQgb3JpZW50YXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IGludGVycG9sYXRlZFF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnF1YXRlcm5pb24pe1xyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICAgICAgdGhpcy5pbml0UXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiB3b3JsZCBzcGFjZS4gVGhpbmsgb2YgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgYXMgYSB2ZWN0b3IsIHdoaWNoIHRoZSBib2R5IHJvdGF0ZXMgYXJvdW5kLiBUaGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yIGRldGVybWluZXMgaG93IGZhc3QgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgdGhlIGJvZHkgcm90YXRlcy5cclxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgaWYob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpe1xyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNvcHkob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluaXRBbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xyXG4gICAgICogQHR5cGUge2FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gb2YgZWFjaCBTaGFwZSBpbiB0aGUgYm9keSwgZ2l2ZW4gaW4gbG9jYWwgQm9keSBzcGFjZS5cclxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZU9mZnNldHNcclxuICAgICAqIEB0eXBlIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWVudGF0aW9uIG9mIGVhY2ggU2hhcGUsIGdpdmVuIGluIGxvY2FsIEJvZHkgc3BhY2UuXHJcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVPcmllbnRhdGlvbnNcclxuICAgICAqIEB0eXBlIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZXJ0aWEgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnZJbmVydGlhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZCA9IG5ldyBNYXQzKCk7XHJcblxyXG4gICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnZJbmVydGlhU29sdmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IE1hdDMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2R5IHRvIHJvdGF0ZS4gTWFrZSBzdXJlIHRvIHJ1biAudXBkYXRlTWFzc1Byb3BlcnRpZXMoKSBhZnRlciBjaGFuZ2luZyB0aGlzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXNlIGdyYXZpdHkgP1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VHcmF2aXR5XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudXNlR3Jhdml0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYW5ndWxhckRhbXBpbmdcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIHByb3BlcnR5IHRvIGxpbWl0IHRoZSBtb3Rpb24gYWxvbmcgYW55IHdvcmxkIGF4aXMuICgxLDEsMSkgd2lsbCBhbGxvdyBtb3Rpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbGluZWFyRmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZWFyRmFjdG9yID0gbmV3IFZlYzMoMSwxLDEpO1xyXG4gICAgaWYob3B0aW9ucy5saW5lYXJGYWN0b3Ipe1xyXG4gICAgICAgIHRoaXMubGluZWFyRmFjdG9yLmNvcHkob3B0aW9ucy5saW5lYXJGYWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoaXMgcHJvcGVydHkgdG8gbGltaXQgdGhlIHJvdGF0aW9uYWwgbW90aW9uIGFsb25nIGFueSB3b3JsZCBheGlzLiAoMSwxLDEpIHdpbGwgYWxsb3cgcm90YXRpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYW5ndWxhckZhY3RvclxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ3VsYXJGYWN0b3IgPSBuZXcgVmVjMygxLDEsMSk7XHJcbiAgICBpZihvcHRpb25zLmFuZ3VsYXJGYWN0b3Ipe1xyXG4gICAgICAgIHRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KG9wdGlvbnMuYW5ndWxhckZhY3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXb3JsZCBzcGFjZSBib3VuZGluZyBib3ggb2YgdGhlIGJvZHkgYW5kIGl0cyBzaGFwZXMuXHJcbiAgICAgKiBAcHJvcGVydHkgYWFiYlxyXG4gICAgICogQHR5cGUge0FBQkJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdG8gYmUgdXBkYXRlZCBiZWZvcmUgdXNlLlxyXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvdGFsIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgQm9keSBpbmNsdWRpbmcgaXRzIHNoYXBlcywgcmVsYXRpdmUgdG8gYm9keS5wb3NpdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XHJcblxyXG4gICAgdGhpcy53bGFtYmRhID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICBpZihvcHRpb25zLnNoYXBlKXtcclxuICAgICAgICB0aGlzLmFkZFNoYXBlKG9wdGlvbnMuc2hhcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaGFzIHRyaWdnZXI/XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGFzVHJpZ2dlciA9IHRydWU7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG59XHJcbkJvZHkucHJvdG90eXBlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XHJcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2hcclxuICogb2YgdGhlIHR3byBib2RpZXMgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbi5cclxuICogQGV2ZW50IGNvbGxpZGVcclxuICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgd2FzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXHJcbiAqIEBwYXJhbSB7Q29udGFjdEVxdWF0aW9ufSBjb250YWN0IFRoZSBkZXRhaWxzIG9mIHRoZSBjb2xsaXNpb24uXHJcbiAqL1xyXG5Cb2R5LkNPTExJREVfRVZFTlRfTkFNRSA9IFwiY29sbGlkZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSBEWU5BTUlDXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xyXG5Cb2R5LkRZTkFNSUMgPSAxO1xyXG5cclxuLyoqXHJcbiAqIEEgc3RhdGljIGJvZHkgZG9lcyBub3QgbW92ZSBkdXJpbmcgc2ltdWxhdGlvbiBhbmQgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy4gU3RhdGljIGJvZGllcyBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgc2V0dGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkuIFRoZSB2ZWxvY2l0eSBvZiBhIHN0YXRpYyBib2R5IGlzIGFsd2F5cyB6ZXJvLiBTdGF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IFNUQVRJQ1xyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxuQm9keS5TVEFUSUMgPSAyO1xyXG5cclxuLyoqXHJcbiAqIEEga2luZW1hdGljIGJvZHkgbW92ZXMgdW5kZXIgc2ltdWxhdGlvbiBhY2NvcmRpbmcgdG8gaXRzIHZlbG9jaXR5LiBUaGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcy4gVGhleSBjYW4gYmUgbW92ZWQgbWFudWFsbHksIGJ1dCBub3JtYWxseSBhIGtpbmVtYXRpYyBib2R5IGlzIG1vdmVkIGJ5IHNldHRpbmcgaXRzIHZlbG9jaXR5LiBBIGtpbmVtYXRpYyBib2R5IGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MuIEtpbmVtYXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xyXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSBBV0FLRVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cclxuQm9keS5BV0FLRSA9IDA7XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgU0xFRVBZXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xyXG5Cb2R5LlNMRUVQWSA9IDE7XHJcblxyXG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgU0xFRVBJTkdcclxuICogQHR5cGUge251bWJlcn1cclxuICovXHJcbkJvZHkuU0xFRVBJTkcgPSAyO1xyXG5cclxuQm9keS5pZENvdW50ZXIgPSAwO1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBzbGVlcGluZyBib2R5IGhhcyB3b2tlbiB1cC5cclxuICogQGV2ZW50IHdha2V1cFxyXG4gKi9cclxuQm9keS53YWtldXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwid2FrZXVwXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXYWtlIHRoZSBib2R5IHVwLlxyXG4gKiBAbWV0aG9kIHdha2VVcFxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcclxuICAgIFdvcmxkLlNMRUVQSU5HID0gZmFsc2U7XHJcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcclxuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XHJcbiAgICB0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XHJcbiAgICBpZihzID09PSBCb2R5LlNMRUVQSU5HKXtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS53YWtldXBFdmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yY2UgYm9keSBzbGVlcFxyXG4gKiBAbWV0aG9kIHNsZWVwXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xyXG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwwLDApO1xyXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcclxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZ29uZSBpbiB0byB0aGUgc2xlZXB5IHN0YXRlLlxyXG4gKiBAZXZlbnQgc2xlZXB5XHJcbiAqL1xyXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJzbGVlcHlcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBmYWxsZW4gYXNsZWVwLlxyXG4gKiBAZXZlbnQgc2xlZXBcclxuICovXHJcbkJvZHkuc2xlZXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2xlZXBcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXHJcbiAqIEBtZXRob2Qgc2xlZXBUaWNrXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnNsZWVwVGljayA9IGZ1bmN0aW9uKHRpbWUpe1xyXG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcclxuICAgICAgICB2YXIgc2xlZXBTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTtcclxuICAgICAgICB2YXIgc3BlZWRTcXVhcmVkID0gdGhpcy52ZWxvY2l0eS5ub3JtMigpICsgdGhpcy5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcclxuICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcclxuICAgICAgICBpZihzbGVlcFN0YXRlPT09Qm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZOyAvLyBTbGVlcHlcclxuICAgICAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVweUV2ZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmIHNwZWVkU3F1YXJlZCA+IHNwZWVkTGltaXRTcXVhcmVkKXtcclxuICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxyXG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgKHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ICkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcclxuICAgICAgICAgICAgdGhpcy5zbGVlcCgpOyAvLyBTbGVlcGluZ1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cclxuICogQG1ldGhvZCB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcclxuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpO1xyXG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcclxuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYSk7XHJcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICogQG1ldGhvZCBwb2ludFRvTG9jYWxGcmFtZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUucG9pbnRUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFBvaW50LHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xyXG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCxyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXHJcbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFZlY3RvciwgcmVzdWx0KXtcclxuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh3b3JsZFZlY3RvcixyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICogQG1ldGhvZCBwb2ludFRvV29ybGRGcmFtZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUucG9pbnRUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFBvaW50LHJlc3VsdCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCxyZXN1bHQpO1xyXG4gICAgcmVzdWx0LnZhZGQodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcclxuICogQHBhcmFtICB7VmVjM30gbG9jYWxWZWN0b3JcclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcclxuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgdG1wVmVjID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLlxyXG4gKiBAbWV0aG9kIGFkZFNoYXBlXHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXHJcbiAqIEBwYXJhbSB7VmVjM30gW19vZmZzZXRdXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW19vcmllbnRhdGlvbl1cclxuICogQHJldHVybiB7Qm9keX0gVGhlIGJvZHkgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gKi9cclxuQm9keS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgX29mZnNldCwgX29yaWVudGF0aW9uKXtcclxuICAgIHZhciBvZmZzZXQgPSBuZXcgVmVjMygpO1xyXG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbiAgICBpZihfb2Zmc2V0KXtcclxuICAgICAgICBvZmZzZXQuY29weShfb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGlmKF9vcmllbnRhdGlvbil7XHJcbiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xyXG4gICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpO1xyXG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcclxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUhhc1RyaWdnZXIoKTtcclxuICAgIFdvcmxkLmlkVG9TaGFwZU1hcFtzaGFwZS5pZF0gPSBzaGFwZTtcclxuICAgIHNoYXBlLmJvZHkgPSB0aGlzO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIHNoYXBlIGZyb20gdGhlIGJvZHlcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUpeyAgIFxyXG4gICAgdmFyIGlkeCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpO1xyXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBzaGFwZS5ib2R5ID0gbnVsbDsgIG5lZWRlZCA/XHJcbiAgICAvLyBkZWxldGUgV29ybGQuaWRUb1NoYXBlTWFwW3NoYXBlLmlkXTsgIG5lZWRlZCA/XHJcblxyXG4gICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB0aGlzLnNoYXBlT2Zmc2V0cy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMuc3BsaWNlKGlkeCwgMSk7XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xyXG4gICAgdGhpcy51cGRhdGVIYXNUcmlnZ2VyKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuXHJcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcclxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcclxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcclxuICAgICAgICByYWRpdXMgPSAwO1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XHJcbiAgICAgICAgc2hhcGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLm5vcm0oKSxcclxuICAgICAgICAgICAgciA9IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzO1xyXG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xyXG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzO1xyXG59O1xyXG5cclxudmFyIGNvbXB1dGVBQUJCX3NoYXBlQUFCQiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgLmFhYmJcclxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gKiBAdG9kbyByZW5hbWUgdG8gdXBkYXRlQUFCQigpXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXHJcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXHJcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zLFxyXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxyXG4gICAgICAgIG9mZnNldCA9IHRtcFZlYyxcclxuICAgICAgICBvcmllbnRhdGlvbiA9IHRtcFF1YXQsXHJcbiAgICAgICAgYm9keVF1YXQgPSB0aGlzLnF1YXRlcm5pb24sXHJcbiAgICAgICAgYWFiYiA9IHRoaXMuYWFiYixcclxuICAgICAgICBzaGFwZUFBQkIgPSBjb21wdXRlQUFCQl9zaGFwZUFBQkI7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgYm9keVF1YXQudm11bHQoc2hhcGVPZmZzZXRzW2ldLCBvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldC52YWRkKHRoaXMucG9zaXRpb24sIG9mZnNldCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBxdWF0ZXJuaW9uXHJcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnNbaV0ubXVsdChib2R5UXVhdCwgb3JpZW50YXRpb24pO1xyXG5cclxuICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxyXG4gICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpO1xyXG5cclxuICAgICAgICBpZihpID09PSAwKXtcclxuICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWFiYi5leHRlbmQoc2hhcGVBQUJCKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxufTtcclxuXHJcbnZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxyXG4gICAgdWl3X20yID0gbmV3IE1hdDMoKSxcclxuICAgIHVpd19tMyA9IG5ldyBNYXQzKCk7XHJcblxyXG4vKipcclxuICogVXBkYXRlIC5pbmVydGlhV29ybGQgYW5kIC5pbnZJbmVydGlhV29ybGRcclxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcclxuICovXHJcbkJvZHkucHJvdG90eXBlLnVwZGF0ZUluZXJ0aWFXb3JsZCA9IGZ1bmN0aW9uKGZvcmNlKXtcclxuICAgIHZhciBJID0gdGhpcy5pbnZJbmVydGlhO1xyXG4gICAgaWYgKEkueCA9PT0gSS55ICYmIEkueSA9PT0gSS56ICYmICFmb3JjZSkge1xyXG4gICAgICAgIC8vIElmIGluZXJ0aWEgTSA9IHMqSSwgd2hlcmUgSSBpcyBpZGVudGl0eSBhbmQgcyBhIHNjYWxhciwgdGhlblxyXG4gICAgICAgIC8vICAgIFIqTSpSJyA9IFIqKHMqSSkqUicgPSBzKlIqSSpSJyA9IHMqUipSJyA9IHMqSSA9IE1cclxuICAgICAgICAvLyB3aGVyZSBSIGlzIHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIHdlIGRvbid0IGhhdmUgdG8gdHJhbnNmb3JtIHRoZSBpbmVydGlhIGlmIGFsbFxyXG4gICAgICAgIC8vIGluZXJ0aWEgZGlhZ29uYWwgZW50cmllcyBhcmUgZXF1YWwuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBtMSA9IHVpd19tMSxcclxuICAgICAgICAgICAgbTIgPSB1aXdfbTIsXHJcbiAgICAgICAgICAgIG0zID0gdWl3X20zO1xyXG4gICAgICAgIG0xLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcclxuICAgICAgICBtMS50cmFuc3Bvc2UobTIpO1xyXG4gICAgICAgIG0xLnNjYWxlKEksbTEpO1xyXG4gICAgICAgIG0xLm1tdWx0KG0yLHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS50b3JxdWUuXHJcbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC5cclxuICogQHBhcmFtICB7VmVjM30gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG52YXIgQm9keV9hcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlLHJlbGF0aXZlUG9pbnQpe1xyXG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpeyAvLyBOZWVkZWQ/XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgdmFyIHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlO1xyXG4gICAgcmVsYXRpdmVQb2ludC5jcm9zcyhmb3JjZSxyb3RGb3JjZSk7XHJcblxyXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxyXG4gICAgdGhpcy5mb3JjZS52YWRkKGZvcmNlLHRoaXMuZm9yY2UpO1xyXG5cclxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLHRoaXMudG9ycXVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBmb3JjZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxyXG4gKiBAbWV0aG9kIGFwcGx5TG9jYWxGb3JjZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG52YXIgQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRGb3JjZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQgPSBuZXcgVmVjMygpO1xyXG5Cb2R5LnByb3RvdHlwZS5hcHBseUxvY2FsRm9yY2UgPSBmdW5jdGlvbihsb2NhbEZvcmNlLCBsb2NhbFBvaW50KXtcclxuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlO1xyXG4gICAgdmFyIHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3JlbGF0aXZlUG9pbnRXb3JsZDtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvcmNlIHZlY3RvciB0byB3b3JsZCBzcGFjZVxyXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxGb3JjZSwgd29ybGRGb3JjZSk7XHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMuYXBwbHlGb3JjZSh3b3JsZEZvcmNlLCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGltcHVsc2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxyXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlbGF0aXZlUG9pbnQgQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3MgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxyXG4gKi9cclxudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3IgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7XHJcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9yb3RWZWxvID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgcmVsYXRpdmVQb2ludCl7XHJcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyXHJcbiAgICB2YXIgciA9IHJlbGF0aXZlUG9pbnQ7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcclxuICAgIHZlbG8uY29weShpbXB1bHNlKTtcclxuICAgIHZlbG8ubXVsdCh0aGlzLmludk1hc3MsdmVsbyk7XHJcblxyXG4gICAgLy8gQWRkIGxpbmVhciBpbXB1bHNlXHJcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQodmVsbywgdGhpcy52ZWxvY2l0eSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgIHZhciByb3RWZWxvID0gQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbztcclxuICAgIHIuY3Jvc3MoaW1wdWxzZSxyb3RWZWxvKTtcclxuXHJcbiAgICAvKlxyXG4gICAgcm90VmVsby54ICo9IHRoaXMuaW52SW5lcnRpYS54O1xyXG4gICAgcm90VmVsby55ICo9IHRoaXMuaW52SW5lcnRpYS55O1xyXG4gICAgcm90VmVsby56ICo9IHRoaXMuaW52SW5lcnRpYS56O1xyXG4gICAgKi9cclxuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkLnZtdWx0KHJvdFZlbG8scm90VmVsbyk7XHJcblxyXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxyXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkudmFkZChyb3RWZWxvLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgbG9jYWxseS1kZWZpbmVkIGltcHVsc2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cclxuICogQG1ldGhvZCBhcHBseUxvY2FsSW1wdWxzZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xyXG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpO1xyXG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTtcclxuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEltcHVsc2UgPSBmdW5jdGlvbihsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpe1xyXG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7XHJcbiAgICB2YXIgcmVsYXRpdmVQb2ludFdvcmxkID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50O1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEltcHVsc2UsIHdvcmxkSW1wdWxzZSk7XHJcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xyXG5cclxuICAgIHRoaXMuYXBwbHlJbXB1bHNlKHdvcmxkSW1wdWxzZSwgcmVsYXRpdmVQb2ludFdvcmxkKTtcclxufTtcclxuXHJcbnZhciBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGJvZHkgc2hhcGUgb3IgbWFzcy5cclxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xyXG4gKi9cclxuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGhhbGZFeHRlbnRzID0gQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cztcclxuXHJcbiAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDtcclxuICAgIHZhciBJID0gdGhpcy5pbmVydGlhO1xyXG4gICAgdmFyIGZpeGVkID0gdGhpcy5maXhlZFJvdGF0aW9uO1xyXG5cclxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcclxuICAgIHRoaXMuY29tcHV0ZUFBQkIoKTtcclxuICAgIGhhbGZFeHRlbnRzLnNldChcclxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXHJcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnktdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLFxyXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC56LXRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMlxyXG4gICAgKTtcclxuICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpO1xyXG5cclxuICAgIHRoaXMuaW52SW5lcnRpYS5zZXQoXHJcbiAgICAgICAgSS54ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnggOiAwLFxyXG4gICAgICAgIEkueSA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS55IDogMCxcclxuICAgICAgICBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDBcclxuICAgICk7XHJcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cclxuICogQG1ldGhvZCBnZXRWZWxvY2l0eUF0V29ybGRQb2ludFxyXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IHZlY3Rvci5cclxuICovXHJcbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcclxuICAgIHZhciByID0gbmV3IFZlYzMoKTtcclxuICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTtcclxuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XHJcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQocmVzdWx0LCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnZhciB0b3JxdWUgPSBuZXcgVmVjMygpO1xyXG52YXIgaW52SV90YXVfZHQgPSBuZXcgVmVjMygpO1xyXG52YXIgdyA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbnZhciB3cSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4vKipcclxuICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaW1lIHN0ZXBcclxuICogQHBhcmFtIHtib29sZWFufSBxdWF0Tm9ybWFsaXplIFNldCB0byB0cnVlIHRvIG5vcm1hbGl6ZSB0aGUgYm9keSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVhdE5vcm1hbGl6ZUZhc3QgSWYgdGhlIHF1YXRlcm5pb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWQgdXNpbmcgXCJmYXN0XCIgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihkdCwgcXVhdE5vcm1hbGl6ZSwgcXVhdE5vcm1hbGl6ZUZhc3Qpe1xyXG5cclxuICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb25cclxuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG4gICAgdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weSh0aGlzLnF1YXRlcm5pb24pO1xyXG5cclxuICAgIGlmKCEodGhpcy50eXBlID09PSBCb2R5LkRZTkFNSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykgfHwgdGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXsgLy8gT25seSBmb3IgZHluYW1pY1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmVsbyA9IHRoaXMudmVsb2NpdHksXHJcbiAgICAgICAgYW5ndWxhclZlbG8gPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSxcclxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgIGZvcmNlID0gdGhpcy5mb3JjZSxcclxuICAgICAgICB0b3JxdWUgPSB0aGlzLnRvcnF1ZSxcclxuICAgICAgICBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uLFxyXG4gICAgICAgIGludk1hc3MgPSB0aGlzLmludk1hc3MsXHJcbiAgICAgICAgaW52SW5lcnRpYSA9IHRoaXMuaW52SW5lcnRpYVdvcmxkLFxyXG4gICAgICAgIGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yO1xyXG5cclxuICAgIHZhciBpTWR0ID0gaW52TWFzcyAqIGR0O1xyXG4gICAgdmVsby54ICs9IGZvcmNlLnggKiBpTWR0ICogbGluZWFyRmFjdG9yLng7XHJcbiAgICB2ZWxvLnkgKz0gZm9yY2UueSAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueTtcclxuICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56O1xyXG5cclxuICAgIHZhciBlID0gaW52SW5lcnRpYS5lbGVtZW50cztcclxuICAgIHZhciBhbmd1bGFyRmFjdG9yID0gdGhpcy5hbmd1bGFyRmFjdG9yO1xyXG4gICAgdmFyIHR4ID0gdG9ycXVlLnggKiBhbmd1bGFyRmFjdG9yLng7XHJcbiAgICB2YXIgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTtcclxuICAgIHZhciB0eiA9IHRvcnF1ZS56ICogYW5ndWxhckZhY3Rvci56O1xyXG4gICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdHggKyBlWzFdICogdHkgKyBlWzJdICogdHopO1xyXG4gICAgYW5ndWxhclZlbG8ueSArPSBkdCAqIChlWzNdICogdHggKyBlWzRdICogdHkgKyBlWzVdICogdHopO1xyXG4gICAgYW5ndWxhclZlbG8ueiArPSBkdCAqIChlWzZdICogdHggKyBlWzddICogdHkgKyBlWzhdICogdHopO1xyXG5cclxuICAgIC8vIFVzZSBuZXcgdmVsb2NpdHkgIC0gbGVhcCBmcm9nXHJcbiAgICBwb3MueCArPSB2ZWxvLnggKiBkdDtcclxuICAgIHBvcy55ICs9IHZlbG8ueSAqIGR0O1xyXG4gICAgcG9zLnogKz0gdmVsby56ICogZHQ7XHJcblxyXG4gICAgcXVhdC5pbnRlZ3JhdGUodGhpcy5hbmd1bGFyVmVsb2NpdHksIGR0LCB0aGlzLmFuZ3VsYXJGYWN0b3IsIHF1YXQpO1xyXG5cclxuICAgIGlmKHF1YXROb3JtYWxpemUpe1xyXG4gICAgICAgIGlmKHF1YXROb3JtYWxpemVGYXN0KXtcclxuICAgICAgICAgICAgcXVhdC5ub3JtYWxpemVGYXN0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB3b3JsZCBpbmVydGlhXHJcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIFNsZWVwaW5nXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS5pc1NsZWVwaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJcyBTbGVlcHlcclxuICovXHJcbkJvZHkucHJvdG90eXBlLmlzU2xlZXB5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZO1xyXG59XHJcblxyXG4vKipcclxuICogSXMgQXdha2VcclxuICovXHJcbkJvZHkucHJvdG90eXBlLmlzQXdha2UgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBoYXNUcmlnZ2VyXHJcbiAqL1xyXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVIYXNUcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2hhcGVzLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICAgIHRoaXMuaGFzVHJpZ2dlciA9ICF0aGlzLnNoYXBlc1tpXS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgICAgICBpZiAodGhpcy5oYXNUcmlnZ2VyKSBicmVhaztcclxuICAgIH1cclxufVxyXG5cclxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI2LFwiLi4vbWF0aC9NYXQzXCI6MjksXCIuLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vc2hhcGVzL0JveFwiOjM5LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjUxLFwiLi4vd29ybGQvV29ybGRcIjo1OH1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuL0JvZHknKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xyXG52YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xyXG52YXIgV2hlZWxJbmZvID0gX2RlcmVxXygnLi4vb2JqZWN0cy9XaGVlbEluZm8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFZlaGljbGU7XHJcblxyXG4vKipcclxuICogVmVoaWNsZSBoZWxwZXIgY2xhc3MgdGhhdCBjYXN0cyByYXlzIGZyb20gdGhlIHdoZWVsIHBvc2l0aW9ucyB0b3dhcmRzIHRoZSBncm91bmQgYW5kIGFwcGxpZXMgZm9yY2VzLlxyXG4gKiBAY2xhc3MgUmF5Y2FzdFZlaGljbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV0gVGhlIGNhciBjaGFzc2lzIGJvZHkuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmluZGV4TGVmdEF4aXNdXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhVcEF4aXNdXHJcbiAqL1xyXG5mdW5jdGlvbiBSYXljYXN0VmVoaWNsZShvcHRpb25zKXtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gY2hhc3Npc0JvZHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHdoZWVsSW5mb3NcclxuICAgICAqL1xyXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2xpZGluZ1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhGb3J3YXJkQXhpc1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZGV4Rm9yd2FyZEF4aXMgPSB0eXBlb2Yob3B0aW9ucy5pbmRleEZvcndhcmRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHVwIGF4aXMsIDA9eCwgMT15LCAyPXpcclxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhVcEF4aXNcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleFVwQXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4VXBBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4VXBBeGlzIDogMjtcclxufVxyXG5cclxudmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWMzID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFZlYzQgPSBuZXcgVmVjMygpO1xyXG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWM2ID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSB3aGVlbC4gRm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zLCBzZWUgV2hlZWxJbmZvLlxyXG4gKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICovXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy53aGVlbEluZm9zLmxlbmd0aDtcclxuICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pO1xyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXHJcbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcclxuICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XTtcclxuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXHJcbiAqIEBtZXRob2QgYXBwbHlFbmdpbmVGb3JjZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hcHBseUVuZ2luZUZvcmNlID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBicmFraW5nIGZvcmNlIG9mIGEgd2hlZWxcclxuICogQG1ldGhvZCBzZXRCcmFrZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XHJcbiAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXHJcbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XHJcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xyXG4gICAgd29ybGQuYWRkQm9keSh0aGlzLmNoYXNzaXNCb2R5KTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGF0LnVwZGF0ZVZlaGljbGUod29ybGQuZHQpO1xyXG4gICAgfTtcclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XHJcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG9uZSBvZiB0aGUgd2hlZWwgYXhsZXMsIHdvcmxkLW9yaWVudGVkLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIGdldFZlaGljbGVBeGlzV29ybGRcclxuICogQHBhcmFtICB7aW50ZWdlcn0gYXhpc0luZGV4XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFZlaGljbGVBeGlzV29ybGQgPSBmdW5jdGlvbihheGlzSW5kZXgsIHJlc3VsdCl7XHJcbiAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMSA/IDEgOiAwLFxyXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMiA/IDEgOiAwXHJcbiAgICApO1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVzdWx0LCByZXN1bHQpO1xyXG59O1xyXG5cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVZlaGljbGUgPSBmdW5jdGlvbih0aW1lU3RlcCl7XHJcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcclxuICAgIHZhciBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMy42ICogY2hhc3Npc0JvZHkudmVsb2NpdHkubm9ybSgpO1xyXG5cclxuICAgIHZhciBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5nZXRWZWhpY2xlQXhpc1dvcmxkKHRoaXMuaW5kZXhGb3J3YXJkQXhpcywgZm9yd2FyZFdvcmxkKTtcclxuXHJcbiAgICBpZiAoZm9yd2FyZFdvcmxkLmRvdChjaGFzc2lzQm9keS52ZWxvY2l0eSkgPCAwKXtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgKj0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2ltdWxhdGUgc3VzcGVuc2lvblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZVN1c3BlbnNpb24odGltZVN0ZXApO1xyXG5cclxuICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xyXG4gICAgICAgIC8vYXBwbHkgc3VzcGVuc2lvbiBmb3JjZVxyXG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XHJcbiAgICAgICAgdmFyIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZTtcclxuICAgICAgICBpZiAoc3VzcGVuc2lvbkZvcmNlID4gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShzdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCwgaW1wdWxzZSk7XHJcblxyXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xyXG4gICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlRnJpY3Rpb24odGltZVN0ZXApO1xyXG5cclxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciBmd2QgID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciB2ZWwgPSBuZXcgVmVjMygpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICAvL3ZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XHJcbiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCB2ZWwpO1xyXG5cclxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXHJcbiAgICAgICAgdmFyIG0gPSAxO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLmluZGV4VXBBeGlzKXtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIG0gPSAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9qID0gZndkLmRvdCh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcclxuXHJcbiAgICAgICAgICAgIGZ3ZC52c3ViKGhpdE5vcm1hbFdvcmxkU2NhbGVkV2l0aFByb2osIGZ3ZCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvajIgPSBmd2QuZG90KHZlbCk7XHJcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSBtICogcHJvajIgKiB0aW1lU3RlcCAvIHdoZWVsLnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCh3aGVlbC5zbGlkaW5nIHx8ICF3aGVlbC5pc0luQ29udGFjdCkgJiYgd2hlZWwuZW5naW5lRm9yY2UgIT09IDAgJiYgd2hlZWwudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCl7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xyXG4gICAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gKHdoZWVsLmVuZ2luZUZvcmNlID4gMCA/IDEgOiAtMSkgKiB3aGVlbC5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkICogdGltZVN0ZXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2NrIHdoZWVsc1xyXG4gICAgICAgIGlmKE1hdGguYWJzKHdoZWVsLmJyYWtlKSA+IE1hdGguYWJzKHdoZWVsLmVuZ2luZUZvcmNlKSl7XHJcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcclxuICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uICo9IDAuOTk7IC8vIGRhbXBpbmcgb2Ygcm90YXRpb24gd2hlbiBub3QgaW4gY29udGFjdFxyXG4gICAgfVxyXG59O1xyXG5cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVN1c3BlbnNpb24gPSBmdW5jdGlvbihkZWx0YVRpbWUpIHtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcbiAgICB2YXIgY2hhc3Npc01hc3MgPSBjaGFzc2lzQm9keS5tYXNzO1xyXG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XHJcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XHJcblxyXG4gICAgZm9yICh2YXIgd19pdCA9IDA7IHdfaXQgPCBudW1XaGVlbHM7IHdfaXQrKyl7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcclxuXHJcbiAgICAgICAgaWYgKHdoZWVsLmlzSW5Db250YWN0KXtcclxuICAgICAgICAgICAgdmFyIGZvcmNlO1xyXG5cclxuICAgICAgICAgICAgLy8gU3ByaW5nXHJcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSAoc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25TdGlmZm5lc3MgKiBsZW5ndGhfZGlmZiAqIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIERhbXBlclxyXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkX3JlbF92ZWwgPSB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTtcclxuICAgICAgICAgICAgdmFyIHN1c3BfZGFtcGluZztcclxuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ0NvbXByZXNzaW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yY2UgLT0gc3VzcF9kYW1waW5nICogcHJvamVjdGVkX3JlbF92ZWw7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSBmb3JjZSAqIGNoYXNzaXNNYXNzO1xyXG4gICAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxyXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XHJcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XHJcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5wcmVTdGVwQ2FsbGJhY2spO1xyXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XHJcbn07XHJcblxyXG52YXIgY2FzdFJheV9yYXl2ZWN0b3IgPSBuZXcgVmVjMygpO1xyXG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuY2FzdFJheSA9IGZ1bmN0aW9uKHdoZWVsKSB7XHJcbiAgICB2YXIgcmF5dmVjdG9yID0gY2FzdFJheV9yYXl2ZWN0b3I7XHJcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XHJcblxyXG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcblxyXG4gICAgdmFyIGRlcHRoID0gLTE7XHJcblxyXG4gICAgdmFyIHJheWxlbiA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwucmFkaXVzO1xyXG5cclxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcclxuICAgIHZhciBzb3VyY2UgPSB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ7XHJcbiAgICBzb3VyY2UudmFkZChyYXl2ZWN0b3IsIHRhcmdldCk7XHJcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XHJcblxyXG4gICAgdmFyIHBhcmFtID0gMDtcclxuXHJcbiAgICByYXljYXN0UmVzdWx0LnJlc2V0KCk7XHJcbiAgICAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHlcclxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXHJcbiAgICB0aGlzLndvcmxkLnJheVRlc3Qoc291cmNlLCB0YXJnZXQsIHJheWNhc3RSZXN1bHQpO1xyXG4gICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBvbGRTdGF0ZTtcclxuXHJcbiAgICB2YXIgb2JqZWN0ID0gcmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcclxuXHJcbiAgICBpZiAob2JqZWN0KSB7XHJcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xyXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQgID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcclxuICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBoaXREaXN0YW5jZSA9IHJheWNhc3RSZXN1bHQuZGlzdGFuY2U7XHJcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IGhpdERpc3RhbmNlIC0gd2hlZWwucmFkaXVzO1xyXG5cclxuICAgICAgICAvLyBjbGFtcCBvbiBtYXggc3VzcGVuc2lvbiB0cmF2ZWxcclxuICAgICAgICB2YXIgbWluU3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoIC0gd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA8IG1pblN1c3BlbnNpb25MZW5ndGgpIHtcclxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1pblN1c3BlbnNpb25MZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkge1xyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWF4U3VzcGVuc2lvbkxlbmd0aDtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xyXG5cclxuICAgICAgICB2YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xyXG5cclxuICAgICAgICB2YXIgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCApO1xyXG5cclxuICAgICAgICBpZiAoZGVub21pbmF0b3IgPj0gLTAuMSkge1xyXG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGludiA9IC0xIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcclxuICAgICAgICAgICAgd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cclxuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggKyAwICogd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcclxuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcclxuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XHJcbiAgICAgICAgd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMS4wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZXB0aDtcclxufTtcclxuXHJcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWwpe1xyXG4gICAgd2hlZWwuaXNJbkNvbnRhY3QgPSBmYWxzZTtcclxuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XHJcbiAgICBjaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZSh3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwsIHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCk7XHJcbiAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUod2hlZWwuZGlyZWN0aW9uTG9jYWwsIHdoZWVsLmRpcmVjdGlvbldvcmxkKTtcclxuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBvbmUgb2YgdGhlIHdoZWVsIHRyYW5zZm9ybS5cclxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXHJcbiAqIEBtZXRob2QgdXBkYXRlV2hlZWxUcmFuc2Zvcm1cclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4IFRoZSB3aGVlbCBpbmRleCB0byB1cGRhdGUuXHJcbiAqL1xyXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm0gPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcclxuICAgIHZhciB1cCA9IHRtcFZlYzQ7XHJcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xyXG4gICAgdmFyIGZ3ZCA9IHRtcFZlYzY7XHJcblxyXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xyXG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcclxuXHJcbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xyXG4gICAgcmlnaHQuY29weSh3aGVlbC5heGxlTG9jYWwpO1xyXG4gICAgdXAuY3Jvc3MocmlnaHQsIGZ3ZCk7XHJcbiAgICBmd2Qubm9ybWFsaXplKCk7XHJcbiAgICByaWdodC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxyXG4gICAgdmFyIHN0ZWVyaW5nID0gd2hlZWwuc3RlZXJpbmc7XHJcbiAgICB2YXIgc3RlZXJpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xyXG5cclxuICAgIHZhciByb3RhdGluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XHJcblxyXG4gICAgLy8gV29ybGQgcm90YXRpb24gb2YgdGhlIHdoZWVsXHJcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XHJcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7XHJcbiAgICBxLm11bHQocm90YXRpbmdPcm4sIHEpO1xyXG5cclxuICAgIHEubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXHJcbiAgICB2YXIgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgcC5jb3B5KHdoZWVsLmRpcmVjdGlvbldvcmxkKTtcclxuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XHJcbiAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTtcclxufTtcclxuXHJcbnZhciBkaXJlY3Rpb25zID0gW1xyXG4gICAgbmV3IFZlYzMoMSwgMCwgMCksXHJcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcclxuICAgIG5ldyBWZWMzKDAsIDAsIDEpXHJcbl07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHNcclxuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICogQHJldHVybiB7VHJhbnNmb3JtfVxyXG4gKi9cclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsVHJhbnNmb3JtV29ybGQgPSBmdW5jdGlvbih3aGVlbEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLndvcmxkVHJhbnNmb3JtO1xyXG59O1xyXG5cclxuXHJcbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xyXG52YXIgdXBkYXRlRnJpY3Rpb25fYXhsZSA9IFtdO1xyXG52YXIgdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTID0gW107XHJcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcclxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZUZyaWN0aW9uID0gZnVuY3Rpb24odGltZVN0ZXApIHtcclxuICAgIHZhciBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7XHJcblxyXG4gICAgLy9jYWxjdWxhdGUgdGhlIGltcHVsc2UsIHNvIHRoYXQgdGhlIHdoZWVscyBkb24ndCBtb3ZlIHNpZGV3YXJkc1xyXG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XHJcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XHJcbiAgICB2YXIgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5O1xyXG4gICAgdmFyIGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUztcclxuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcclxuXHJcbiAgICB2YXIgbnVtV2hlZWxzT25Hcm91bmQgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xyXG5cclxuICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG4gICAgICAgIGlmIChncm91bmRPYmplY3Qpe1xyXG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xyXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcclxuICAgICAgICBpZighZm9yd2FyZFdTW2ldKXtcclxuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWF4bGVbaV0pe1xyXG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKyl7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYXhsZWkgPSBheGxlW2ldO1xyXG4gICAgICAgICAgICB2YXIgd2hlZWxUcmFucyA9IHRoaXMuZ2V0V2hlZWxUcmFuc2Zvcm1Xb3JsZChpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBheGxlXHJcbiAgICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdXJmTm9ybWFsV1MgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkO1xyXG4gICAgICAgICAgICB2YXIgcHJvaiA9IGF4bGVpLmRvdChzdXJmTm9ybWFsV1MpO1xyXG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcclxuICAgICAgICAgICAgYXhsZWkudnN1YihzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2osIGF4bGVpKTtcclxuICAgICAgICAgICAgYXhsZWkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBzdXJmTm9ybWFsV1MuY3Jvc3MoYXhsZWksIGZvcndhcmRXU1tpXSk7XHJcbiAgICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChcclxuICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LFxyXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICAgICAgZ3JvdW5kT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxyXG4gICAgICAgICAgICAgICAgYXhsZWlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaWRlRmFjdG9yID0gMTtcclxuICAgIHZhciBmd2RGYWN0b3IgPSAwLjU7XHJcblxyXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcclxuXHJcbiAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxO1xyXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSB3aGVlbC5icmFrZSA/IHdoZWVsLmJyYWtlIDogZGVmYXVsdFJvbGxpbmdGcmljdGlvbkltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBidFdoZWVsQ29udGFjdFBvaW50IGNvbnRhY3RQdChjaGFzc2lzQm9keSxncm91bmRPYmplY3Qsd2hlZWxJbmZyYXljYXN0SW5mby5oaXRQb2ludFdvcmxkLGZvcndhcmRXU1t3aGVlbF0sbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgIC8vIHJvbGxpbmdGcmljdGlvbiA9IGNhbGNSb2xsaW5nRnJpY3Rpb24oY29udGFjdFB0KTtcclxuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XHJcblxyXG4gICAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDtcclxuXHJcbiAgICAgICAgICAgIC8vIHJvbGxpbmdGcmljdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uO1xyXG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxyXG5cclxuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XHJcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xyXG5cclxuICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXhpbXAgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCAqIHdoZWVsLmZyaWN0aW9uU2xpcDtcclxuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF4aW1wU3F1YXJlZCA9IG1heGltcCAqIG1heGltcFNpZGU7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IHJvbGxpbmdGcmljdGlvbjsvL3doZWVsSW5mby5lbmdpbmVGb3JjZSogdGltZVN0ZXA7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHdoZWVsLnNpZGVJbXB1bHNlICogc2lkZUZhY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XHJcblxyXG4gICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gbWF4aW1wIC8gTWF0aC5zcXJ0KGltcHVsc2VTcXVhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGluZykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcclxuICAgICAgICAgICAgaWYgKHdoZWVsLnNpZGVJbXB1bHNlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcclxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSAqPSB3aGVlbC5za2lkSW5mbztcclxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSAqPSB3aGVlbC5za2lkSW5mbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBseSB0aGUgaW1wdWxzZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcclxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xyXG5cclxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpO1xyXG4gICAgICAgIC8vIGNhbm5vbnMgYXBwbHlpbXB1bHNlIGlzIHVzaW5nIHdvcmxkIGNvb3JkIGZvciB0aGUgcG9zaXRpb25cclxuICAgICAgICAvL3JlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xyXG5cclxuICAgICAgICBpZiAod2hlZWwuZm9yd2FyZEltcHVsc2UgIT09IDApIHtcclxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgICAgICBmb3J3YXJkV1NbaV0uc2NhbGUod2hlZWwuZm9yd2FyZEltcHVsc2UsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVsX3Bvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApe1xyXG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlbF9wb3MyID0gbmV3IFZlYzMoKTtcclxuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoZ3JvdW5kT2JqZWN0LnBvc2l0aW9uLCByZWxfcG9zMik7XHJcbiAgICAgICAgICAgIC8vcmVsX3BvczIuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xyXG4gICAgICAgICAgICB2YXIgc2lkZUltcCA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSB1cCBkaXJlY3Rpb24gd2l0aCByb2xsSW5mbHVlbmNlLlxyXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxyXG4gICAgICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XHJcbiAgICAgICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7XHJcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxfcG9zLCByZWxfcG9zKTtcclxuICAgICAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MpO1xyXG5cclxuICAgICAgICAgICAgLy9hcHBseSBmcmljdGlvbiBpbXB1bHNlIG9uIHRoZSBncm91bmRcclxuICAgICAgICAgICAgc2lkZUltcC5zY2FsZSgtMSwgc2lkZUltcCk7XHJcbiAgICAgICAgICAgIGdyb3VuZE9iamVjdC5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3BvczIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEgPSBuZXcgVmVjMygpO1xyXG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyID0gbmV3IFZlYzMoKTtcclxudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsID0gbmV3IFZlYzMoKTtcclxuXHJcbmZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XHJcbiAgICB2YXIgajEgPSAwO1xyXG4gICAgdmFyIGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7XHJcblxyXG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcclxuICAgIC8vIHZhciByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgdmVsMSA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMTtcclxuICAgIHZhciB2ZWwyID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyO1xyXG4gICAgdmFyIHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsO1xyXG4gICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTAucG9zaXRpb24sIHJlbF9wb3MxKTtcclxuICAgIC8vIGNvbnRhY3RQb3NXb3JsZC52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMik7XHJcblxyXG4gICAgYm9keTAuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwxKTtcclxuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMik7XHJcbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcclxuXHJcbiAgICB2YXIgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7XHJcblxyXG4gICAgdmFyIGRlbm9tMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTAsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xyXG4gICAgdmFyIGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xyXG4gICAgdmFyIHJlbGF4YXRpb24gPSAxO1xyXG4gICAgdmFyIGphY0RpYWdBQkludiA9IHJlbGF4YXRpb24gLyAoZGVub20wICsgZGVub20xKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgaiB0aGF0IG1vdmVzIHVzIHRvIHplcm8gcmVsYXRpdmUgdmVsb2NpdHlcclxuICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7XHJcblxyXG4gICAgaWYgKG1heEltcHVsc2UgPCBqMSkge1xyXG4gICAgICAgIGoxID0gbWF4SW1wdWxzZTtcclxuICAgIH1cclxuICAgIGlmIChqMSA8IC1tYXhJbXB1bHNlKSB7XHJcbiAgICAgICAgajEgPSAtbWF4SW1wdWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gajE7XHJcbn1cclxuXHJcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTtcclxudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzAgPSBuZXcgVmVjMygpO1xyXG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWMgPSBuZXcgVmVjMygpO1xyXG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTtcclxuZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkge1xyXG4gICAgdmFyIHIwID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9yMDtcclxuICAgIHZhciBjMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzA7XHJcbiAgICB2YXIgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7XHJcbiAgICB2YXIgbSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfbTtcclxuXHJcbiAgICBwb3MudnN1Yihib2R5LnBvc2l0aW9uLCByMCk7XHJcbiAgICByMC5jcm9zcyhub3JtYWwsIGMwKTtcclxuICAgIGJvZHkuaW52SW5lcnRpYVdvcmxkLnZtdWx0KGMwLCBtKTtcclxuICAgIG0uY3Jvc3MocjAsIHZlYyk7XHJcblxyXG4gICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTtcclxufVxyXG5cclxuXHJcbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEgPSBuZXcgVmVjMygpO1xyXG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTtcclxudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTtcclxuXHJcbi8vYmlsYXRlcmFsIGNvbnN0cmFpbnQgYmV0d2VlbiB0d28gZHluYW1pYyBvYmplY3RzXHJcbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoYm9keTEsIHBvczEsIGJvZHkyLCBwb3MyLCBub3JtYWwsIGltcHVsc2Upe1xyXG4gICAgdmFyIG5vcm1hbExlblNxciA9IG5vcm1hbC5ub3JtMigpO1xyXG4gICAgaWYgKG5vcm1hbExlblNxciA+IDEuMSl7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2VcclxuICAgIH1cclxuICAgIC8vIHZhciByZWxfcG9zMSA9IG5ldyBWZWMzKCk7XHJcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xyXG4gICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7XHJcbiAgICAvLyBwb3MyLnZzdWIoYm9keTIucG9zaXRpb24sIHJlbF9wb3MyKTtcclxuXHJcbiAgICB2YXIgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTtcclxuICAgIHZhciB2ZWwyID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyO1xyXG4gICAgdmFyIHZlbCA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsO1xyXG4gICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XHJcbiAgICBib2R5Mi5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChwb3MyLCB2ZWwyKTtcclxuXHJcbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcclxuXHJcbiAgICB2YXIgcmVsX3ZlbCA9IG5vcm1hbC5kb3QodmVsKTtcclxuXHJcbiAgICB2YXIgY29udGFjdERhbXBpbmcgPSAwLjI7XHJcbiAgICB2YXIgbWFzc1Rlcm0gPSAxIC8gKGJvZHkxLmludk1hc3MgKyBib2R5Mi5pbnZNYXNzKTtcclxuICAgIHZhciBpbXB1bHNlID0gLSBjb250YWN0RGFtcGluZyAqIHJlbF92ZWwgKiBtYXNzVGVybTtcclxuXHJcbiAgICByZXR1cm4gaW1wdWxzZTtcclxufVxyXG59LHtcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMCxcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTEsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vb2JqZWN0cy9XaGVlbEluZm9cIjozOCxcIi4vQm9keVwiOjMzfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgQm9keSA9IF9kZXJlcV8oJy4vQm9keScpO1xyXG52YXIgU3BoZXJlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NwaGVyZScpO1xyXG52YXIgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgSGluZ2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XHJcbnZhciBDTWF0aCA9IF9kZXJlcV8oJy4uL21hdGgvQ01hdGgnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cclxuICogQGNsYXNzIFJpZ2lkVmVoaWNsZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cclxuICovXHJcbmZ1bmN0aW9uIFJpZ2lkVmVoaWNsZShvcHRpb25zKXtcclxuICAgIHRoaXMud2hlZWxCb2RpZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBjb29yZGluYXRlU3lzdGVtXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mKG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSk9PT0ndW5kZWZpbmVkJyA/IG5ldyBWZWMzKDEsIDIsIDMpIDogb3B0aW9ucy5jb29yZGluYXRlU3lzdGVtLmNsb25lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5O1xyXG5cclxuICAgIGlmKCF0aGlzLmNoYXNzaXNCb2R5KXtcclxuICAgICAgICAvLyBObyBjaGFzc2lzIGJvZHkgZ2l2ZW4uIENyZWF0ZSBpdCFcclxuICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcclxuICAgICAgICB0aGlzLmNoYXNzaXNCb2R5ID0gbmV3IEJvZHkoMSwgY2hhc3Npc1NoYXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50c1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XHJcblxyXG4gICAgdGhpcy53aGVlbEF4ZXMgPSBbXTtcclxuICAgIHRoaXMud2hlZWxGb3JjZXMgPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBhIHdoZWVsXHJcbiAqIEBtZXRob2QgYWRkV2hlZWxcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucG9zaXRpb25dIFBvc2l0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBpbiB0aGUgY2hhc3NpcyBib2R5LlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbl0gU2xpZGUgZGlyZWN0aW9uIG9mIHRoZSB3aGVlbCBhbG9uZyB0aGUgc3VzcGVuc2lvbi5cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxyXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLmJvZHldIFRoZSB3aGVlbCBib2R5LlxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgd2hlZWxCb2R5ID0gb3B0aW9ucy5ib2R5O1xyXG4gICAgaWYoIXdoZWVsQm9keSl7XHJcbiAgICAgICAgd2hlZWxCb2R5ID0gIG5ldyBCb2R5KDEsIG5ldyBTcGhlcmUoMS4yKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcclxuICAgIHRoaXMud2hlZWxGb3JjZXMucHVzaCgwKTtcclxuXHJcbiAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXHJcbiAgICB2YXIgemVybyA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgcG9zaXRpb24gPSB0eXBlb2Yob3B0aW9ucy5wb3NpdGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvLyBTZXQgcG9zaXRpb24gbG9jYWxseSB0byB0aGUgY2hhc3Npc1xyXG4gICAgdmFyIHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XHJcbiAgICB3aGVlbEJvZHkucG9zaXRpb24uc2V0KHdvcmxkUG9zaXRpb24ueCwgd29ybGRQb3NpdGlvbi55LCB3b3JsZFBvc2l0aW9uLnopO1xyXG5cclxuICAgIC8vIENvbnN0cmFpbiB3aGVlbFxyXG4gICAgdmFyIGF4aXMgPSB0eXBlb2Yob3B0aW9ucy5heGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmF4aXMuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xyXG4gICAgdGhpcy53aGVlbEF4ZXMucHVzaChheGlzKTtcclxuXHJcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gbmV3IEhpbmdlQ29uc3RyYWludCh0aGlzLmNoYXNzaXNCb2R5LCB3aGVlbEJvZHksIHtcclxuICAgICAgICBwaXZvdEE6IHBvc2l0aW9uLFxyXG4gICAgICAgIGF4aXNBOiBheGlzLFxyXG4gICAgICAgIHBpdm90QjogVmVjMy5aRVJPLFxyXG4gICAgICAgIGF4aXNCOiBheGlzLFxyXG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChoaW5nZUNvbnN0cmFpbnQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLndoZWVsQm9kaWVzLmxlbmd0aCAtIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBzdGVlcmluZyB2YWx1ZSBvZiBhIHdoZWVsLlxyXG4gKiBAbWV0aG9kIHNldFN0ZWVyaW5nVmFsdWVcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gKiBAdG9kbyBjaGVjayBjb29yZGluYXRlU3lzdGVtXHJcbiAqL1xyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLnNldFN0ZWVyaW5nVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XHJcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcclxuICAgIHZhciBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XHJcblxyXG4gICAgdmFyIGMgPSBDTWF0aC5jb3ModmFsdWUpLFxyXG4gICAgICAgIHMgPSBDTWF0aC5zaW4odmFsdWUpLFxyXG4gICAgICAgIHggPSBheGlzLngsXHJcbiAgICAgICAgeSA9IGF4aXMueTtcclxuICAgIHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF0uYXhpc0Euc2V0KFxyXG4gICAgICAgIGMqeCAtcyp5LFxyXG4gICAgICAgIHMqeCArYyp5LFxyXG4gICAgICAgIDBcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgaGluZ2UgY29uc3RyYWludC5cclxuICogQG1ldGhvZCBzZXRNb3RvclNwZWVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcclxuICAgIHZhciBoaW5nZUNvbnN0cmFpbnQgPSB0aGlzLmNvbnN0cmFpbnRzW3doZWVsSW5kZXhdO1xyXG4gICAgaGluZ2VDb25zdHJhaW50LmVuYWJsZU1vdG9yKCk7XHJcbiAgICBoaW5nZUNvbnN0cmFpbnQubW90b3JUYXJnZXRWZWxvY2l0eSA9IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGhpbmdlIGNvbnN0cmFpbnQuXHJcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XHJcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XTtcclxuICAgIGhpbmdlQ29uc3RyYWludC5kaXNhYmxlTW90b3IoKTtcclxufTtcclxuXHJcbnZhciB0b3JxdWUgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgd2hlZWwgZm9yY2UgdG8gYXBwbHkgb24gb25lIG9mIHRoZSB3aGVlbHMgZWFjaCB0aW1lIHN0ZXBcclxuICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXHJcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtICB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gKi9cclxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5zZXRXaGVlbEZvcmNlID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgdGhpcy53aGVlbEZvcmNlc1t3aGVlbEluZGV4XSA9IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGEgdG9ycXVlIG9uIG9uZSBvZiB0aGUgd2hlZWxzLlxyXG4gKiBAbWV0aG9kIGFwcGx5V2hlZWxGb3JjZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICovXHJcblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYXBwbHlXaGVlbEZvcmNlID0gZnVuY3Rpb24odmFsdWUsIHdoZWVsSW5kZXgpe1xyXG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcclxuICAgIHZhciB3aGVlbEJvZHkgPSB0aGlzLndoZWVsQm9kaWVzW3doZWVsSW5kZXhdO1xyXG4gICAgdmFyIGJvZHlUb3JxdWUgPSB3aGVlbEJvZHkudG9ycXVlO1xyXG5cclxuICAgIGF4aXMuc2NhbGUodmFsdWUsIHRvcnF1ZSk7XHJcbiAgICB3aGVlbEJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHRvcnF1ZSwgdG9ycXVlKTtcclxuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cclxuICogQG1ldGhvZCBhZGRUb1dvcmxkXHJcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XHJcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xyXG4gICAgdmFyIGJvZGllcyA9IHRoaXMud2hlZWxCb2RpZXMuY29uY2F0KFt0aGlzLmNoYXNzaXNCb2R5XSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB3b3JsZC5hZGRCb2R5KGJvZGllc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludHNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHdoZWVsRm9yY2VzID0gdGhpcy53aGVlbEZvcmNlcztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2hlZWxGb3JjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmFwcGx5V2hlZWxGb3JjZSh3aGVlbEZvcmNlc1tpXSwgaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgZnJvbSB0aGUgd29ybGQuXHJcbiAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXHJcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XHJcbiAgICB2YXIgYm9kaWVzID0gdGhpcy53aGVlbEJvZGllcy5jb25jYXQoW3RoaXMuY2hhc3Npc0JvZHldKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHdvcmxkLnJlbW92ZShib2RpZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciB3b3JsZEF4aXMgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgYSB3aGVlbFxyXG4gKiBAbWV0aG9kIGdldFdoZWVsU3BlZWRcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAqL1xyXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsU3BlZWQgPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcclxuICAgIHZhciBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XHJcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcclxuICAgIHZhciB3ID0gd2hlZWxCb2R5LmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIHRoaXMuY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKGF4aXMsIHdvcmxkQXhpcyk7XHJcbiAgICByZXR1cm4gdy5kb3Qod29ybGRBeGlzKTtcclxufTtcclxuXHJcbn0se1wiLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50XCI6MTYsXCIuLi9tYXRoL0NNYXRoXCI6MjcsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4uL3NoYXBlcy9Cb3hcIjozOSxcIi4uL3NoYXBlcy9TcGhlcmVcIjo0NixcIi4vQm9keVwiOjMzfV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNQSFN5c3RlbTtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKTtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcclxudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcclxuXHJcbi8qKlxyXG4gKiBTbW9vdGhlZC1wYXJ0aWNsZSBoeWRyb2R5bmFtaWNzIHN5c3RlbVxyXG4gKiBAY2xhc3MgU1BIU3lzdGVtXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gU1BIU3lzdGVtKCl7XHJcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xyXG5cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZW5zaXR5XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVuc2l0eSA9IDE7XHJcblx0XHJcbiAgICAvKipcclxuICAgICAqIERpc3RhbmNlIGJlbG93IHdoaWNoIHR3byBwYXJ0aWNsZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgbmVpZ2hib3JzLlxyXG4gICAgICogSXQgc2hvdWxkIGJlIGFkanVzdGVkIHNvIHRoZXJlIGFyZSBhYm91dCAxNS0yMCBuZWlnaGJvciBwYXJ0aWNsZXMgd2l0aGluIHRoaXMgcmFkaXVzLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNtb290aGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNtb290aGluZ1JhZGl1cyA9IDE7XHJcbiAgICB0aGlzLnNwZWVkT2ZTb3VuZCA9IDE7XHJcblx0XHJcbiAgICAvKipcclxuICAgICAqIFZpc2Nvc2l0eSBvZiB0aGUgc3lzdGVtLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZpc2Nvc2l0eSA9IDAuMDE7XHJcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xyXG5cclxuICAgIC8vIFN0dWZmIENvbXB1dGVkIHBlciBwYXJ0aWNsZVxyXG4gICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcclxuICAgIHRoaXMuZGVuc2l0aWVzID0gW107XHJcbiAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHtCb2R5fSBwYXJ0aWNsZVxyXG4gKi9cclxuU1BIU3lzdGVtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwYXJ0aWNsZSl7XHJcbiAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcclxuICAgIGlmKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCl7XHJcbiAgICAgICAgdGhpcy5uZWlnaGJvcnMucHVzaChbXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgcGFydGljbGUgZnJvbSB0aGUgc3lzdGVtLlxyXG4gKiBAbWV0aG9kIHJlbW92ZVxyXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXHJcbiAqL1xyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBhcnRpY2xlKXtcclxuICAgIHZhciBpZHggPSB0aGlzLnBhcnRpY2xlcy5pbmRleE9mKHBhcnRpY2xlKTtcclxuICAgIGlmKGlkeCAhPT0gLTEpe1xyXG4gICAgICAgIHRoaXMucGFydGljbGVzLnNwbGljZShpZHgsMSk7XHJcbiAgICAgICAgaWYodGhpcy5uZWlnaGJvcnMubGVuZ3RoID4gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKXtcclxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBuZWlnaGJvcnMgd2l0aGluIHNtb290aGluZyB2b2x1bWUsIHNhdmUgaW4gdGhlIGFycmF5IG5laWdoYm9yc1xyXG4gKiBAbWV0aG9kIGdldE5laWdoYm9yc1xyXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xyXG4gKi9cclxudmFyIFNQSFN5c3RlbV9nZXROZWlnaGJvcnNfZGlzdCA9IG5ldyBWZWMzKCk7XHJcblNQSFN5c3RlbS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24ocGFydGljbGUsbmVpZ2hib3JzKXtcclxuICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxyXG4gICAgICAgIGlkID0gcGFydGljbGUuaWQsXHJcbiAgICAgICAgUjIgPSB0aGlzLnNtb290aGluZ1JhZGl1cyAqIHRoaXMuc21vb3RoaW5nUmFkaXVzLFxyXG4gICAgICAgIGRpc3QgPSBTUEhTeXN0ZW1fZ2V0TmVpZ2hib3JzX2Rpc3Q7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcclxuICAgICAgICBwLnBvc2l0aW9uLnZzdWIocGFydGljbGUucG9zaXRpb24sZGlzdCk7XHJcbiAgICAgICAgaWYoaWQhPT1wLmlkICYmIGRpc3Qubm9ybTIoKSA8IFIyKXtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gVGVtcCB2ZWN0b3JzIGZvciBjYWxjdWxhdGlvblxyXG52YXIgU1BIU3lzdGVtX3VwZGF0ZV9kaXN0ID0gbmV3IFZlYzMoKSxcclxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZSA9IG5ldyBWZWMzKCksXHJcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYyA9IG5ldyBWZWMzKCksXHJcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKSxcclxuICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWMgPSBuZXcgVmVjMygpLFxyXG4gICAgU1BIU3lzdGVtX3VwZGF0ZV91ID0gbmV3IFZlYzMoKTsgLy8gUmVsYXRpdmUgdmVsb2NpdHlcclxuU1BIU3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIE4gPSB0aGlzLnBhcnRpY2xlcy5sZW5ndGgsXHJcbiAgICAgICAgZGlzdCA9IFNQSFN5c3RlbV91cGRhdGVfZGlzdCxcclxuICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxyXG4gICAgICAgIGVwcyA9IHRoaXMuZXBzO1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucGFydGljbGVzW2ldOyAvLyBDdXJyZW50IHBhcnRpY2xlXHJcbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMubmVpZ2hib3JzW2ldO1xyXG5cclxuICAgICAgICAvLyBHZXQgbmVpZ2hib3JzXHJcbiAgICAgICAgbmVpZ2hib3JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCxuZWlnaGJvcnMpO1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMucGFydGljbGVzW2ldKTsgLy8gQWRkIGN1cnJlbnQgdG9vXHJcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFjY3VtdWxhdGUgZGVuc2l0eSBmb3IgdGhlIHBhcnRpY2xlXHJcbiAgICAgICAgdmFyIHN1bSA9IDAuMDtcclxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PW51bU5laWdoYm9yczsgaisrKXtcclxuXHJcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiQ3VycmVudCBwYXJ0aWNsZSBoYXMgcG9zaXRpb24gJWYgJWYgJWZcXG5cIixvYmplY3RzW2lkXS5wb3MueCgpLG9iamVjdHNbaWRdLnBvcy55KCksb2JqZWN0c1tpZF0ucG9zLnooKSk7XHJcbiAgICAgICAgICAgIHAucG9zaXRpb24udnN1YihuZWlnaGJvcnNbal0ucG9zaXRpb24sIGRpc3QpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gZGlzdC5ub3JtKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy53KGxlbik7XHJcbiAgICAgICAgICAgIHN1bSArPSBuZWlnaGJvcnNbal0ubWFzcyAqIHdlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNhdmVcclxuICAgICAgICB0aGlzLmRlbnNpdGllc1tpXSA9IHN1bTtcclxuICAgICAgICB0aGlzLnByZXNzdXJlc1tpXSA9IGNzICogY3MgKiAodGhpcy5kZW5zaXRpZXNbaV0gLSB0aGlzLmRlbnNpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBmb3JjZXNcclxuXHJcbiAgICAvLyBTdW0gdG8gdGhlc2UgYWNjZWxlcmF0aW9uc1xyXG4gICAgdmFyIGFfcHJlc3N1cmU9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcclxuICAgIHZhciBhX3Zpc2MgPSAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYztcclxuICAgIHZhciBncmFkVyA9ICAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXO1xyXG4gICAgdmFyIHJfdmVjID0gICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XHJcbiAgICB2YXIgdSA9ICAgICAgICAgU1BIU3lzdGVtX3VwZGF0ZV91O1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcclxuXHJcbiAgICAgICAgdmFyIHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaV07XHJcblxyXG4gICAgICAgIGFfcHJlc3N1cmUuc2V0KDAsMCwwKTtcclxuICAgICAgICBhX3Zpc2Muc2V0KDAsMCwwKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdCB2YXJzXHJcbiAgICAgICAgdmFyIFBpajtcclxuICAgICAgICB2YXIgbmFibGE7XHJcbiAgICAgICAgdmFyIFZpajtcclxuXHJcbiAgICAgICAgLy8gU3VtIHVwIGZvciBhbGwgb3RoZXIgbmVpZ2hib3JzXHJcbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMubmVpZ2hib3JzW2ldO1xyXG4gICAgICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvL3ByaW50ZihcIk5laWdoYm9yczogXCIpO1xyXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09bnVtTmVpZ2hib3JzOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2pdO1xyXG4gICAgICAgICAgICAvL3ByaW50ZihcIiVkIFwiLG5qKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCByIG9uY2UgZm9yIGFsbC4uXHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnZzdWIobmVpZ2hib3IucG9zaXRpb24scl92ZWMpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNzdXJlIGNvbnRyaWJ1dGlvblxyXG4gICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSp0aGlzLmRlbnNpdGllc1tpXSArIGVwcykgKyB0aGlzLnByZXNzdXJlc1tqXSAvICh0aGlzLmRlbnNpdGllc1tqXSp0aGlzLmRlbnNpdGllc1tqXSArIGVwcykpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWR3KHJfdmVjLCBncmFkVyk7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBwcmVzc3VyZSBhY2NlbGVyYXRpb25cclxuICAgICAgICAgICAgZ3JhZFcubXVsdChQaWogLCBncmFkVyk7XHJcbiAgICAgICAgICAgIGFfcHJlc3N1cmUudmFkZChncmFkVywgYV9wcmVzc3VyZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXHJcbiAgICAgICAgICAgIG5laWdoYm9yLnZlbG9jaXR5LnZzdWIocGFydGljbGUudmVsb2NpdHksIHUpO1xyXG4gICAgICAgICAgICB1Lm11bHQoIDEuMCAvICgwLjAwMDErdGhpcy5kZW5zaXRpZXNbaV0gKiB0aGlzLmRlbnNpdGllc1tqXSkgKiB0aGlzLnZpc2Nvc2l0eSAqIG5laWdoYm9yLm1hc3MgLCB1ICk7XHJcbiAgICAgICAgICAgIG5hYmxhID0gdGhpcy5uYWJsYXcocik7XHJcbiAgICAgICAgICAgIHUubXVsdChuYWJsYSx1KTtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIHZpc2Nvc2l0eSBhY2NlbGVyYXRpb25cclxuICAgICAgICAgICAgYV92aXNjLnZhZGQoIHUsIGFfdmlzYyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlXHJcbiAgICAgICAgYV92aXNjLm11bHQocGFydGljbGUubWFzcywgYV92aXNjKTtcclxuICAgICAgICBhX3ByZXNzdXJlLm11bHQocGFydGljbGUubWFzcywgYV9wcmVzc3VyZSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBmb3JjZSB0byBwYXJ0aWNsZXNcclxuICAgICAgICBwYXJ0aWNsZS5mb3JjZS52YWRkKGFfdmlzYywgcGFydGljbGUuZm9yY2UpO1xyXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQ2FsY3VsYXRlIHRoZSB3ZWlnaHQgdXNpbmcgdGhlIFcocikgd2VpZ2h0ZnVuY3Rpb25cclxuU1BIU3lzdGVtLnByb3RvdHlwZS53ID0gZnVuY3Rpb24ocil7XHJcbiAgICAvLyAzMTVcclxuICAgIHZhciBoID0gdGhpcy5zbW9vdGhpbmdSYWRpdXM7XHJcbiAgICByZXR1cm4gMzE1LjAvKDY0LjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KGgqaC1yKnIsMyk7XHJcbn07XHJcblxyXG4vLyBjYWxjdWxhdGUgZ3JhZGllbnQgb2YgdGhlIHdlaWdodCBmdW5jdGlvblxyXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmdyYWR3ID0gZnVuY3Rpb24oclZlYyxyZXN1bHRWZWMpe1xyXG4gICAgdmFyIHIgPSByVmVjLm5vcm0oKSxcclxuICAgICAgICBoID0gdGhpcy5zbW9vdGhpbmdSYWRpdXM7XHJcbiAgICByVmVjLm11bHQoOTQ1LjAvKDMyLjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KChoKmgtcipyKSwyKSAsIHJlc3VsdFZlYyk7XHJcbn07XHJcblxyXG4vLyBDYWxjdWxhdGUgbmFibGEoVylcclxuU1BIU3lzdGVtLnByb3RvdHlwZS5uYWJsYXcgPSBmdW5jdGlvbihyKXtcclxuICAgIHZhciBoID0gdGhpcy5zbW9vdGhpbmdSYWRpdXM7XHJcbiAgICB2YXIgbmFibGEgPSA5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogKGgqaC1yKnIpKig3KnIqciAtIDMqaCpoKTtcclxuICAgIHJldHVybiBuYWJsYTtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNixcIi4uL21hdGgvUXVhdGVybmlvblwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuLi9vYmplY3RzL0JvZHlcIjozMyxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQzLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDV9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcclxuXHJcbi8qKlxyXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLlxyXG4gKlxyXG4gKiBAY2xhc3MgU3ByaW5nXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQ6IDFcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzc10gICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMTAwXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcclxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JBXSBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxyXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuXHJcbiAqIEBwYXJhbSB7VmVjM30gIFtvcHRpb25zLmxvY2FsQW5jaG9yQl1cclxuICovXHJcbmZ1bmN0aW9uIFNwcmluZyhib2R5QSxib2R5QixvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdCBsZW5ndGggb2YgdGhlIHNwcmluZy5cclxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cclxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3MgfHwgMTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLlxyXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZyB8fCAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyc3QgY29ubmVjdGVkIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgYm9keUJcclxuICAgICAqIEB0eXBlIHtCb2R5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxyXG4gICAgICogQHR5cGUge1ZlYzN9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuY2hvciBmb3IgYm9keUIgaW4gbG9jYWwgYm9keUIgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXtcclxuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JBKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXtcclxuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JBKXtcclxuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XHJcbiAgICB9XHJcbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQil7XHJcbiAgICAgICAgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cclxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcclxuICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckFcclxuICovXHJcblNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcclxuICAgIHRoaXMuYm9keUEucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JBLHRoaXMubG9jYWxBbmNob3JBKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQW5jaG9yQlxyXG4gKi9cclxuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xyXG4gICAgdGhpcy5ib2R5Qi5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckIsdGhpcy5sb2NhbEFuY2hvckIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXHJcbiAqIEBwYXJhbSB7VmVjM30gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICovXHJcblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgIHRoaXMuYm9keUEucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckEscmVzdWx0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAqL1xyXG5TcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICB0aGlzLmJvZHlCLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JCLHJlc3VsdCk7XHJcbn07XHJcblxyXG52YXIgYXBwbHlGb3JjZV9yID0gICAgICAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3JfdW5pdCA9ICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV9mID0gICAgICAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9ICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV9yaSA9ICAgICAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3JqID0gICAgICAgICAgICAgbmV3IFZlYzMoKSxcclxuICAgIGFwcGx5Rm9yY2VfcmlfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxyXG4gICAgYXBwbHlGb3JjZV9yal94X2YgPSAgICAgICAgIG5ldyBWZWMzKCksXHJcbiAgICBhcHBseUZvcmNlX3RtcCA9ICAgICAgICAgICAgbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxyXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcclxuICovXHJcblNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxyXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXHJcbiAgICAgICAgbCA9IHRoaXMucmVzdExlbmd0aCxcclxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXHJcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxyXG4gICAgICAgIHIgPSBhcHBseUZvcmNlX3IsXHJcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXHJcbiAgICAgICAgdSA9IGFwcGx5Rm9yY2VfdSxcclxuICAgICAgICBmID0gYXBwbHlGb3JjZV9mLFxyXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xyXG5cclxuICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSxcclxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcclxuICAgICAgICByaSA9IGFwcGx5Rm9yY2VfcmksXHJcbiAgICAgICAgcmogPSBhcHBseUZvcmNlX3JqLFxyXG4gICAgICAgIHJpX3hfZiA9IGFwcGx5Rm9yY2VfcmlfeF9mLFxyXG4gICAgICAgIHJqX3hfZiA9IGFwcGx5Rm9yY2VfcmpfeF9mO1xyXG5cclxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXHJcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xyXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcclxuXHJcbiAgICAvLyBHZXQgb2Zmc2V0IHBvaW50c1xyXG4gICAgd29ybGRBbmNob3JBLnZzdWIoYm9keUEucG9zaXRpb24scmkpO1xyXG4gICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24scmopO1xyXG5cclxuICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xyXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLHIpO1xyXG4gICAgdmFyIHJsZW4gPSByLm5vcm0oKTtcclxuICAgIHJfdW5pdC5jb3B5KHIpO1xyXG4gICAgcl91bml0Lm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcclxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksdSk7XHJcbiAgICAvLyBBZGQgcm90YXRpb25hbCB2ZWxvY2l0eVxyXG5cclxuICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaix0bXApO1xyXG4gICAgdS52YWRkKHRtcCx1KTtcclxuICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaSx0bXApO1xyXG4gICAgdS52c3ViKHRtcCx1KTtcclxuXHJcbiAgICAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApXHJcbiAgICByX3VuaXQubXVsdCgtayoocmxlbi1sKSAtIGQqdS5kb3Qocl91bml0KSwgZik7XHJcblxyXG4gICAgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcclxuICAgIGJvZHlBLmZvcmNlLnZzdWIoZixib2R5QS5mb3JjZSk7XHJcbiAgICBib2R5Qi5mb3JjZS52YWRkKGYsYm9keUIuZm9yY2UpO1xyXG5cclxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcclxuICAgIHJpLmNyb3NzKGYscmlfeF9mKTtcclxuICAgIHJqLmNyb3NzKGYscmpfeF9mKTtcclxuICAgIGJvZHlBLnRvcnF1ZS52c3ViKHJpX3hfZixib2R5QS50b3JxdWUpO1xyXG4gICAgYm9keUIudG9ycXVlLnZhZGQocmpfeF9mLGJvZHlCLnRvcnF1ZSk7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMyfV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xyXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXaGVlbEluZm87XHJcblxyXG4vKipcclxuICogQGNsYXNzIFdoZWVsSW5mb1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbF1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uTG9jYWxdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uV29ybGRdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4bGVXb3JsZF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZXN0TGVuZ3RoPTFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M9MTAwXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb249MTBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvblNsaXA9MTAwMDBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucm90YXRpb249MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlbHRhUm90YXRpb249MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFN1c3BlbnNpb25Gb3JjZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWw9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk9MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25Gb3JjZT0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25MZW5ndGg9MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw9MV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZD0tMC4xXVxyXG4gKi9cclxuZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWw6IG5ldyBWZWMzKCksXHJcbiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkOiBuZXcgVmVjMygpLFxyXG4gICAgICAgIGRpcmVjdGlvbkxvY2FsOiBuZXcgVmVjMygpLFxyXG4gICAgICAgIGRpcmVjdGlvbldvcmxkOiBuZXcgVmVjMygpLFxyXG4gICAgICAgIGF4bGVMb2NhbDogbmV3IFZlYzMoKSxcclxuICAgICAgICBheGxlV29ybGQ6IG5ldyBWZWMzKCksXHJcbiAgICAgICAgc3VzcGVuc2lvblJlc3RMZW5ndGg6IDEsXHJcbiAgICAgICAgc3VzcGVuc2lvbk1heExlbmd0aDogMixcclxuICAgICAgICByYWRpdXM6IDEsXHJcbiAgICAgICAgc3VzcGVuc2lvblN0aWZmbmVzczogMTAwLFxyXG4gICAgICAgIGRhbXBpbmdDb21wcmVzc2lvbjogMTAsXHJcbiAgICAgICAgZGFtcGluZ1JlbGF4YXRpb246IDEwLFxyXG4gICAgICAgIGZyaWN0aW9uU2xpcDogMTAwMDAsXHJcbiAgICAgICAgc3RlZXJpbmc6IDAsXHJcbiAgICAgICAgcm90YXRpb246IDAsXHJcbiAgICAgICAgZGVsdGFSb3RhdGlvbjogMCxcclxuICAgICAgICByb2xsSW5mbHVlbmNlOiAwLjAxLFxyXG4gICAgICAgIG1heFN1c3BlbnNpb25Gb3JjZTogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICBpc0Zyb250V2hlZWw6IHRydWUsXHJcbiAgICAgICAgY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOiAxLFxyXG4gICAgICAgIHN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5OiAwLFxyXG4gICAgICAgIHN1c3BlbnNpb25Gb3JjZTogMCxcclxuICAgICAgICBza2lkSW5mbzogMCxcclxuICAgICAgICBzdXNwZW5zaW9uTGVuZ3RoOiAwLFxyXG4gICAgICAgIG1heFN1c3BlbnNpb25UcmF2ZWw6IDEsXHJcbiAgICAgICAgdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogZmFsc2UsXHJcbiAgICAgICAgY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogLTAuMVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXggdHJhdmVsIGRpc3RhbmNlIG9mIHRoZSBzdXNwZW5zaW9uLCBpbiBtZXRlcnMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvblRyYXZlbFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFN1c3BlbnNpb25UcmF2ZWwgPSBvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVlZCB0byBhcHBseSB0byB0aGUgd2hlZWwgcm90YXRpb24gd2hlbiB0aGUgd2hlZWwgaXMgc2xpZGluZy5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXHJcbiAgICAgKi9cclxuICAgIHRoaXMudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xpZGluZ1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3Rpb24gcG9pbnQsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgY2hhc3NpcyBib2R5IGZyYW1lLlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRcclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Mb2NhbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpcmVjdGlvbkxvY2FsID0gb3B0aW9ucy5kaXJlY3Rpb25Mb2NhbC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Xb3JsZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpcmVjdGlvbldvcmxkID0gb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlTG9jYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGxlTG9jYWwgPSBvcHRpb25zLmF4bGVMb2NhbC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlV29ybGRcclxuICAgICAqL1xyXG4gICAgdGhpcy5heGxlV29ybGQgPSBvcHRpb25zLmF4bGVXb3JsZC5jbG9uZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25SZXN0TGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGggPSBvcHRpb25zLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25NYXhMZW5ndGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25TdGlmZm5lc3NcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uU3RpZmZuZXNzID0gb3B0aW9ucy5zdXNwZW5zaW9uU3RpZmZuZXNzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdDb21wcmVzc2lvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhbXBpbmdDb21wcmVzc2lvbiA9IG9wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdSZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGFtcGluZ1JlbGF4YXRpb24gPSBvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZyaWN0aW9uU2xpcFxyXG4gICAgICovXHJcbiAgICB0aGlzLmZyaWN0aW9uU2xpcCA9IG9wdGlvbnMuZnJpY3Rpb25TbGlwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0ZWVyaW5nXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RlZXJpbmcgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFSb3RhdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvbGxJbmZsdWVuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yb2xsSW5mbHVlbmNlID0gb3B0aW9ucy5yb2xsSW5mbHVlbmNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFN1c3BlbnNpb25Gb3JjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJyYWtlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnJha2UgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlzRnJvbnRXaGVlbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzRnJvbnRXaGVlbCA9IG9wdGlvbnMuaXNGcm9udFdoZWVsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvbkZvcmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lkSW5mb1xyXG4gICAgICovXHJcbiAgICB0aGlzLnNraWRJbmZvID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3VzcGVuc2lvbkxlbmd0aCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lkZUltcHVsc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5zaWRlSW1wdWxzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZm9yd2FyZEltcHVsc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5mb3J3YXJkSW1wdWxzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVzdWx0IGZyb20gcmF5Y2FzdGluZ1xyXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByYXljYXN0UmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVlbCB3b3JsZCB0cmFuc2Zvcm1cclxuICAgICAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtfSB3b3JsZFRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0luQ29udGFjdFxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzSW5Db250YWN0ID0gZmFsc2U7XHJcbn1cclxuXHJcbnZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XHJcbnZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xyXG5XaGVlbEluZm8ucHJvdG90eXBlLnVwZGF0ZVdoZWVsID0gZnVuY3Rpb24oY2hhc3Npcyl7XHJcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHRoaXMucmF5Y2FzdFJlc3VsdDtcclxuXHJcbiAgICBpZiAodGhpcy5pc0luQ29udGFjdCl7XHJcbiAgICAgICAgdmFyIHByb2plY3Q9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQpO1xyXG4gICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7XHJcbiAgICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTtcclxuICAgICAgICB2YXIgcHJvalZlbCA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCApO1xyXG4gICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjAgLyAwLjE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGludiA9IC0xIC8gcHJvamVjdDtcclxuICAgICAgICAgICAgdGhpcy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IHByb2pWZWwgKiBpbnY7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vdCBpbiBjb250YWN0IDogcG9zaXRpb24gd2hlZWwgaW4gYSBuaWNlIChyZXN0IGxlbmd0aCkgcG9zaXRpb25cclxuICAgICAgICByYXljYXN0UmVzdWx0LnN1c3BlbnNpb25MZW5ndGggPSB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XHJcbiAgICAgICAgcmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XHJcbiAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7XHJcbiAgICB9XHJcbn07XHJcbn0se1wiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjoxMSxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MzEsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4uL3V0aWxzL1V0aWxzXCI6NTV9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQm94O1xyXG5cclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4vQ29udmV4UG9seWhlZHJvbicpO1xyXG5cclxuLyoqXHJcbiAqIEEgM2QgYm94IHNoYXBlLlxyXG4gKiBAY2xhc3MgQm94XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1ZlYzN9IGhhbGZFeHRlbnRzXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICovXHJcbmZ1bmN0aW9uIEJveChoYWxmRXh0ZW50cyl7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5CT1hcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGhhbGZFeHRlbnRzXHJcbiAgICAgKiBAdHlwZSB7VmVjM31cclxuICAgICAqL1xyXG4gICAgdGhpcy5oYWxmRXh0ZW50cyA9IGhhbGZFeHRlbnRzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBieSB0aGUgY29udGFjdCBnZW5lcmF0b3IgdG8gbWFrZSBjb250YWN0cyB3aXRoIG90aGVyIGNvbnZleCBwb2x5aGVkcmEgZm9yIGV4YW1wbGVcclxuICAgICAqIEBwcm9wZXJ0eSBjb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb25cclxuICAgICAqIEB0eXBlIHtDb252ZXhQb2x5aGVkcm9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTtcclxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcclxufVxyXG5Cb3gucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XHJcbkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3g7XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgbG9jYWwgY29udmV4IHBvbHloZWRyb24gcmVwcmVzZW50YXRpb24gdXNlZCBmb3Igc29tZSBjb2xsaXNpb25zLlxyXG4gKiBAbWV0aG9kIHVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvblxyXG4gKi9cclxuQm94LnByb3RvdHlwZS51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHN4ID0gdGhpcy5oYWxmRXh0ZW50cy54O1xyXG4gICAgdmFyIHN5ID0gdGhpcy5oYWxmRXh0ZW50cy55O1xyXG4gICAgdmFyIHN6ID0gdGhpcy5oYWxmRXh0ZW50cy56O1xyXG4gICAgdmFyIFYgPSBWZWMzO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcclxuICAgICAgICBuZXcgVigtc3gsLXN5LC1zeiksXHJcbiAgICAgICAgbmV3IFYoIHN4LC1zeSwtc3opLFxyXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksLXN6KSxcclxuICAgICAgICBuZXcgVigtc3gsIHN5LC1zeiksXHJcbiAgICAgICAgbmV3IFYoLXN4LC1zeSwgc3opLFxyXG4gICAgICAgIG5ldyBWKCBzeCwtc3ksIHN6KSxcclxuICAgICAgICBuZXcgViggc3gsIHN5LCBzeiksXHJcbiAgICAgICAgbmV3IFYoLXN4LCBzeSwgc3opXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gW1xyXG4gICAgICAgIFszLDIsMSwwXSwgLy8gLXpcclxuICAgICAgICBbNCw1LDYsN10sIC8vICt6XHJcbiAgICAgICAgWzUsNCwwLDFdLCAvLyAteVxyXG4gICAgICAgIFsyLDMsNyw2XSwgLy8gK3lcclxuICAgICAgICBbMCw0LDcsM10sIC8vIC14XHJcbiAgICAgICAgWzEsMiw2LDVdLCAvLyAreFxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgYXhlcyA9IFtcclxuICAgICAgICBuZXcgVigwLCAwLCAxKSxcclxuICAgICAgICBuZXcgVigwLCAxLCAwKSxcclxuICAgICAgICBuZXcgVigxLCAwLCAwKVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgaCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKHZlcnRpY2VzLCBpbmRpY2VzKTtcclxuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDtcclxuICAgIGgubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcbkJveC5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICBCb3guY2FsY3VsYXRlSW5lcnRpYSh0aGlzLmhhbGZFeHRlbnRzLCBtYXNzLCB0YXJnZXQpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbkJveC5jYWxjdWxhdGVJbmVydGlhID0gZnVuY3Rpb24oaGFsZkV4dGVudHMsbWFzcyx0YXJnZXQpe1xyXG4gICAgdmFyIGUgPSBoYWxmRXh0ZW50cztcclxuICAgIGlmIChlLmlzWmVybygpKSB7XHJcbiAgICAgICAgdGFyZ2V0LnggPSAyLjAgLyAxMi4wICogbWFzcztcclxuICAgICAgICB0YXJnZXQueSA9IDIuMCAvIDEyLjAgKiBtYXNzO1xyXG4gICAgICAgIHRhcmdldC56ID0gMi4wIC8gMTIuMCAqIG1hc3M7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLnoqMiplLnogKTtcclxuICAgICAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS54KjIqZS54ICsgMiplLnoqMiplLnogKTtcclxuICAgICAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLngqMiplLnggKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGJveCA2IHNpZGUgbm9ybWFsc1xyXG4gKiBAbWV0aG9kIGdldFNpZGVOb3JtYWxzXHJcbiAqIEBwYXJhbSB7YXJyYXl9ICAgICAgc2l4VGFyZ2V0VmVjdG9ycyBBbiBhcnJheSBvZiA2IHZlY3RvcnMsIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBub3JtYWxzIGluLlxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXQgICAgICAgICAgICAgT3JpZW50YXRpb24gdG8gYXBwbHkgdG8gdGhlIG5vcm1hbCB2ZWN0b3JzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB2ZWN0b3JzIHdpbGwgYmUgaW4gcmVzcGVjdCB0byB0aGUgbG9jYWwgZnJhbWUuXHJcbiAqIEByZXR1cm4ge2FycmF5fVxyXG4gKi9cclxuQm94LnByb3RvdHlwZS5nZXRTaWRlTm9ybWFscyA9IGZ1bmN0aW9uKHNpeFRhcmdldFZlY3RvcnMscXVhdCl7XHJcbiAgICB2YXIgc2lkZXMgPSBzaXhUYXJnZXRWZWN0b3JzO1xyXG4gICAgdmFyIGV4ID0gdGhpcy5oYWxmRXh0ZW50cztcclxuICAgIHNpZGVzWzBdLnNldCggIGV4LngsICAgICAwLCAgICAgMCk7XHJcbiAgICBzaWRlc1sxXS5zZXQoICAgICAwLCAgZXgueSwgICAgIDApO1xyXG4gICAgc2lkZXNbMl0uc2V0KCAgICAgMCwgICAgIDAsICBleC56KTtcclxuICAgIHNpZGVzWzNdLnNldCggLWV4LngsICAgICAwLCAgICAgMCk7XHJcbiAgICBzaWRlc1s0XS5zZXQoICAgICAwLCAtZXgueSwgICAgIDApO1xyXG4gICAgc2lkZXNbNV0uc2V0KCAgICAgMCwgICAgIDAsIC1leC56KTtcclxuXHJcbiAgICBpZihxdWF0IT09dW5kZWZpbmVkKXtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXNpZGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgcXVhdC52bXVsdChzaWRlc1tpXSxzaWRlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaWRlcztcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7XHJcbn07XHJcblxyXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLm5vcm0oKTtcclxufTtcclxuXHJcbnZhciB3b3JsZENvcm5lclRlbXBQb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgd29ybGRDb3JuZXJUZW1wTmVnID0gbmV3IFZlYzMoKTtcclxuQm94LnByb3RvdHlwZS5mb3JFYWNoV29ybGRDb3JuZXIgPSBmdW5jdGlvbihwb3MscXVhdCxjYWxsYmFjayl7XHJcblxyXG4gICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xyXG4gICAgdmFyIGNvcm5lcnMgPSBbWyAgZS54LCAgZS55LCAgZS56XSxcclxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgIGUueSwgIGUuel0sXHJcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsIC1lLnksICBlLnpdLFxyXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAtZS55LCAtZS56XSxcclxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgLWUueSwgLWUuel0sXHJcbiAgICAgICAgICAgICAgICAgICBbICBlLngsICBlLnksIC1lLnpdLFxyXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAgZS55LCAtZS56XSxcclxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgLWUueSwgIGUuel1dO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8Y29ybmVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnNldChjb3JuZXJzW2ldWzBdLGNvcm5lcnNbaV1bMV0sY29ybmVyc1tpXVsyXSk7XHJcbiAgICAgICAgcXVhdC52bXVsdCh3b3JsZENvcm5lclRlbXBQb3Msd29ybGRDb3JuZXJUZW1wUG9zKTtcclxuICAgICAgICBwb3MudmFkZCh3b3JsZENvcm5lclRlbXBQb3Msd29ybGRDb3JuZXJUZW1wUG9zKTtcclxuICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCxcclxuICAgICAgICAgICAgICAgICB3b3JsZENvcm5lclRlbXBQb3MueSxcclxuICAgICAgICAgICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Mueik7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgd29ybGRDb3JuZXJzVGVtcCA9IFtcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpLFxyXG4gICAgbmV3IFZlYzMoKSxcclxuICAgIG5ldyBWZWMzKCksXHJcbiAgICBuZXcgVmVjMygpXHJcbl07XHJcbkJveC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XHJcblxyXG4gICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFswXS5zZXQoZS54LCBlLnksIGUueik7XHJcbiAgICB3b3JsZENvcm5lcnNUZW1wWzFdLnNldCgtZS54LCAgZS55LCBlLnopO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTtcclxuICAgIHdvcmxkQ29ybmVyc1RlbXBbM10uc2V0KC1lLngsIC1lLnksIC1lLnopO1xyXG4gICAgd29ybGRDb3JuZXJzVGVtcFs0XS5zZXQoZS54LCAtZS55LCAtZS56KTtcclxuICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgIGUueSwgLWUueik7XHJcbiAgICB3b3JsZENvcm5lcnNUZW1wWzZdLnNldCgtZS54LCAgZS55LCAtZS56KTtcclxuICAgIHdvcmxkQ29ybmVyc1RlbXBbN10uc2V0KGUueCwgLWUueSwgIGUueik7XHJcblxyXG4gICAgdmFyIHdjID0gd29ybGRDb3JuZXJzVGVtcFswXTtcclxuICAgIHF1YXQudm11bHQod2MsIHdjKTtcclxuICAgIHBvcy52YWRkKHdjLCB3Yyk7XHJcbiAgICBtYXguY29weSh3Yyk7XHJcbiAgICBtaW4uY29weSh3Yyk7XHJcbiAgICBmb3IodmFyIGk9MTsgaTw4OyBpKyspe1xyXG4gICAgICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbaV07XHJcbiAgICAgICAgcXVhdC52bXVsdCh3Yywgd2MpO1xyXG4gICAgICAgIHBvcy52YWRkKHdjLCB3Yyk7XHJcbiAgICAgICAgdmFyIHggPSB3Yy54O1xyXG4gICAgICAgIHZhciB5ID0gd2MueTtcclxuICAgICAgICB2YXIgeiA9IHdjLno7XHJcbiAgICAgICAgaWYoeCA+IG1heC54KXtcclxuICAgICAgICAgICAgbWF4LnggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih5ID4gbWF4Lnkpe1xyXG4gICAgICAgICAgICBtYXgueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHogPiBtYXgueil7XHJcbiAgICAgICAgICAgIG1heC56ID0gejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHggPCBtaW4ueCl7XHJcbiAgICAgICAgICAgIG1pbi54ID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoeSA8IG1pbi55KXtcclxuICAgICAgICAgICAgbWluLnkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih6IDwgbWluLnope1xyXG4gICAgICAgICAgICBtaW4ueiA9IHo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XHJcbiAgICAvLyBtaW4uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTtcclxuICAgIC8vIG1heC5zZXQoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpO1xyXG4gICAgLy8gdGhpcy5mb3JFYWNoV29ybGRDb3JuZXIocG9zLHF1YXQsZnVuY3Rpb24oeCx5LHope1xyXG4gICAgLy8gICAgIGlmKHggPiBtYXgueCl7XHJcbiAgICAvLyAgICAgICAgIG1heC54ID0geDtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgaWYoeSA+IG1heC55KXtcclxuICAgIC8vICAgICAgICAgbWF4LnkgPSB5O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZih6ID4gbWF4Lnope1xyXG4gICAgLy8gICAgICAgICBtYXgueiA9IHo7XHJcbiAgICAvLyAgICAgfVxyXG5cclxuICAgIC8vICAgICBpZih4IDwgbWluLngpe1xyXG4gICAgLy8gICAgICAgICBtaW4ueCA9IHg7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGlmKHkgPCBtaW4ueSl7XHJcbiAgICAvLyAgICAgICAgIG1pbi55ID0geTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgaWYoeiA8IG1pbi56KXtcclxuICAgIC8vICAgICAgICAgbWluLnogPSB6O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH0pO1xyXG59O1xyXG5cclxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMixcIi4vQ29udmV4UG9seWhlZHJvblwiOjQwLFwiLi9TaGFwZVwiOjQ1fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZleFBvbHloZWRyb247XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xyXG5cclxuLyoqXHJcbiAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXHJcbiAqIEBjbGFzcyBDb252ZXhQb2x5aGVkcm9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKiBAZGVzY3JpcHRpb24gVGhlIHNoYXBlIE1VU1QgYmUgY29udmV4IGZvciB0aGUgY29kZSB0byB3b3JrIHByb3Blcmx5LiBObyBwb2x5Z29ucyBtYXkgYmUgY29wbGFuYXIgKGNvbnRhaW5lZFxyXG4gKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgVmVjMydzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhbyAob3JpZ2luYWwgYXV0aG9yLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3FpYW8vdGhyZWUuanMvY29tbWl0Lzg1MDI2ZjBjNzY5ZTQwMDAxNDhhNjdkNDVhOWU5YjljNTEwODgzNmYpXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcclxuICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXHJcbiAqIEBzZWUgaHR0cDovL2J1bGxldC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvc3JjL0J1bGxldENvbGxpc2lvbi9OYXJyb3dQaGFzZUNvbGxpc2lvbi9idFBvbHloZWRyYWxDb250YWN0Q2xpcHBpbmcuY3BwXHJcbiAqXHJcbiAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xyXG4gKiBAdG9kbyBBdXRvbWF0aWNhbGx5IG1lcmdlIGNvcGxhbmFyIHBvbHlnb25zIGluIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gQ29udmV4UG9seWhlZHJvbihwb2ludHMsIGZhY2VzLCB1bmlxdWVBeGVzKSB7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIFZlYzNcclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRpY2VzID0gcG9pbnRzfHxbXTtcclxuXHJcbiAgICB0aGlzLndvcmxkVmVydGljZXMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAudmVydGljZXNcclxuICAgIHRoaXMud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZlxyXG4gICAgICogQHByb3BlcnR5IGZhY2VzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmFjZXMgPSBmYWNlc3x8W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBWZWMzXHJcbiAgICAgKiBAcHJvcGVydHkgZmFjZU5vcm1hbHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mYWNlTm9ybWFscyA9IFtdO1xyXG4gICAgdGhpcy5jb21wdXRlTm9ybWFscygpO1xyXG5cclxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFscyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC5mYWNlTm9ybWFsc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgVmVjM1xyXG4gICAgICogQHByb3BlcnR5IHVuaXF1ZUVkZ2VzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5pcXVlRWRnZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIGdpdmVuLCB0aGVzZSBsb2NhbGx5IGRlZmluZWQsIG5vcm1hbGl6ZWQgYXhlcyBhcmUgdGhlIG9ubHkgb25lcyBiZWluZyBjaGVja2VkIHdoZW4gZG9pbmcgc2VwYXJhdGluZyBheGlzIGNoZWNrLlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gdW5pcXVlQXhlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLnVuaXF1ZUF4ZXMgPSB1bmlxdWVBeGVzID8gdW5pcXVlQXhlcy5zbGljZSgpIDogbnVsbDtcclxuXHJcbiAgICB0aGlzLmNvbXB1dGVFZGdlcygpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG59XHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4UG9seWhlZHJvbjtcclxuXHJcbnZhciBjb21wdXRlRWRnZXNfdG1wRWRnZSA9IG5ldyBWZWMzKCk7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyB1bmlxdWVFZGdlc1xyXG4gKiBAbWV0aG9kIGNvbXB1dGVFZGdlc1xyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgdmFyIG52ID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgdmFyIGVkZ2VzID0gdGhpcy51bmlxdWVFZGdlcztcclxuXHJcbiAgICBlZGdlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgIHZhciBlZGdlID0gY29tcHV0ZUVkZ2VzX3RtcEVkZ2U7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGZhY2VzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ldO1xyXG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IGZhY2UubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IG51bVZlcnRpY2VzOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgayA9ICggaisxICkgJSBudW1WZXJ0aWNlcztcclxuICAgICAgICAgICAgdmVydGljZXNbZmFjZVtqXV0udnN1Yih2ZXJ0aWNlc1tmYWNlW2tdXSwgZWRnZSk7XHJcbiAgICAgICAgICAgIGVkZ2Uubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IodmFyIHA9MDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspe1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSB8fCBlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmb3VuZCl7XHJcbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgcmV1c2UgZXhpc3RpbmcgVmVjMyBvYmplY3RzIGluIHRoZSAuZmFjZU5vcm1hbHMgYXJyYXkgaWYgdGhleSBleGlzdC5cclxuICogQG1ldGhvZCBjb21wdXRlTm9ybWFsc1xyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGggPSB0aGlzLmZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXHJcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmZhY2VzLmxlbmd0aDsgaSsrKXtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgc28gYWxsIHZlcnRpY2VzIGV4aXN0cyBmb3IgdGhpcyBmYWNlXHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dKXtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleCBcIit0aGlzLmZhY2VzW2ldW2pdK1wiIG5vdCBmb3VuZCFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tpXSB8fCBuZXcgVmVjMygpO1xyXG4gICAgICAgIHRoaXMuZ2V0RmFjZU5vcm1hbChpLG4pO1xyXG4gICAgICAgIG4ubmVnYXRlKG4pO1xyXG4gICAgICAgIHRoaXMuZmFjZU5vcm1hbHNbaV0gPSBuO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bMF1dO1xyXG4gICAgICAgIGlmKG4uZG90KHZlcnRleCkgPCAwKXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIi5mYWNlTm9ybWFsc1tcIiArIGkgKyBcIl0gPSBWZWMzKFwiK24udG9TdHJpbmcoKStcIikgbG9va3MgbGlrZSBpdCBwb2ludHMgaW50byB0aGUgc2hhcGU/IFRoZSB2ZXJ0aWNlcyBmb2xsb3cuIE1ha2Ugc3VyZSB0aGV5IGFyZSBvcmRlcmVkIENDVyBhcm91bmQgdGhlIG5vcm1hbCwgdXNpbmcgdGhlIHJpZ2h0IGhhbmQgcnVsZS5cIik7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiLnZlcnRpY2VzW1wiK3RoaXMuZmFjZXNbaV1bal0rXCJdID0gVmVjMyhcIit0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dLnRvU3RyaW5nKCkrXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXHJcbiAqIEBwYXJhbSB7VmVjM30gdmFcclxuICogQHBhcmFtIHtWZWMzfSB2YlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XHJcbiAqL1xyXG52YXIgY2IgPSBuZXcgVmVjMygpO1xyXG52YXIgYWIgPSBuZXcgVmVjMygpO1xyXG5Db252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwgPSBmdW5jdGlvbiAoIHZhLCB2YiwgdmMsIHRhcmdldCApIHtcclxuICAgIHZiLnZzdWIodmEsYWIpO1xyXG4gICAgdmMudnN1Yih2YixjYik7XHJcbiAgICBjYi5jcm9zcyhhYix0YXJnZXQpO1xyXG4gICAgaWYgKCAhdGFyZ2V0LmlzWmVybygpICkge1xyXG4gICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgYSBmYWNlIGZyb20gaXRzIHZlcnRpY2VzXHJcbiAqIEBtZXRob2QgZ2V0RmFjZU5vcm1hbFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRGYWNlTm9ybWFsID0gZnVuY3Rpb24oaSx0YXJnZXQpe1xyXG4gICAgdmFyIGYgPSB0aGlzLmZhY2VzW2ldO1xyXG4gICAgdmFyIHZhID0gdGhpcy52ZXJ0aWNlc1tmWzBdXTtcclxuICAgIHZhciB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07XHJcbiAgICB2YXIgdmMgPSB0aGlzLnZlcnRpY2VzW2ZbMl1dO1xyXG4gICAgcmV0dXJuIENvbnZleFBvbHloZWRyb24uY29tcHV0ZU5vcm1hbCh2YSx2Yix2Yyx0YXJnZXQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2xpcEFnYWluc3RIdWxsXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXHJcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcclxuICogQHBhcmFtIHtWZWMzfSBwb3NCXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcclxuICogQHBhcmFtIHtWZWMzfSBzZXBhcmF0aW5nTm9ybWFsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IENsYW1wIGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEaXN0XHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbFxyXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxyXG4gKi9cclxudmFyIGNhaF9Xb3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHBvc0EscXVhdEEsaHVsbEIscG9zQixxdWF0QixzZXBhcmF0aW5nTm9ybWFsLG1pbkRpc3QsbWF4RGlzdCxyZXN1bHQpe1xyXG4gICAgdmFyIFdvcmxkTm9ybWFsID0gY2FoX1dvcmxkTm9ybWFsO1xyXG4gICAgdmFyIGh1bGxBID0gdGhpcztcclxuICAgIHZhciBjdXJNYXhEaXN0ID0gbWF4RGlzdDtcclxuICAgIHZhciBjbG9zZXN0RmFjZUIgPSAtMTtcclxuICAgIHZhciBkbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBmb3IodmFyIGZhY2U9MDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcclxuICAgICAgICBXb3JsZE5vcm1hbC5jb3B5KGh1bGxCLmZhY2VOb3JtYWxzW2ZhY2VdKTtcclxuICAgICAgICBxdWF0Qi52bXVsdChXb3JsZE5vcm1hbCxXb3JsZE5vcm1hbCk7XHJcbiAgICAgICAgLy9wb3NCLnZhZGQoV29ybGROb3JtYWwsV29ybGROb3JtYWwpO1xyXG4gICAgICAgIHZhciBkID0gV29ybGROb3JtYWwuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xyXG4gICAgICAgIGlmIChkID4gZG1heCl7XHJcbiAgICAgICAgICAgIGRtYXggPSBkO1xyXG4gICAgICAgICAgICBjbG9zZXN0RmFjZUIgPSBmYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciB3b3JsZFZlcnRzQjEgPSBbXTtcclxuICAgIHZhciBwb2x5QiA9IGh1bGxCLmZhY2VzW2Nsb3Nlc3RGYWNlQl07XHJcbiAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Qi5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGUwPTA7IGUwPG51bVZlcnRpY2VzOyBlMCsrKXtcclxuICAgICAgICB2YXIgYiA9IGh1bGxCLnZlcnRpY2VzW3BvbHlCW2UwXV07XHJcbiAgICAgICAgdmFyIHdvcmxkYiA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgd29ybGRiLmNvcHkoYik7XHJcbiAgICAgICAgcXVhdEIudm11bHQod29ybGRiLHdvcmxkYik7XHJcbiAgICAgICAgcG9zQi52YWRkKHdvcmxkYix3b3JsZGIpO1xyXG4gICAgICAgIHdvcmxkVmVydHNCMS5wdXNoKHdvcmxkYik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNsb3Nlc3RGYWNlQj49MCl7XHJcbiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0EsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YXRBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRzQjEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhpcyBodWxsIGFuZCBhbm90aGVyXHJcbiAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXHJcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcclxuICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcclxuICogQHBhcmFtIHtWZWMzfSBwb3NCXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHRhcmdldCB2ZWN0b3IgdG8gc2F2ZSB0aGUgYXhpcyBpblxyXG4gKiBAcmV0dXJuIHtib29sfSBSZXR1cm5zIGZhbHNlIGlmIGEgc2VwYXJhdGlvbiBpcyBmb3VuZCwgZWxzZSB0cnVlXHJcbiAqL1xyXG52YXIgZnNhX2ZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKSxcclxuICAgIGZzYV9Xb3JsZG5vcm1hbDEgPSBuZXcgVmVjMygpLFxyXG4gICAgZnNhX2RlbHRhQyA9IG5ldyBWZWMzKCksXHJcbiAgICBmc2Ffd29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXHJcbiAgICBmc2Ffd29ybGRFZGdlMSA9IG5ldyBWZWMzKCksXHJcbiAgICBmc2FfQ3Jvc3MgPSBuZXcgVmVjMygpO1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5maW5kU2VwYXJhdGluZ0F4aXMgPSBmdW5jdGlvbihodWxsQixwb3NBLHF1YXRBLHBvc0IscXVhdEIsdGFyZ2V0LCBmYWNlTGlzdEEsIGZhY2VMaXN0Qil7XHJcbiAgICB2YXIgZmFjZUFOb3JtYWxXUzMgPSBmc2FfZmFjZUFOb3JtYWxXUzMsXHJcbiAgICAgICAgV29ybGRub3JtYWwxID0gZnNhX1dvcmxkbm9ybWFsMSxcclxuICAgICAgICBkZWx0YUMgPSBmc2FfZGVsdGFDLFxyXG4gICAgICAgIHdvcmxkRWRnZTAgPSBmc2Ffd29ybGRFZGdlMCxcclxuICAgICAgICB3b3JsZEVkZ2UxID0gZnNhX3dvcmxkRWRnZTEsXHJcbiAgICAgICAgQ3Jvc3MgPSBmc2FfQ3Jvc3M7XHJcblxyXG4gICAgdmFyIGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdmFyIGh1bGxBID0gdGhpcztcclxuICAgIHZhciBjdXJQbGFuZVRlc3RzPTA7XHJcblxyXG4gICAgaWYoIWh1bGxBLnVuaXF1ZUF4ZXMpe1xyXG5cclxuICAgICAgICB2YXIgbnVtRmFjZXNBID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBLmxlbmd0aCA6IGh1bGxBLmZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQVxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzQTsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGZpID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBW2ldIDogaTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBmYWNlIG5vcm1hbFxyXG4gICAgICAgICAgICBmYWNlQU5vcm1hbFdTMy5jb3B5KGh1bGxBLmZhY2VOb3JtYWxzW2ZpXSk7XHJcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLGZhY2VBTm9ybWFsV1MzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xyXG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xyXG4gICAgICAgICAgICAgICAgZG1pbiA9IGQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgIT09IGh1bGxBLnVuaXF1ZUF4ZXMubGVuZ3RoOyBpKyspe1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXNcclxuICAgICAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlQXhlc1tpXSxmYWNlQU5vcm1hbFdTMyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcclxuICAgICAgICAgICAgaWYoZD09PWZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZDxkbWluKXtcclxuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoZmFjZUFOb3JtYWxXUzMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKCFodWxsQi51bmlxdWVBeGVzKXtcclxuXHJcbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQlxyXG4gICAgICAgIHZhciBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8bnVtRmFjZXNCO2krKyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEJbaV0gOiBpO1xyXG5cclxuICAgICAgICAgICAgV29ybGRub3JtYWwxLmNvcHkoaHVsbEIuZmFjZU5vcm1hbHNbZmldKTtcclxuICAgICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLFdvcmxkbm9ybWFsMSk7XHJcbiAgICAgICAgICAgIGN1clBsYW5lVGVzdHMrKztcclxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qik7XHJcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGQ8ZG1pbil7XHJcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUZXN0IHVuaXF1ZSBheGVzIGluIEJcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlQXhlc1tpXSxXb3JsZG5vcm1hbDEpO1xyXG5cclxuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIscG9zQSxxdWF0QSxwb3NCLHF1YXRCKTtcclxuICAgICAgICAgICAgaWYoZD09PWZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZDxkbWluKXtcclxuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoV29ybGRub3JtYWwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IGVkZ2VzXHJcbiAgICBmb3IodmFyIGUwPTA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspe1xyXG5cclxuICAgICAgICAvLyBHZXQgd29ybGQgZWRnZVxyXG4gICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUVkZ2VzW2UwXSx3b3JsZEVkZ2UwKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBlMT0wOyBlMSAhPT0gaHVsbEIudW5pcXVlRWRnZXMubGVuZ3RoOyBlMSsrKXtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlIDJcclxuICAgICAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlRWRnZXNbZTFdLCB3b3JsZEVkZ2UxKTtcclxuICAgICAgICAgICAgd29ybGRFZGdlMC5jcm9zcyh3b3JsZEVkZ2UxLENyb3NzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCFDcm9zcy5hbG1vc3RaZXJvKCkpe1xyXG4gICAgICAgICAgICAgICAgQ3Jvc3Mubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGh1bGxBLnRlc3RTZXBBeGlzKENyb3NzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcclxuICAgICAgICAgICAgICAgIGlmKGRpc3QgPT09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihkaXN0IDwgZG1pbil7XHJcbiAgICAgICAgICAgICAgICAgICAgZG1pbiA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoQ3Jvc3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBvc0IudnN1Yihwb3NBLGRlbHRhQyk7XHJcbiAgICBpZigoZGVsdGFDLmRvdCh0YXJnZXQpKT4wLjApe1xyXG4gICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBtYXhtaW5BPVtdLCBtYXhtaW5CPVtdO1xyXG5cclxuLyoqXHJcbiAqIFRlc3Qgc2VwYXJhdGluZyBheGlzIGFnYWluc3QgdHdvIGh1bGxzLiBCb3RoIGh1bGxzIGFyZSBwcm9qZWN0ZWQgb250byB0aGUgYXhpcyBhbmQgdGhlIG92ZXJsYXAgc2l6ZSBpcyByZXR1cm5lZCBpZiB0aGVyZSBpcyBvbmUuXHJcbiAqIEBtZXRob2QgdGVzdFNlcEF4aXNcclxuICogQHBhcmFtIHtWZWMzfSBheGlzXHJcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcclxuICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcclxuICogQHBhcmFtIHtWZWMzfSBwb3NCXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3ZlcmxhcCBkZXB0aCwgb3IgRkFMU0UgaWYgbm8gcGVuZXRyYXRpb24uXHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50ZXN0U2VwQXhpcyA9IGZ1bmN0aW9uKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpe1xyXG4gICAgdmFyIGh1bGxBPXRoaXM7XHJcbiAgICBDb252ZXhQb2x5aGVkcm9uLnByb2plY3QoaHVsbEEsIGF4aXMsIHBvc0EsIHF1YXRBLCBtYXhtaW5BKTtcclxuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpO1xyXG4gICAgdmFyIG1heEEgPSBtYXhtaW5BWzBdO1xyXG4gICAgdmFyIG1pbkEgPSBtYXhtaW5BWzFdO1xyXG4gICAgdmFyIG1heEIgPSBtYXhtaW5CWzBdO1xyXG4gICAgdmFyIG1pbkIgPSBtYXhtaW5CWzFdO1xyXG4gICAgaWYobWF4QTxtaW5CIHx8IG1heEI8bWluQSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTZXBhcmF0ZWRcclxuICAgIH1cclxuICAgIHZhciBkMCA9IG1heEEgLSBtaW5CO1xyXG4gICAgdmFyIGQxID0gbWF4QiAtIG1pbkE7XHJcbiAgICB2YXIgZGVwdGggPSBkMDxkMSA/IGQwOmQxO1xyXG4gICAgcmV0dXJuIGRlcHRoO1xyXG59O1xyXG5cclxudmFyIGNsaV9hYWJibWluID0gbmV3IFZlYzMoKSxcclxuICAgIGNsaV9hYWJibWF4ID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcclxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXHJcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcclxuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihjbGlfYWFiYm1pbixjbGlfYWFiYm1heCk7XHJcbiAgICB2YXIgeCA9IGNsaV9hYWJibWF4LnggLSBjbGlfYWFiYm1pbi54LFxyXG4gICAgICAgIHkgPSBjbGlfYWFiYm1heC55IC0gY2xpX2FhYmJtaW4ueSxcclxuICAgICAgICB6ID0gY2xpX2FhYmJtYXgueiAtIGNsaV9hYWJibWluLno7XHJcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip6KjIqeiApO1xyXG4gICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKTtcclxuICAgIHRhcmdldC56ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKngqMip4ICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRQbGFuZUNvbnN0YW50T2ZGYWNlXHJcbiAqIEBwYXJhbSAge051bWJlcn0gZmFjZV9pIEluZGV4IG9mIHRoZSBmYWNlXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UgPSBmdW5jdGlvbihmYWNlX2kpe1xyXG4gICAgdmFyIGYgPSB0aGlzLmZhY2VzW2ZhY2VfaV07XHJcbiAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbZmFjZV9pXTtcclxuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tmWzBdXTtcclxuICAgIHZhciBjID0gLW4uZG90KHYpO1xyXG4gICAgcmV0dXJuIGM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuXHJcbiAqIEBtZXRob2QgY2xpcEZhY2VBZ2FpbnN0SHVsbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcclxuICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcclxuICogQHBhcmFtIHtBcnJheX0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IERpc3RhbmNlIGNsYW1waW5nXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEaXN0XHJcbiAqIEBwYXJhbSBBcnJheSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGNvbnRhY3QgcG9pbnRzIGluLiBXaWxsIGJlIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzOiBwb2ludCwgZGVwdGgsIG5vcm1hbC4gVGhlc2UgYXJlIHJlcHJlc2VudGVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxudmFyIGNmYWhfZmFjZUFOb3JtYWxXUyA9IG5ldyBWZWMzKCksXHJcbiAgICBjZmFoX2VkZ2UwID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfV29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXHJcbiAgICBjZmFoX3dvcmxkUGxhbmVBbm9ybWFsMSA9IG5ldyBWZWMzKCksXHJcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKSxcclxuICAgIGNmYWhfd29ybGRBMSA9IG5ldyBWZWMzKCksXHJcbiAgICBjZmFoX2xvY2FsUGxhbmVOb3JtYWwgPSBuZXcgVmVjMygpLFxyXG4gICAgY2ZhaF9wbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEZhY2VBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QscmVzdWx0KXtcclxuICAgIHZhciBmYWNlQU5vcm1hbFdTID0gY2ZhaF9mYWNlQU5vcm1hbFdTLFxyXG4gICAgICAgIGVkZ2UwID0gY2ZhaF9lZGdlMCxcclxuICAgICAgICBXb3JsZEVkZ2UwID0gY2ZhaF9Xb3JsZEVkZ2UwLFxyXG4gICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMSA9IGNmYWhfd29ybGRQbGFuZUFub3JtYWwxLFxyXG4gICAgICAgIHBsYW5lTm9ybWFsV1MxID0gY2ZhaF9wbGFuZU5vcm1hbFdTMSxcclxuICAgICAgICB3b3JsZEExID0gY2ZhaF93b3JsZEExLFxyXG4gICAgICAgIGxvY2FsUGxhbmVOb3JtYWwgPSBjZmFoX2xvY2FsUGxhbmVOb3JtYWwsXHJcbiAgICAgICAgcGxhbmVOb3JtYWxXUyA9IGNmYWhfcGxhbmVOb3JtYWxXUztcclxuXHJcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xyXG4gICAgdmFyIHdvcmxkVmVydHNCMiA9IFtdO1xyXG4gICAgdmFyIHBWdHhJbiA9IHdvcmxkVmVydHNCMTtcclxuICAgIHZhciBwVnR4T3V0ID0gd29ybGRWZXJ0c0IyO1xyXG4gICAgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcclxuICAgIHZhciBjbG9zZXN0RmFjZUEgPSAtMTtcclxuICAgIHZhciBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGZvcih2YXIgZmFjZT0wOyBmYWNlPGh1bGxBLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcclxuICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pO1xyXG4gICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MsZmFjZUFOb3JtYWxXUyk7XHJcbiAgICAgICAgLy9wb3NBLnZhZGQoZmFjZUFOb3JtYWxXUyxmYWNlQU5vcm1hbFdTKTtcclxuICAgICAgICB2YXIgZCA9IGZhY2VBTm9ybWFsV1MuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xyXG4gICAgICAgIGlmIChkIDwgZG1pbil7XHJcbiAgICAgICAgICAgIGRtaW4gPSBkO1xyXG4gICAgICAgICAgICBjbG9zZXN0RmFjZUEgPSBmYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjbG9zZXN0RmFjZUEgPCAwKXtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tLSBkaWQgbm90IGZpbmQgYW55IGNsb3Nlc3QgZmFjZS4uLiAtLS1cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy9jb25zb2xlLmxvZyhcImNsb3Nlc3QgQTogXCIsY2xvc2VzdEZhY2VBKTtcclxuICAgIC8vIEdldCB0aGUgZmFjZSBhbmQgY29uc3RydWN0IGNvbm5lY3RlZCBmYWNlc1xyXG4gICAgdmFyIHBvbHlBID0gaHVsbEEuZmFjZXNbY2xvc2VzdEZhY2VBXTtcclxuICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzID0gW107XHJcbiAgICBmb3IodmFyIGk9MDsgaTxodWxsQS5mYWNlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICBpZihwb2x5QS5pbmRleE9mKGh1bGxBLmZhY2VzW2ldW2pdKSE9PS0xIC8qIFNoYXJpbmcgYSB2ZXJ0ZXgqLyAmJiBpIT09Y2xvc2VzdEZhY2VBIC8qIE5vdCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvciBjb25uZWN0aW9ucyBmcm9tICovICYmIHBvbHlBLmNvbm5lY3RlZEZhY2VzLmluZGV4T2YoaSk9PT0tMSAvKiBOb3QgYWxyZWFkeSBhZGRlZCAqLyApe1xyXG4gICAgICAgICAgICAgICAgcG9seUEuY29ubmVjdGVkRmFjZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENsaXAgdGhlIHBvbHlnb24gdG8gdGhlIGJhY2sgb2YgdGhlIHBsYW5lcyBvZiBhbGwgZmFjZXMgb2YgaHVsbCBBLCB0aGF0IGFyZSBhZGphY2VudCB0byB0aGUgd2l0bmVzcyBmYWNlXHJcbiAgICB2YXIgbnVtQ29udGFjdHMgPSBwVnR4SW4ubGVuZ3RoO1xyXG4gICAgdmFyIG51bVZlcnRpY2VzQSA9IHBvbHlBLmxlbmd0aDtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIGZvcih2YXIgZTA9MDsgZTA8bnVtVmVydGljZXNBOyBlMCsrKXtcclxuICAgICAgICB2YXIgYSA9IGh1bGxBLnZlcnRpY2VzW3BvbHlBW2UwXV07XHJcbiAgICAgICAgdmFyIGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoZTArMSklbnVtVmVydGljZXNBXV07XHJcbiAgICAgICAgYS52c3ViKGIsZWRnZTApO1xyXG4gICAgICAgIFdvcmxkRWRnZTAuY29weShlZGdlMCk7XHJcbiAgICAgICAgcXVhdEEudm11bHQoV29ybGRFZGdlMCxXb3JsZEVkZ2UwKTtcclxuICAgICAgICBwb3NBLnZhZGQoV29ybGRFZGdlMCxXb3JsZEVkZ2UwKTtcclxuICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pOy8vdHJhbnNBLmdldEJhc2lzKCkqIGJ0VmVjdG9yMyhwb2x5QS5tX3BsYW5lWzBdLHBvbHlBLm1fcGxhbmVbMV0scG9seUEubV9wbGFuZVsyXSk7XHJcbiAgICAgICAgcXVhdEEudm11bHQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XHJcbiAgICAgICAgcG9zQS52YWRkKHdvcmxkUGxhbmVBbm9ybWFsMSx3b3JsZFBsYW5lQW5vcm1hbDEpO1xyXG4gICAgICAgIFdvcmxkRWRnZTAuY3Jvc3Mod29ybGRQbGFuZUFub3JtYWwxLHBsYW5lTm9ybWFsV1MxKTtcclxuICAgICAgICBwbGFuZU5vcm1hbFdTMS5uZWdhdGUocGxhbmVOb3JtYWxXUzEpO1xyXG4gICAgICAgIHdvcmxkQTEuY29weShhKTtcclxuICAgICAgICBxdWF0QS52bXVsdCh3b3JsZEExLHdvcmxkQTEpO1xyXG4gICAgICAgIHBvc0EudmFkZCh3b3JsZEExLHdvcmxkQTEpO1xyXG4gICAgICAgIHZhciBwbGFuZUVxV1MxID0gLXdvcmxkQTEuZG90KHBsYW5lTm9ybWFsV1MxKTtcclxuICAgICAgICB2YXIgcGxhbmVFcVdTO1xyXG4gICAgICAgIGlmKHRydWUpe1xyXG4gICAgICAgICAgICB2YXIgb3RoZXJGYWNlID0gcG9seUEuY29ubmVjdGVkRmFjZXNbZTBdO1xyXG4gICAgICAgICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tvdGhlckZhY2VdKTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpO1xyXG5cclxuICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xyXG4gICAgICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xyXG4gICAgICAgICAgICAvL3Bvc0EudmFkZChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xyXG4gICAgICAgICAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XHJcbiAgICAgICAgfSBlbHNlICB7XHJcbiAgICAgICAgICAgIHBsYW5lTm9ybWFsV1MuY29weShwbGFuZU5vcm1hbFdTMSk7XHJcbiAgICAgICAgICAgIHBsYW5lRXFXUyA9IHBsYW5lRXFXUzE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGlwIGZhY2UgYWdhaW5zdCBvdXIgY29uc3RydWN0ZWQgcGxhbmVcclxuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKHBWdHhJbiwgcFZ0eE91dCwgcGxhbmVOb3JtYWxXUywgcGxhbmVFcVdTKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgYXdheSBhbGwgY2xpcHBlZCBwb2ludHMsIGJ1dCBzYXZlIHRoZSByZWFtaW5pbmcgdW50aWwgbmV4dCBjbGlwXHJcbiAgICAgICAgd2hpbGUocFZ0eEluLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHBWdHhJbi5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZShwVnR4T3V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHBWdHhJbi5wdXNoKHBWdHhPdXQuc2hpZnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vY29uc29sZS5sb2coXCJSZXN1bHRpbmcgcG9pbnRzIGFmdGVyIGNsaXA6XCIscFZ0eEluKTtcclxuXHJcbiAgICAvLyBvbmx5IGtlZXAgY29udGFjdCBwb2ludHMgdGhhdCBhcmUgYmVoaW5kIHRoZSB3aXRuZXNzIGZhY2VcclxuICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pO1xyXG5cclxuICAgIHZhciBsb2NhbFBsYW5lRXEgPSB0aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UoY2xvc2VzdEZhY2VBKTtcclxuICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTtcclxuICAgIHF1YXRBLnZtdWx0KHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XHJcblxyXG4gICAgdmFyIHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpO1xyXG4gICAgZm9yICh2YXIgaT0wOyBpPHBWdHhJbi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGRlcHRoID0gcGxhbmVOb3JtYWxXUy5kb3QocFZ0eEluW2ldKSArIHBsYW5lRXFXUzsgLy8/Pz9cclxuICAgICAgICAvKmNvbnNvbGUubG9nKFwiZGVwdGggY2FsYyBmcm9tIG5vcm1hbD1cIixwbGFuZU5vcm1hbFdTLnRvU3RyaW5nKCksXCIgYW5kIGNvbnN0YW50IFwiK3BsYW5lRXFXUytcIiBhbmQgdmVydGV4IFwiLHBWdHhJbltpXS50b1N0cmluZygpLFwiIGdpdmVzIFwiK2RlcHRoKTsqL1xyXG4gICAgICAgIGlmIChkZXB0aCA8PW1pbkRpc3Qpe1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNsYW1wZWQ6IGRlcHRoPVwiK2RlcHRoK1wiIHRvIG1pbkRpc3Q9XCIrKG1pbkRpc3QrXCJcIikpO1xyXG4gICAgICAgICAgICBkZXB0aCA9IG1pbkRpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVwdGggPD1tYXhEaXN0KXtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gcFZ0eEluW2ldO1xyXG4gICAgICAgICAgICBpZihkZXB0aDw9MCl7XHJcbiAgICAgICAgICAgICAgICAvKmNvbnNvbGUubG9nKFwiR290IGNvbnRhY3QgcG9pbnQgXCIscG9pbnQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgXCIsIGRlcHRoPVwiLGRlcHRoLFxyXG4gICAgICAgICAgICAgICAgICBcImNvbnRhY3Qgbm9ybWFsPVwiLHNlcGFyYXRpbmdOb3JtYWwudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgXCJwbGFuZVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgXCJwbGFuZUNvbnN0YW50XCIscGxhbmVFcVdTKTsqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6cG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsOnBsYW5lTm9ybWFsV1MsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsaXAgYSBmYWNlIGluIGEgaHVsbCBhZ2FpbnN0IHRoZSBiYWNrIG9mIGEgcGxhbmUuXHJcbiAqIEBtZXRob2QgY2xpcEZhY2VBZ2FpbnN0UGxhbmVcclxuICogQHBhcmFtIHtBcnJheX0gaW5WZXJ0aWNlc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRWZXJ0aWNlc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHBsYW5lTm9ybWFsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uXHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jbGlwRmFjZUFnYWluc3RQbGFuZSA9IGZ1bmN0aW9uKGluVmVydGljZXMsb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KXtcclxuICAgIHZhciBuX2RvdF9maXJzdCwgbl9kb3RfbGFzdDtcclxuICAgIHZhciBudW1WZXJ0cyA9IGluVmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgIGlmKG51bVZlcnRzIDwgMil7XHJcbiAgICAgICAgcmV0dXJuIG91dFZlcnRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaXJzdFZlcnRleCA9IGluVmVydGljZXNbaW5WZXJ0aWNlcy5sZW5ndGgtMV0sXHJcbiAgICAgICAgbGFzdFZlcnRleCA9ICAgaW5WZXJ0aWNlc1swXTtcclxuXHJcbiAgICBuX2RvdF9maXJzdCA9IHBsYW5lTm9ybWFsLmRvdChmaXJzdFZlcnRleCkgKyBwbGFuZUNvbnN0YW50O1xyXG5cclxuICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IG51bVZlcnRzOyB2aSsrKXtcclxuICAgICAgICBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1t2aV07XHJcbiAgICAgICAgbl9kb3RfbGFzdCA9IHBsYW5lTm9ybWFsLmRvdChsYXN0VmVydGV4KSArIHBsYW5lQ29uc3RhbnQ7XHJcbiAgICAgICAgaWYobl9kb3RfZmlyc3QgPCAwKXtcclxuICAgICAgICAgICAgaWYobl9kb3RfbGFzdCA8IDApe1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPCAwLCBzbyBvdXRwdXQgbGFzdFZlcnRleFxyXG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgICAgICAgICAgbmV3di5jb3B5KGxhc3RWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kID49IDAsIHNvIG91dHB1dCBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XHJcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYobl9kb3RfbGFzdDwwKXtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0ID49IDAsIGVuZCA8IDAgc28gb3V0cHV0IGludGVyc2VjdGlvbiBhbmQgZW5kXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3diA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3YpO1xyXG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcclxuICAgICAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobGFzdFZlcnRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmlyc3RWZXJ0ZXggPSBsYXN0VmVydGV4O1xyXG4gICAgICAgIG5fZG90X2ZpcnN0ID0gbl9kb3RfbGFzdDtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRWZXJ0aWNlcztcclxufTtcclxuXHJcbi8vIFVwZGF0ZXMgLndvcmxkVmVydGljZXMgYW5kIHNldHMgLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSB0byBmYWxzZS5cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbihwb3NpdGlvbixxdWF0KXtcclxuICAgIHZhciBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB3aGlsZSh0aGlzLndvcmxkVmVydGljZXMubGVuZ3RoIDwgTil7XHJcbiAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2goIG5ldyBWZWMzKCkgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxyXG4gICAgICAgIHdvcmxkVmVydHMgPSB0aGlzLndvcmxkVmVydGljZXM7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgcXVhdC52bXVsdCggdmVydHNbaV0gLCB3b3JsZFZlcnRzW2ldICk7XHJcbiAgICAgICAgcG9zaXRpb24udmFkZCggd29ybGRWZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG59O1xyXG5cclxudmFyIGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0ID0gbmV3IFZlYzMoKTtcclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZUxvY2FsQUFCQiA9IGZ1bmN0aW9uKGFhYmJtaW4sYWFiYm1heCl7XHJcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcclxuICAgICAgICB3b3JsZFZlcnQgPSBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydDtcclxuXHJcbiAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcclxuICAgIGFhYmJtYXguc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XHJcbiAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICBpZiAgICAgKHYueCA8IGFhYmJtaW4ueCl7XHJcbiAgICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDtcclxuICAgICAgICB9IGVsc2UgaWYodi54ID4gYWFiYm1heC54KXtcclxuICAgICAgICAgICAgYWFiYm1heC54ID0gdi54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAgICAgKHYueSA8IGFhYmJtaW4ueSl7XHJcbiAgICAgICAgICAgIGFhYmJtaW4ueSA9IHYueTtcclxuICAgICAgICB9IGVsc2UgaWYodi55ID4gYWFiYm1heC55KXtcclxuICAgICAgICAgICAgYWFiYm1heC55ID0gdi55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAgICAgKHYueiA8IGFhYmJtaW4ueil7XHJcbiAgICAgICAgICAgIGFhYmJtaW4ueiA9IHYuejtcclxuICAgICAgICB9IGVsc2UgaWYodi56ID4gYWFiYm1heC56KXtcclxuICAgICAgICAgICAgYWFiYm1heC56ID0gdi56O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXHJcbiAqIEBtZXRob2QgY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHNcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHMgPSBmdW5jdGlvbihxdWF0KXtcclxuICAgIHZhciBOID0gdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7XHJcbiAgICB3aGlsZSh0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoIDwgTil7XHJcbiAgICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzLnB1c2goIG5ldyBWZWMzKCkgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHMsXHJcbiAgICAgICAgd29ybGROb3JtYWxzID0gdGhpcy53b3JsZEZhY2VOb3JtYWxzO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHF1YXQudm11bHQoIG5vcm1hbHNbaV0gLCB3b3JsZE5vcm1hbHNbaV0gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcclxuICovXHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXJcclxuICAgIHZhciBtYXgyID0gMDtcclxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcbiAgICBmb3IodmFyIGk9MCwgTj12ZXJ0cy5sZW5ndGg7IGkhPT1OOyBpKyspIHtcclxuICAgICAgICB2YXIgbm9ybTIgPSB2ZXJ0c1tpXS5ub3JtMigpO1xyXG4gICAgICAgIGlmKG5vcm0yID4gbWF4Mil7XHJcbiAgICAgICAgICAgIG1heDIgPSBub3JtMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpO1xyXG59O1xyXG5cclxudmFyIHRlbXBXb3JsZFZlcnRleCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjYWxjdWxhdGVXb3JsZEFBQkJcclxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcclxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWluXHJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxyXG4gKi9cclxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XHJcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcbiAgICB2YXIgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XHJcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xyXG4gICAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcclxuICAgICAgICBxdWF0LnZtdWx0KHRlbXBXb3JsZFZlcnRleCx0ZW1wV29ybGRWZXJ0ZXgpO1xyXG4gICAgICAgIHBvcy52YWRkKHRlbXBXb3JsZFZlcnRleCx0ZW1wV29ybGRWZXJ0ZXgpO1xyXG4gICAgICAgIHZhciB2ID0gdGVtcFdvcmxkVmVydGV4O1xyXG4gICAgICAgIGlmICAgICAodi54IDwgbWlueCB8fCBtaW54PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWlueCA9IHYueDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1heHggPSB2Lng7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAgICAgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1pbnkgPSB2Lnk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBcclxuICAgICAgICBpZih2LnkgPiBtYXh5IHx8IG1heHk9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtYXh5ID0gdi55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgICAgICh2LnogPCBtaW56IHx8IG1pbno9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtaW56ID0gdi56O1xyXG4gICAgICAgIH0gIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1heHogPSB2Lno7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XHJcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYXBwcm94aW1hdGUgY29udmV4IHZvbHVtZVxyXG4gKiBAbWV0aG9kIHZvbHVtZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmVydGljZXMgcG9zaXRpb25zXHJcbiAqIEBtZXRob2QgZ2V0QXZlcmFnZVBvaW50TG9jYWxcclxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAqIEByZXR1cm4ge1ZlYzN9XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRBdmVyYWdlUG9pbnRMb2NhbCA9IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcclxuICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSx0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgdGFyZ2V0Lm11bHQoMS9uLHRhcmdldCk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzXHJcbiAqIEBtZXRob2QgdHJhbnNmb3JtQWxsUG9pbnRzXHJcbiAqIEBwYXJhbSAge1ZlYzN9IG9mZnNldFxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqL1xyXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50cmFuc2Zvcm1BbGxQb2ludHMgPSBmdW5jdGlvbihvZmZzZXQscXVhdCl7XHJcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuXHJcbiAgICAvLyBBcHBseSByb3RhdGlvblxyXG4gICAgaWYocXVhdCl7XHJcbiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSb3RhdGUgZmFjZSBub3JtYWxzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5mYWNlTm9ybWFsc1tpXTtcclxuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIC8vIFJvdGF0ZSBlZGdlc1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pcXVlRWRnZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudW5pcXVlRWRnZXNbaV07XHJcbiAgICAgICAgICAgIHF1YXQudm11bHQodix2KTtcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBvZmZzZXRcclxuICAgIGlmKG9mZnNldCl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuICAgICAgICAgICAgdi52YWRkKG9mZnNldCx2KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcCBpcyBpbnNpZGUgdGhlIHBvbHloZWRyYS4gTXVzdCBiZSBpbiBsb2NhbCBjb29yZHMuIFRoZSBwb2ludCBsaWVzIG91dHNpZGUgb2YgdGhlIGNvbnZleCBodWxsIG9mIHRoZSBvdGhlciBwb2ludHMgaWYgYW5kIG9ubHkgaWYgdGhlIGRpcmVjdGlvbiBvZiBhbGwgdGhlIHZlY3RvcnMgZnJvbSBpdCB0byB0aG9zZSBvdGhlciBwb2ludHMgYXJlIG9uIGxlc3MgdGhhbiBvbmUgaGFsZiBvZiBhIHNwaGVyZSBhcm91bmQgaXQuXHJcbiAqIEBtZXRob2QgcG9pbnRJc0luc2lkZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxudmFyIENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1AgPSBuZXcgVmVjMygpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbl92VG9Qb2ludEluc2lkZSA9IG5ldyBWZWMzKCk7XHJcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnBvaW50SXNJbnNpZGUgPSBmdW5jdGlvbihwKXtcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxyXG4gICAgICAgIGZhY2VzID0gdGhpcy5mYWNlcyxcclxuICAgICAgICBub3JtYWxzID0gdGhpcy5mYWNlTm9ybWFscztcclxuICAgIHZhciBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7XHJcbiAgICB2YXIgTiA9IHRoaXMuZmFjZXMubGVuZ3RoO1xyXG4gICAgdmFyIHBvaW50SW5zaWRlID0gQ29udmV4UG9seWhlZHJvbl9wb2ludElzSW5zaWRlO1xyXG4gICAgdGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChwb2ludEluc2lkZSk7XHJcbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xyXG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IHRoaXMuZmFjZXNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIHZhciBuID0gbm9ybWFsc1tpXTtcclxuICAgICAgICB2YXIgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZVxyXG5cclxuICAgICAgICAvLyBUaGlzIGRvdCBwcm9kdWN0IGRldGVybWluZXMgd2hpY2ggc2lkZSBvZiB0aGUgZWRnZSB0aGUgcG9pbnQgaXNcclxuICAgICAgICB2YXIgdlRvUCA9IENvbnZleFBvbHloZWRyb25fdlRvUDtcclxuICAgICAgICBwLnZzdWIodix2VG9QKTtcclxuICAgICAgICB2YXIgcjEgPSBuLmRvdCh2VG9QKTtcclxuXHJcbiAgICAgICAgdmFyIHZUb1BvaW50SW5zaWRlID0gQ29udmV4UG9seWhlZHJvbl92VG9Qb2ludEluc2lkZTtcclxuICAgICAgICBwb2ludEluc2lkZS52c3ViKHYsdlRvUG9pbnRJbnNpZGUpO1xyXG4gICAgICAgIHZhciByMiA9IG4uZG90KHZUb1BvaW50SW5zaWRlKTtcclxuXHJcbiAgICAgICAgaWYoKHIxPDAgJiYgcjI+MCkgfHwgKHIxPjAgJiYgcjI8MCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXHJcbiAgICByZXR1cm4gcG9zaXRpdmVSZXN1bHQgPyAxIDogLTE7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG1heCBhbmQgbWluIGRvdCBwcm9kdWN0IG9mIGEgY29udmV4IGh1bGwgYXQgcG9zaXRpb24gKHBvcyxxdWF0KSBwcm9qZWN0ZWQgb250byBhbiBheGlzLiBSZXN1bHRzIGFyZSBzYXZlZCBpbiB0aGUgYXJyYXkgbWF4bWluLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgcHJvamVjdFxyXG4gKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxcclxuICogQHBhcmFtIHtWZWMzfSBheGlzXHJcbiAqIEBwYXJhbSB7VmVjM30gcG9zXHJcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdFxyXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgcmVzdWx0WzBdIGFuZCByZXN1bHRbMV0gd2lsbCBiZSBzZXQgdG8gbWF4aW11bSBhbmQgbWluaW11bSwgcmVzcGVjdGl2ZWx5LlxyXG4gKi9cclxudmFyIHByb2plY3Rfd29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xyXG52YXIgcHJvamVjdF9sb2NhbEF4aXMgPSBuZXcgVmVjMygpO1xyXG52YXIgcHJvamVjdF9sb2NhbE9yaWdpbiA9IG5ldyBWZWMzKCk7XHJcbkNvbnZleFBvbHloZWRyb24ucHJvamVjdCA9IGZ1bmN0aW9uKGh1bGwsIGF4aXMsIHBvcywgcXVhdCwgcmVzdWx0KXtcclxuICAgIHZhciBuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgd29ybGRWZXJ0ZXggPSBwcm9qZWN0X3dvcmxkVmVydGV4LFxyXG4gICAgICAgIGxvY2FsQXhpcyA9IHByb2plY3RfbG9jYWxBeGlzLFxyXG4gICAgICAgIG1heCA9IDAsXHJcbiAgICAgICAgbWluID0gMCxcclxuICAgICAgICBsb2NhbE9yaWdpbiA9IHByb2plY3RfbG9jYWxPcmlnaW4sXHJcbiAgICAgICAgdnMgPSBodWxsLnZlcnRpY2VzO1xyXG5cclxuICAgIGxvY2FsT3JpZ2luLnNldFplcm8oKTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWxcclxuICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBheGlzLCBsb2NhbEF4aXMpO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgbG9jYWxPcmlnaW4sIGxvY2FsT3JpZ2luKTtcclxuICAgIHZhciBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTtcclxuXHJcbiAgICBtaW4gPSBtYXggPSB2c1swXS5kb3QobG9jYWxBeGlzKTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgbjsgaSsrKXtcclxuICAgICAgICB2YXIgdmFsID0gdnNbaV0uZG90KGxvY2FsQXhpcyk7XHJcblxyXG4gICAgICAgIGlmKHZhbCA+IG1heCl7XHJcbiAgICAgICAgICAgIG1heCA9IHZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHZhbCA8IG1pbil7XHJcbiAgICAgICAgICAgIG1pbiA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWluIC09IGFkZDtcclxuICAgIG1heCAtPSBhZGQ7XHJcblxyXG4gICAgaWYobWluID4gbWF4KXtcclxuICAgICAgICAvLyBJbmNvbnNpc3RlbnQgLSBzd2FwXHJcbiAgICAgICAgdmFyIHRlbXAgPSBtaW47XHJcbiAgICAgICAgbWluID0gbWF4O1xyXG4gICAgICAgIG1heCA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICAvLyBPdXRwdXRcclxuICAgIHJlc3VsdFswXSA9IG1heDtcclxuICAgIHJlc3VsdFsxXSA9IG1pbjtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MzAsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjMxLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL1NoYXBlXCI6NDV9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gQ3lsaW5kZXI7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XHJcbnZhciBDTWF0aCA9IF9kZXJlcV8oJy4uL21hdGgvQ01hdGgnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQ3lsaW5kZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVG9wXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtU2VnbWVudHMgVGhlIG51bWJlciBvZiBzZWdtZW50cyB0byBidWlsZCB0aGUgY3lsaW5kZXIgb3V0IG9mXHJcbiAqL1xyXG5mdW5jdGlvbiBDeWxpbmRlciggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCAsIG51bVNlZ21lbnRzICwgaXNEaXJZKSB7XHJcbiAgICBpZiAoaXNEaXJZKSB7XHJcbiAgICAgICAgdmFyIE4gPSBudW1TZWdtZW50cyxcclxuICAgICAgICBjb3MgPSBDTWF0aC5jb3MsXHJcbiAgICAgICAgc2luID0gQ01hdGguc2luO1xyXG4gICAgICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICB2YXIgdGYgPSBbMF07XHJcbiAgICAgICAgdmFyIGJmID0gWzFdO1xyXG4gICAgICAgIHZhciBheGVzID0gW107XHJcbiAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5QSSAqIDIgLyBOO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wICogY29zKHRoZXRhICogaSksIGhhbGZILCByYWRpdXNUb3AgKiBzaW4odGhldGEgKiBpKSkpO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCAqIGNvcyh0aGV0YSAqIGkpLCAtaGFsZkgsIHJhZGl1c1RvcCAqIHNpbih0aGV0YSAqIGkpKSk7XHJcbiAgICAgICAgICAgIGlmIChpIDwgTiAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChbMiAqIGkgKyAyLCAyICogaSArIDMsIDIgKiBpICsgMSwgMiAqIGldKTtcclxuICAgICAgICAgICAgICAgIHRmLnB1c2goMiAqIGkgKyAyKTtcclxuICAgICAgICAgICAgICAgIGJmLnB1c2goMiAqIGkgKyAzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChbMCwgMSwgMiAqIGkgKyAxLCAyICogaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOICUgMiA9PT0gMSB8fCBpIDwgTiAvIDIpIGF4ZXMucHVzaChuZXcgVmVjMyhjb3ModGhldGEgKiAoaSArIDAuNSkpLCAwLCBzaW4odGhldGEgKiAoaSArIDAuNSkpKSk7ICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGljZXMucHVzaChiZik7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRmLmxlbmd0aDsgaSsrKSB0ZW1wLnB1c2godGZbdGYubGVuZ3RoIC0gaSAtIDFdKTsgICAgXHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRlbXApO1xyXG4gICAgICAgIGF4ZXMucHVzaChuZXcgVmVjMygwLCAxLCAwKSk7XHJcbiAgICAgICAgQ29udmV4UG9seWhlZHJvbi5jYWxsKHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCBheGVzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgTiA9IG51bVNlZ21lbnRzLFxyXG4gICAgICAgIHZlcnRzID0gW10sXHJcbiAgICAgICAgYXhlcyA9IFtdLFxyXG4gICAgICAgIGZhY2VzID0gW10sXHJcbiAgICAgICAgYm90dG9tZmFjZSA9IFtdLFxyXG4gICAgICAgIHRvcGZhY2UgPSBbXSxcclxuICAgICAgICBjb3MgPSBDTWF0aC5jb3MsXHJcbiAgICAgICAgc2luID0gQ01hdGguc2luO1xyXG5cclxuICAgIC8vIEZpcnN0IGJvdHRvbSBwb2ludFxyXG4gICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNCb3R0b20qY29zKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbigwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1oZWlnaHQqMC41KSk7XHJcbiAgICBib3R0b21mYWNlLnB1c2goMCk7XHJcblxyXG4gICAgLy8gRmlyc3QgdG9wIHBvaW50XHJcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3MoMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3Aqc2luKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0KjAuNSkpO1xyXG4gICAgdG9wZmFjZS5wdXNoKDEpO1xyXG5cclxuICAgIGZvcih2YXIgaT0wOyBpPE47IGkrKyl7XHJcbiAgICAgICAgdmFyIHRoZXRhID0gMipNYXRoLlBJL04gKiAoaSsxKTtcclxuICAgICAgICB2YXIgdGhldGFOID0gMipNYXRoLlBJL04gKiAoaSswLjUpO1xyXG4gICAgICAgIGlmKGk8Ti0xKXtcclxuICAgICAgICAgICAgLy8gQm90dG9tXHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzQm90dG9tKmNvcyh0aGV0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c0JvdHRvbSpzaW4odGhldGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0KjAuNSkpO1xyXG4gICAgICAgICAgICBib3R0b21mYWNlLnB1c2goMippKzIpO1xyXG4gICAgICAgICAgICAvLyBUb3BcclxuICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNUb3AqY29zKHRoZXRhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzVG9wKnNpbih0aGV0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCowLjUpKTtcclxuICAgICAgICAgICAgdG9wZmFjZS5wdXNoKDIqaSszKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhY2VcclxuICAgICAgICAgICAgZmFjZXMucHVzaChbMippKzIsIDIqaSszLCAyKmkrMSwyKmldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmYWNlcy5wdXNoKFswLDEsIDIqaSsxLCAyKmldKTsgLy8gQ29ubmVjdFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXhpczogd2UgY2FuIGN1dCBvZmYgaGFsZiBvZiB0aGVtIGlmIHdlIGhhdmUgZXZlbiBudW1iZXIgb2Ygc2VnbWVudHNcclxuICAgICAgICBpZihOICUgMiA9PT0gMSB8fCBpIDwgTiAvIDIpe1xyXG4gICAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoY29zKHRoZXRhTiksIHNpbih0aGV0YU4pLCAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmFjZXMucHVzaCh0b3BmYWNlKTtcclxuICAgIGF4ZXMucHVzaChuZXcgVmVjMygwLDAsMSkpO1xyXG5cclxuICAgIC8vIFJlb3JkZXIgYm90dG9tIGZhY2VcclxuICAgIHZhciB0ZW1wID0gW107XHJcbiAgICBmb3IodmFyIGk9MDsgaTxib3R0b21mYWNlLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB0ZW1wLnB1c2goYm90dG9tZmFjZVtib3R0b21mYWNlLmxlbmd0aCAtIGkgLSAxXSk7XHJcbiAgICB9XHJcbiAgICBmYWNlcy5wdXNoKHRlbXApO1xyXG5cclxuICAgIENvbnZleFBvbHloZWRyb24uY2FsbCggdGhpcywgdmVydHMsIGZhY2VzLCBheGVzICk7XHJcbn1cclxuXHJcbkN5bGluZGVyLnByb3RvdHlwZSA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XHJcblxyXG59LHtcIi4uL21hdGgvQ01hdGhcIjoyNyxcIi4uL21hdGgvUXVhdGVybmlvblwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL0NvbnZleFBvbHloZWRyb25cIjo0MCxcIi4vU2hhcGVcIjo0NX1dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4vQ29udmV4UG9seWhlZHJvbicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHRmaWVsZDtcclxuXHJcbi8qKlxyXG4gKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZ2l2ZW4gZGlzdGFuY2UuXHJcbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRTaXplPTAuMV0gV29ybGQgc3BhY2luZyBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvbi5cclxuICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeVxyXG4gKiBAdG9kbyBzaG91bGQgYmUgcG9zc2libGUgdG8gc2NhbGUgYWxvbmcgYWxsIGF4ZXNcclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cclxuICogICAgIHZhciBkYXRhID0gW107XHJcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcclxuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xyXG4gKiAgICAgICAgIGRhdGEucHVzaCh5KTtcclxuICogICAgIH1cclxuICpcclxuICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGVcclxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcclxuICogICAgICAgICBlbGVtZW50U2l6ZTogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGFuZCBZIGRpcmVjdGlvbnNcclxuICogICAgIH0pO1xyXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XHJcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XHJcbiAqICAgICB3b3JsZC5hZGRCb2R5KGhlaWdodGZpZWxkQm9keSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBIZWlnaHRmaWVsZChkYXRhLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XHJcbiAgICAgICAgbWF4VmFsdWUgOiBudWxsLFxyXG4gICAgICAgIG1pblZhbHVlIDogbnVsbCxcclxuICAgICAgICBlbGVtZW50U2l6ZSA6IDFcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxyXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50U2l6ZVxyXG4gICAgICogQHRvZG8gZWxlbWVudFNpemVYIGFuZCBZXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZWxlbWVudFNpemUgPSBvcHRpb25zLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIGlmKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwpe1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWluVmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmKG9wdGlvbnMubWF4VmFsdWUgPT09IG51bGwpe1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgU2hhcGUuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuSEVJR0hURklFTERcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucGlsbGFyQ29udmV4ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcclxuICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XHJcblxyXG4gICAgLy8gXCJpX2pfaXNVcHBlclwiID0+IHsgY29udmV4OiAuLi4sIG9mZnNldDogLi4uIH1cclxuICAgIC8vIGZvciBleGFtcGxlOlxyXG4gICAgLy8gX2NhY2hlZFBpbGxhcnNbXCIwXzJfMVwiXVxyXG4gICAgdGhpcy5fY2FjaGVkUGlsbGFycyA9IHt9O1xyXG59XHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuLyoqXHJcbiAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS5cclxuICogQG1ldGhvZCB1cGRhdGVcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fY2FjaGVkUGlsbGFycyA9IHt9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIHByb3BlcnR5XHJcbiAqIEBtZXRob2QgdXBkYXRlTWluVmFsdWVcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVNaW5WYWx1ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHZhciBtaW5WYWx1ZSA9IGRhdGFbMF1bMF07XHJcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgdiA9IGRhdGFbaV1bal07XHJcbiAgICAgICAgICAgIGlmKHYgPCBtaW5WYWx1ZSl7XHJcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLm1pblZhbHVlID0gbWluVmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSAubWF4VmFsdWUgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVNYXhWYWx1ZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heFZhbHVlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIG1heFZhbHVlID0gZGF0YVswXVswXTtcclxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gZGF0YVtpXS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcclxuICAgICAgICAgICAgaWYodiA+IG1heFZhbHVlKXtcclxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGhlaWdodCB2YWx1ZSBhdCBhbiBpbmRleC4gRG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYWZ0ZXIgeW91J3JlIGRvbmUuXHJcbiAqIEBtZXRob2Qgc2V0SGVpZ2h0VmFsdWVBdEluZGV4XHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0geGlcclxuICogQHBhcmFtIHtpbnRlZ2VyfSB5aVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbih4aSwgeWksIHZhbHVlKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgZGF0YVt4aV1beWldID0gdmFsdWU7XHJcblxyXG4gICAgLy8gSW52YWxpZGF0ZSBjYWNoZVxyXG4gICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZmFsc2UpO1xyXG4gICAgaWYoeGkgPiAwKXtcclxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlmKHlpID4gMCl7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBpZih5aSA+IDAgJiYgeGkgPiAwKXtcclxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBtYXgvbWluIGluIGEgcmVjdGFuZ2xlIGluIHRoZSBtYXRyaXggZGF0YVxyXG4gKiBAbWV0aG9kIGdldFJlY3RNaW5NYXhcclxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1pblhcclxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1pbllcclxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFhcclxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFlcclxuICogQHBhcmFtICB7YXJyYXl9IFtyZXN1bHRdIEFuIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLlxyXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLlxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFJlY3RNaW5NYXggPSBmdW5jdGlvbiAoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIHJlc3VsdCkge1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG5cclxuICAgIC8vIEdldCBtYXggYW5kIG1pbiBvZiB0aGUgZGF0YVxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgbWF4ID0gdGhpcy5taW5WYWx1ZTsgLy8gU2V0IGZpcnN0IHZhbHVlXHJcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8PSBpTWF4WDsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaV1bal07XHJcbiAgICAgICAgICAgIGlmKGhlaWdodCA+IG1heCl7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTtcclxuICAgIHJlc3VsdFsxXSA9IG1heDtcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgaW5kZXggb2YgYSBsb2NhbCBwb3NpdGlvbiBvbiB0aGUgaGVpZ2h0ZmllbGQuIFRoZSBpbmRleGVzIGluZGljYXRlIHRoZSByZWN0YW5nbGVzLCBzbyBpZiB5b3VyIHRlcnJhaW4gaXMgbWFkZSBvZiBOIHggTiBoZWlnaHQgZGF0YSBwb2ludHMsIHlvdSB3aWxsIGhhdmUgcmVjdGFuZ2xlIGluZGV4ZXMgcmFuZ2luZyBmcm9tIDAgdG8gTi0xLlxyXG4gKiBAbWV0aG9kIGdldEluZGV4T2ZQb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcclxuICogQHBhcmFtICB7bnVtYmVyfSB5XHJcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXlcclxuICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXAgSWYgdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBjbGFtcGVkIHRvIHRoZSBoZWlnaHRmaWVsZCBlZGdlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldEluZGV4T2ZQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCByZXN1bHQsIGNsYW1wKSB7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XHJcbiAgICB2YXIgdyA9IHRoaXMuZWxlbWVudFNpemU7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHZhciB4aSA9IE1hdGguZmxvb3IoeCAvIHcpO1xyXG4gICAgdmFyIHlpID0gTWF0aC5mbG9vcih5IC8gdyk7XHJcblxyXG4gICAgcmVzdWx0WzBdID0geGk7XHJcbiAgICByZXN1bHRbMV0gPSB5aTtcclxuXHJcbiAgICBpZihjbGFtcCl7XHJcbiAgICAgICAgLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcclxuICAgICAgICBpZih4aSA8IDApeyB4aSA9IDA7IH1cclxuICAgICAgICBpZih5aSA8IDApeyB5aSA9IDA7IH1cclxuICAgICAgICBpZih4aSA+PSBkYXRhLmxlbmd0aCAtIDEpeyB4aSA9IGRhdGEubGVuZ3RoIC0gMTsgfVxyXG4gICAgICAgIGlmKHlpID49IGRhdGFbMF0ubGVuZ3RoIC0gMSl7IHlpID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxyXG4gICAgaWYoeGkgPCAwIHx8IHlpIDwgMCB8fCB4aSA+PSBkYXRhLmxlbmd0aC0xIHx8IHlpID49IGRhdGFbMF0ubGVuZ3RoLTEpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG52YXIgZ2V0SGVpZ2h0QXRfaWR4ID0gW107XHJcbnZhciBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTtcclxudmFyIGdldEhlaWdodEF0X2EgPSBuZXcgVmVjMygpO1xyXG52YXIgZ2V0SGVpZ2h0QXRfYiA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTtcclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRUcmlhbmdsZUF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKXtcclxuICAgIHZhciBpZHggPSBnZXRIZWlnaHRBdF9pZHg7XHJcbiAgICB0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih4LCB5LCBpZHgsIGVkZ2VDbGFtcCk7XHJcbiAgICB2YXIgeGkgPSBpZHhbMF07XHJcbiAgICB2YXIgeWkgPSBpZHhbMV07XHJcblxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICBpZihlZGdlQ2xhbXApe1xyXG4gICAgICAgIHhpID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB4aSkpO1xyXG4gICAgICAgIHlpID0gTWF0aC5taW4oZGF0YVswXS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB5aSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XHJcbiAgICB2YXIgbG93ZXJEaXN0MiA9IE1hdGgucG93KHggLyBlbGVtZW50U2l6ZSAtIHhpLCAyKSArIE1hdGgucG93KHkgLyBlbGVtZW50U2l6ZSAtIHlpLCAyKTtcclxuICAgIHZhciB1cHBlckRpc3QyID0gTWF0aC5wb3coeCAvIGVsZW1lbnRTaXplIC0gKHhpICsgMSksIDIpICsgTWF0aC5wb3coeSAvIGVsZW1lbnRTaXplIC0gKHlpICsgMSksIDIpO1xyXG4gICAgdmFyIHVwcGVyID0gbG93ZXJEaXN0MiA+IHVwcGVyRGlzdDI7XHJcbiAgICB0aGlzLmdldFRyaWFuZ2xlKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpO1xyXG4gICAgcmV0dXJuIHVwcGVyO1xyXG59O1xyXG5cclxudmFyIGdldE5vcm1hbEF0X2EgPSBuZXcgVmVjMygpO1xyXG52YXIgZ2V0Tm9ybWFsQXRfYiA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTtcclxudmFyIGdldE5vcm1hbEF0X2UwID0gbmV3IFZlYzMoKTtcclxudmFyIGdldE5vcm1hbEF0X2UxID0gbmV3IFZlYzMoKTtcclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldE5vcm1hbEF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpe1xyXG4gICAgdmFyIGEgPSBnZXROb3JtYWxBdF9hO1xyXG4gICAgdmFyIGIgPSBnZXROb3JtYWxBdF9iO1xyXG4gICAgdmFyIGMgPSBnZXROb3JtYWxBdF9jO1xyXG4gICAgdmFyIGUwID0gZ2V0Tm9ybWFsQXRfZTA7XHJcbiAgICB2YXIgZTEgPSBnZXROb3JtYWxBdF9lMTtcclxuICAgIHRoaXMuZ2V0VHJpYW5nbGVBdCh4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpO1xyXG4gICAgYi52c3ViKGEsIGUwKTtcclxuICAgIGMudnN1YihhLCBlMSk7XHJcbiAgICBlMC5jcm9zcyhlMSwgcmVzdWx0KTtcclxuICAgIHJlc3VsdC5ub3JtYWxpemUoKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IGFuIEFBQkIgb2YgYSBzcXVhcmUgaW4gdGhlIGhlaWdodGZpZWxkXHJcbiAqIEBwYXJhbSAge251bWJlcn0geGlcclxuICogQHBhcmFtICB7bnVtYmVyfSB5aVxyXG4gKiBAcGFyYW0gIHtBQUJCfSByZXN1bHRcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRBYWJiQXRJbmRleCA9IGZ1bmN0aW9uKHhpLCB5aSwgcmVzdWx0KXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcclxuXHJcbiAgICByZXN1bHQubG93ZXJCb3VuZC5zZXQoXHJcbiAgICAgICAgeGkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgIGRhdGFbeGldW3lpXVxyXG4gICAgKTtcclxuICAgIHJlc3VsdC51cHBlckJvdW5kLnNldChcclxuICAgICAgICAoeGkgKyAxKSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICh5aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV1cclxuICAgICk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgaGVpZ2h0IGluIHRoZSBoZWlnaHRmaWVsZCBhdCBhIGdpdmVuIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge251bWJlcn0geFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcclxuICogQHBhcmFtICB7Ym9vbGVhbn0gZWRnZUNsYW1wXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRIZWlnaHRBdCA9IGZ1bmN0aW9uKHgsIHksIGVkZ2VDbGFtcCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIHZhciBhID0gZ2V0SGVpZ2h0QXRfYTtcclxuICAgIHZhciBiID0gZ2V0SGVpZ2h0QXRfYjtcclxuICAgIHZhciBjID0gZ2V0SGVpZ2h0QXRfYztcclxuICAgIHZhciBpZHggPSBnZXRIZWlnaHRBdF9pZHg7XHJcblxyXG4gICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xyXG4gICAgdmFyIHhpID0gaWR4WzBdO1xyXG4gICAgdmFyIHlpID0gaWR4WzFdO1xyXG4gICAgaWYoZWRnZUNsYW1wKXtcclxuICAgICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTtcclxuICAgICAgICB5aSA9IE1hdGgubWluKGRhdGFbMF0ubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeWkpKTtcclxuICAgIH1cclxuICAgIHZhciB1cHBlciA9IHRoaXMuZ2V0VHJpYW5nbGVBdCh4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpO1xyXG4gICAgYmFyeWNlbnRyaWNXZWlnaHRzKHgsIHksIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIGdldEhlaWdodEF0X3dlaWdodHMpO1xyXG5cclxuICAgIHZhciB3ID0gZ2V0SGVpZ2h0QXRfd2VpZ2h0cztcclxuXHJcbiAgICBpZih1cHBlcil7XHJcblxyXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHJldHVybiBkYXRhW3hpICsgMV1beWkgKyAxXSAqIHcueCArIGRhdGFbeGldW3lpICsgMV0gKiB3LnkgKyBkYXRhW3hpICsgMV1beWldICogdy56O1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHJldHVybiBkYXRhW3hpXVt5aV0gKiB3LnggKyBkYXRhW3hpICsgMV1beWldICogdy55ICsgZGF0YVt4aV1beWkgKyAxXSAqIHcuejtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFyeWNlbnRyaWNfY29vcmRpbmF0ZV9zeXN0ZW1cclxuZnVuY3Rpb24gYmFyeWNlbnRyaWNXZWlnaHRzKHgsIHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHJlc3VsdCl7XHJcbiAgICByZXN1bHQueCA9ICgoYnkgLSBjeSkgKiAoeCAtIGN4KSArIChjeCAtIGJ4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpO1xyXG4gICAgcmVzdWx0LnkgPSAoKGN5IC0gYXkpICogKHggLSBjeCkgKyAoYXggLSBjeCkgKiAoeSAtIGN5KSkgLyAoKGJ5IC0gY3kpICogKGF4IC0gY3gpICsgKGN4IC0gYngpICogKGF5IC0gY3kpKTtcclxuICAgIHJlc3VsdC56ID0gMSAtIHJlc3VsdC54IC0gcmVzdWx0Lnk7XHJcbn1cclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5ID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKXtcclxuICAgIHJldHVybiB4aSArICdfJyArIHlpICsgJ18nICsgKGdldFVwcGVyVHJpYW5nbGUgPyAxIDogMCk7XHJcbn07XHJcblxyXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCl7XHJcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXSA9IHtcclxuICAgICAgICBjb252ZXg6IGNvbnZleCxcclxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgfTtcclxufTtcclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKXtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB0cmlhbmdsZSBmcm9tIHRoZSBoZWlnaHRmaWVsZFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhpXHJcbiAqIEBwYXJhbSAge251bWJlcn0geWlcclxuICogQHBhcmFtICB7Ym9vbGVhbn0gdXBwZXJcclxuICogQHBhcmFtICB7VmVjM30gYVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBiXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGNcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRUcmlhbmdsZSA9IGZ1bmN0aW9uKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xyXG5cclxuICAgIGlmKHVwcGVyKXtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgYS5zZXQoXHJcbiAgICAgICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgICh5aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aSArIDFdXHJcbiAgICAgICAgKTtcclxuICAgICAgICBiLnNldChcclxuICAgICAgICAgICAgeGkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYy5zZXQoXHJcbiAgICAgICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIHlpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV1cclxuICAgICAgICApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIGEuc2V0KFxyXG4gICAgICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpXVt5aV1cclxuICAgICAgICApO1xyXG4gICAgICAgIGIuc2V0KFxyXG4gICAgICAgICAgICAoeGkgKyAxKSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWldXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjLnNldChcclxuICAgICAgICAgICAgeGkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgdHJpYW5nbGUgaW4gdGhlIHRlcnJhaW4gaW4gdGhlIGZvcm0gb2YgYSB0cmlhbmd1bGFyIGNvbnZleCBzaGFwZS5cclxuICogQG1ldGhvZCBnZXRDb252ZXhUcmlhbmdsZVBpbGxhclxyXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpXHJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGpcclxuICogQHBhcmFtICB7Ym9vbGVhbn0gZ2V0VXBwZXJUcmlhbmdsZVxyXG4gKi9cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKXtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnBpbGxhckNvbnZleDtcclxuICAgIHZhciBvZmZzZXRSZXN1bHQgPSB0aGlzLnBpbGxhck9mZnNldDtcclxuXHJcbiAgICBpZih0aGlzLmNhY2hlRW5hYmxlZCl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSk7XHJcbiAgICAgICAgaWYoZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gZGF0YS5jb252ZXg7XHJcbiAgICAgICAgICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gZGF0YS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XHJcbiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICAgICAgdGhpcy5waWxsYXJDb252ZXggPSByZXN1bHQ7XHJcbiAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBvZmZzZXRSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xyXG4gICAgdmFyIGZhY2VzID0gcmVzdWx0LmZhY2VzO1xyXG5cclxuICAgIC8vIFJldXNlIHZlcnRzIGlmIHBvc3NpYmxlXHJcbiAgICByZXN1bHQudmVydGljZXMubGVuZ3RoID0gNjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgaWYoIXJlc3VsdC52ZXJ0aWNlc1tpXSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC52ZXJ0aWNlc1tpXSA9IG5ldyBWZWMzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldXNlIGZhY2VzIGlmIHBvc3NpYmxlXHJcbiAgICBmYWNlcy5sZW5ndGggPSA1O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICBpZighZmFjZXNbaV0pe1xyXG4gICAgICAgICAgICBmYWNlc1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmVydHMgPSByZXN1bHQudmVydGljZXM7XHJcblxyXG4gICAgdmFyIGggPSAoTWF0aC5taW4oXHJcbiAgICAgICAgZGF0YVt4aV1beWldLFxyXG4gICAgICAgIGRhdGFbeGkrMV1beWldLFxyXG4gICAgICAgIGRhdGFbeGldW3lpKzFdLFxyXG4gICAgICAgIGRhdGFbeGkrMV1beWkrMV1cclxuICAgICkgLSB0aGlzLm1pblZhbHVlICkgLyAyICsgdGhpcy5taW5WYWx1ZTtcclxuXHJcbiAgICBpZiAoIWdldFVwcGVyVHJpYW5nbGUpIHtcclxuXHJcbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXHJcbiAgICAgICAgb2Zmc2V0UmVzdWx0LnNldChcclxuICAgICAgICAgICAgKHhpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAoeWkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBoIC8vIHZlcnRpY2FsIGNlbnRlclxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHZlcnRzWzBdLnNldChcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aV1beWldIC0gaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydHNbMV0uc2V0KFxyXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV0gLSBoXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0c1syXS5zZXQoXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXSAtIGhcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcclxuICAgICAgICB2ZXJ0c1szXS5zZXQoXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC1oLTFcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzRdLnNldChcclxuICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtaC0xXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0c1s1XS5zZXQoXHJcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuNzUgICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC1oLTFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyB0b3AgdHJpYW5nbGVcclxuICAgICAgICBmYWNlc1swXVswXSA9IDA7XHJcbiAgICAgICAgZmFjZXNbMF1bMV0gPSAxO1xyXG4gICAgICAgIGZhY2VzWzBdWzJdID0gMjtcclxuXHJcbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlXHJcbiAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xyXG4gICAgICAgIGZhY2VzWzFdWzFdID0gNDtcclxuICAgICAgICBmYWNlc1sxXVsyXSA9IDM7XHJcblxyXG4gICAgICAgIC8vIC14IGZhY2luZyBxdWFkXHJcbiAgICAgICAgZmFjZXNbMl1bMF0gPSAwO1xyXG4gICAgICAgIGZhY2VzWzJdWzFdID0gMjtcclxuICAgICAgICBmYWNlc1syXVsyXSA9IDU7XHJcbiAgICAgICAgZmFjZXNbMl1bM10gPSAzO1xyXG5cclxuICAgICAgICAvLyAteSBmYWNpbmcgcXVhZFxyXG4gICAgICAgIGZhY2VzWzNdWzBdID0gMTtcclxuICAgICAgICBmYWNlc1szXVsxXSA9IDA7XHJcbiAgICAgICAgZmFjZXNbM11bMl0gPSAzO1xyXG4gICAgICAgIGZhY2VzWzNdWzNdID0gNDtcclxuXHJcbiAgICAgICAgLy8gK3h5IGZhY2luZyBxdWFkXHJcbiAgICAgICAgZmFjZXNbNF1bMF0gPSA0O1xyXG4gICAgICAgIGZhY2VzWzRdWzFdID0gNTtcclxuICAgICAgICBmYWNlc1s0XVsyXSA9IDI7XHJcbiAgICAgICAgZmFjZXNbNF1bM10gPSAxO1xyXG5cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmVcclxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICAoeGkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICh5aSArIDAuNzUpICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXHJcbiAgICAgICAgdmVydHNbMF0uc2V0KFxyXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV0gLSBoXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0c1sxXS5zZXQoXHJcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXSAtIGhcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzJdLnNldChcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWldIC0gaFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHZlcnRzWzNdLnNldChcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIC0gaC0xXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0c1s0XS5zZXQoXHJcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgLSBoLTFcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRzWzVdLnNldChcclxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAtIGgtMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZVxyXG4gICAgICAgIGZhY2VzWzBdWzBdID0gMDtcclxuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XHJcbiAgICAgICAgZmFjZXNbMF1bMl0gPSAyO1xyXG5cclxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcclxuICAgICAgICBmYWNlc1sxXVswXSA9IDU7XHJcbiAgICAgICAgZmFjZXNbMV1bMV0gPSA0O1xyXG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcclxuXHJcbiAgICAgICAgLy8gK3ggZmFjaW5nIHF1YWRcclxuICAgICAgICBmYWNlc1syXVswXSA9IDI7XHJcbiAgICAgICAgZmFjZXNbMl1bMV0gPSA1O1xyXG4gICAgICAgIGZhY2VzWzJdWzJdID0gMztcclxuICAgICAgICBmYWNlc1syXVszXSA9IDA7XHJcblxyXG4gICAgICAgIC8vICt5IGZhY2luZyBxdWFkXHJcbiAgICAgICAgZmFjZXNbM11bMF0gPSAzO1xyXG4gICAgICAgIGZhY2VzWzNdWzFdID0gNDtcclxuICAgICAgICBmYWNlc1szXVsyXSA9IDE7XHJcbiAgICAgICAgZmFjZXNbM11bM10gPSAwO1xyXG5cclxuICAgICAgICAvLyAteHkgZmFjaW5nIHF1YWRcclxuICAgICAgICBmYWNlc1s0XVswXSA9IDE7XHJcbiAgICAgICAgZmFjZXNbNF1bMV0gPSA0O1xyXG4gICAgICAgIGZhY2VzWzRdWzJdID0gNTtcclxuICAgICAgICBmYWNlc1s0XVszXSA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7XHJcbiAgICByZXN1bHQuY29tcHV0ZUVkZ2VzKCk7XHJcbiAgICByZXN1bHQudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcclxuXHJcbiAgICB0aGlzLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSwgcmVzdWx0LCBvZmZzZXRSZXN1bHQpO1xyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsIHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gVGhlIHRlcnJhaW4gaXMgaW5maW5pdGVcclxufTtcclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MsIHF1YXQsIG1pbiwgbWF4KXtcclxuICAgIC8vIFRPRE86IGRvIGl0IHByb3Blcmx5XHJcbiAgICBtaW4uc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgbWF4LnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcclxufTtcclxuXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvLyBVc2UgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgbWluL21heCB2YWx1ZXNcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxyXG4gICAgICAgIHMgPSB0aGlzLmVsZW1lbnRTaXplO1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IG5ldyBWZWMzKGRhdGEubGVuZ3RoICogcywgZGF0YVswXS5sZW5ndGggKiBzLCBNYXRoLm1heChNYXRoLmFicyh0aGlzLm1heFZhbHVlKSwgTWF0aC5hYnModGhpcy5taW5WYWx1ZSkpKS5ub3JtKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgaGVpZ2h0IHZhbHVlcyBmcm9tIGFuIGltYWdlLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3Nlci5cclxuICogQG1ldGhvZCBzZXRIZWlnaHRzRnJvbUltYWdlXHJcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXHJcbiAqIEBwYXJhbSB7VmVjM30gc2NhbGVcclxuICovXHJcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRzRnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2UsIHNjYWxlKXtcclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcblxyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuZGF0YTtcclxuICAgIG1hdHJpeC5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IE1hdGguYWJzKHNjYWxlLngpIC8gaW1hZ2VEYXRhLndpZHRoO1xyXG4gICAgZm9yKHZhciBpPTA7IGk8aW1hZ2VEYXRhLmhlaWdodDsgaSsrKXtcclxuICAgICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aW1hZ2VEYXRhLndpZHRoOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgYSA9IGltYWdlRGF0YS5kYXRhWyhpKmltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDRdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGltYWdlRGF0YS5kYXRhWyhpKmltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGMgPSBpbWFnZURhdGEuZGF0YVsoaSppbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0ICsgMl07XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAoYSArIGIgKyBjKSAvIDQgLyAyNTUgKiBzY2FsZS56O1xyXG4gICAgICAgICAgICBpZihzY2FsZS54IDwgMCl7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChoZWlnaHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm93LnVuc2hpZnQoaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihzY2FsZS55IDwgMCl7XHJcbiAgICAgICAgICAgIG1hdHJpeC51bnNoaWZ0KHJvdyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4LnB1c2gocm93KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XHJcbiAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vdXRpbHMvVXRpbHNcIjo1NSxcIi4vQ29udmV4UG9seWhlZHJvblwiOjQwLFwiLi9TaGFwZVwiOjQ1fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xyXG5cclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG5cclxuLyoqXHJcbiAqIFBhcnRpY2xlIHNoYXBlLlxyXG4gKiBAY2xhc3MgUGFydGljbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICovXHJcbmZ1bmN0aW9uIFBhcnRpY2xlKCl7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QQVJUSUNMRVxyXG4gICAgfSk7XHJcbn1cclxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XHJcblBhcnRpY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICogQHJldHVybiB7VmVjM31cclxuICovXHJcblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuUGFydGljbGUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gMDtcclxufTtcclxuXHJcblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcclxufTtcclxuXHJcblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcclxuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XHJcbiAgICBtaW4uY29weShwb3MpO1xyXG4gICAgbWF4LmNvcHkocG9zKTtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL1NoYXBlXCI6NDV9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgQm9keSBhbmQgcm90YXRlIHRoYXQgYm9keS4gU2VlIHRoZSBkZW1vcy5cclxuICogQGNsYXNzIFBsYW5lXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqL1xyXG5mdW5jdGlvbiBQbGFuZSgpe1xyXG4gICAgU2hhcGUuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuUExBTkVcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdvcmxkIG9yaWVudGVkIG5vcm1hbFxyXG4gICAgdGhpcy53b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG59XHJcblBsYW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xyXG5QbGFuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZTtcclxuXHJcblBsYW5lLnByb3RvdHlwZS5jb21wdXRlV29ybGROb3JtYWwgPSBmdW5jdGlvbihxdWF0KXtcclxuICAgIHZhciBuID0gdGhpcy53b3JsZE5vcm1hbDtcclxuICAgIG4uc2V0KDAsMCwxKTtcclxuICAgIHF1YXQudm11bHQobixuKTtcclxuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG59O1xyXG5cclxuUGxhbmUucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcblBsYW5lLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFRoZSBwbGFuZSBpcyBpbmZpbml0ZS4uLlxyXG59O1xyXG5cclxudmFyIHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpO1xyXG5QbGFuZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLCBxdWF0LCBtaW4sIG1heCl7XHJcbiAgICAvLyBUaGUgcGxhbmUgQUFCQiBpcyBpbmZpbml0ZSwgZXhjZXB0IGlmIHRoZSBub3JtYWwgaXMgcG9pbnRpbmcgYWxvbmcgYW55IGF4aXNcclxuICAgIHRlbXBOb3JtYWwuc2V0KDAsMCwxKTsgLy8gRGVmYXVsdCBwbGFuZSBub3JtYWwgaXMgelxyXG4gICAgcXVhdC52bXVsdCh0ZW1wTm9ybWFsLHRlbXBOb3JtYWwpO1xyXG4gICAgdmFyIG1heFZhbCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBtaW4uc2V0KC1tYXhWYWwsIC1tYXhWYWwsIC1tYXhWYWwpO1xyXG4gICAgbWF4LnNldChtYXhWYWwsIG1heFZhbCwgbWF4VmFsKTtcclxuXHJcbiAgICBpZih0ZW1wTm9ybWFsLnggPT09IDEpeyBtYXgueCA9IHBvcy54OyB9XHJcbiAgICBpZih0ZW1wTm9ybWFsLnkgPT09IDEpeyBtYXgueSA9IHBvcy55OyB9XHJcbiAgICBpZih0ZW1wTm9ybWFsLnogPT09IDEpeyBtYXgueiA9IHBvcy56OyB9XHJcblxyXG4gICAgaWYodGVtcE5vcm1hbC54ID09PSAtMSl7IG1pbi54ID0gcG9zLng7IH1cclxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gLTEpeyBtaW4ueSA9IHBvcy55OyB9XHJcbiAgICBpZih0ZW1wTm9ybWFsLnogPT09IC0xKXsgbWluLnogPSBwb3MuejsgfVxyXG59O1xyXG5cclxuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG59O1xyXG59LHtcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi9TaGFwZVwiOjQ1fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xyXG5cclxudmFyIEV2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi4vdXRpbHMvRXZlbnRUYXJnZXQnKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlc1xyXG4gKiBAY2xhc3MgU2hhcGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPTFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1hdGVyaWFsPW51bGxdXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXHJcbmZ1bmN0aW9uIFNoYXBlKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XHJcbiAgICAvKipcclxuICAgICAqIElkZW50aWZ5ZXIgb2YgdGhlIFNoYXBlLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWQgPSBTaGFwZS5pZENvdW50ZXIrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgc2hhcGUuIE11c3QgYmUgc2V0IHRvIGFuIGludCA+IDAgYnkgc3ViY2xhc3Nlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHNlZSBTaGFwZS50eXBlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdTcGhlcmVSYWRpdXNcclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvbkZpbHRlck1hc2tcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TWF0ZXJpYWx9IG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsID8gb3B0aW9ucy5tYXRlcmlhbCA6IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcclxufVxyXG5TaGFwZS5wcm90b3R5cGUgPSBuZXcgRXZlbnRUYXJnZXQoKTtcclxuU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGU7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoZSBwcm9wZXJ0eSAuYm91bmRpbmdTcGhlcmVSYWRpdXNcclxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gKi9cclxuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRocm93IFwiY29tcHV0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlXHJcbiAqIEBtZXRob2Qgdm9sdW1lXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcblNoYXBlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgXCJ2b2x1bWUoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIrdGhpcy50eXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGluZXJ0aWEgaW4gdGhlIGxvY2FsIGZyYW1lIGZvciB0aGlzIHNoYXBlLlxyXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzc1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICovXHJcblNoYXBlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICB0aHJvdyBcImNhbGN1bGF0ZUxvY2FsSW5lcnRpYSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XHJcbn07XHJcblxyXG5TaGFwZS5pZENvdW50ZXIgPSAwO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IHR5cGVzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5TaGFwZS50eXBlcyA9IHtcclxuICAgIFNQSEVSRToxLFxyXG4gICAgUExBTkU6MixcclxuICAgIEJPWDo0LFxyXG4gICAgQ09NUE9VTkQ6OCxcclxuICAgIENPTlZFWFBPTFlIRURST046MTYsXHJcbiAgICBIRUlHSFRGSUVMRDozMixcclxuICAgIFBBUlRJQ0xFOjY0LFxyXG4gICAgQ1lMSU5ERVI6MTI4LFxyXG4gICAgVFJJTUVTSDoyNTZcclxufTtcclxuXHJcblxyXG59LHtcIi4uL21hdGVyaWFsL01hdGVyaWFsXCI6MjYsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vdXRpbHMvRXZlbnRUYXJnZXRcIjo1MSxcIi4vU2hhcGVcIjo0NX1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBTcGhlcmU7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcblxyXG4vKipcclxuICogU3BoZXJpY2FsIHNoYXBlXHJcbiAqIEBjbGFzcyBTcGhlcmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFNoYXBlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cclxuZnVuY3Rpb24gU3BoZXJlKHJhZGl1cyl7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5TUEhFUkVcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhZGl1c1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMS4wO1xyXG5cclxuICAgIGlmKHRoaXMucmFkaXVzIDwgMCl7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3BoZXJlIHJhZGl1cyBjYW5ub3QgYmUgbmVnYXRpdmUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG59XHJcblNwaGVyZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcclxuU3BoZXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZTtcclxuXHJcblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgSSA9IDIuMCptYXNzKnRoaXMucmFkaXVzKnRoaXMucmFkaXVzLzUuMDtcclxuICAgIHRhcmdldC54ID0gSTtcclxuICAgIHRhcmdldC55ID0gSTtcclxuICAgIHRhcmdldC56ID0gSTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5TcGhlcmUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMucmFkaXVzIC8gMy4wO1xyXG59O1xyXG5cclxuU3BoZXJlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbn07XHJcblxyXG5TcGhlcmUucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xyXG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcclxuICAgIHZhciBheGVzID0gWyd4JywneScsJ3onXTtcclxuICAgIGZvcih2YXIgaT0wOyBpPGF4ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBheCA9IGF4ZXNbaV07XHJcbiAgICAgICAgbWluW2F4XSA9IHBvc1theF0gLSByO1xyXG4gICAgICAgIG1heFtheF0gPSBwb3NbYXhdICsgcjtcclxuICAgIH1cclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL1NoYXBlXCI6NDV9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gVHJpbWVzaDtcclxuXHJcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcclxudmFyIE9jdHJlZSA9IF9kZXJlcV8oJy4uL3V0aWxzL09jdHJlZScpO1xyXG52YXIgQ01hdGggPSBfZGVyZXFfKCcuLi9tYXRoL0NNYXRoJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFRyaW1lc2hcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHZlcnRpY2VzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGluZGljZXNcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICogQGV4YW1wbGVcclxuICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlXHJcbiAqICAgICB2YXIgdmVydGljZXMgPSBbXHJcbiAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDBcclxuICogICAgICAgICAxLCAwLCAwLCAvLyB2ZXJ0ZXggMVxyXG4gKiAgICAgICAgIDAsIDEsIDAgIC8vIHZlcnRleCAyXHJcbiAqICAgICBdO1xyXG4gKiAgICAgdmFyIGluZGljZXMgPSBbXHJcbiAqICAgICAgICAgMCwgMSwgMiAgLy8gdHJpYW5nbGUgMFxyXG4gKiAgICAgXTtcclxuICogICAgIHZhciB0cmltZXNoU2hhcGUgPSBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XHJcbiAqL1xyXG5mdW5jdGlvbiBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKSB7XHJcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5UUklNRVNIXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VycywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIHRyaWFuZ2xlIGNvbnNpc3RzIG9mLiBUaGUgbGVuZ3RoIG9mIHRoaXMgYXJyYXkgaXMgdGh1cyAzIHRpbWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLlxyXG4gICAgICogQHByb3BlcnR5IGluZGljZXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IEludDE2QXJyYXkoaW5kaWNlcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFscyBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IG5vcm1hbHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cclxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guXHJcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBlZGdlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmVkZ2VzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuXHJcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LlxyXG4gICAgICogQHByb3BlcnR5IHtPY3RyZWV9IHRyZWVcclxuICAgICAqL1xyXG4gICAgdGhpcy50cmVlID0gbmV3IE9jdHJlZSgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgdGhpcy51cGRhdGVBQUJCKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZVRyZWUoKTtcclxufVxyXG5UcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xyXG5UcmltZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyaW1lc2g7XHJcblxyXG52YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB1cGRhdGVUcmVlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVUcmVlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xyXG5cclxuICAgIHRyZWUucmVzZXQoKTtcclxuICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7XHJcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlOyAvLyBUaGUgbG9jYWwgbWVzaCBBQUJCIGlzIHNjYWxlZCwgYnV0IHRoZSBvY3RyZWUgQUFCQiBzaG91bGQgYmUgdW5zY2FsZWRcclxuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnggKj0gMSAvIHNjYWxlLng7XHJcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xyXG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcclxuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnggKj0gMSAvIHNjYWxlLng7XHJcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xyXG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcclxuXHJcbiAgICAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlc1xyXG4gICAgdmFyIHRyaWFuZ2xlQUFCQiA9IG5ldyBBQUJCKCk7XHJcbiAgICB2YXIgYSA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgYiA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgYyA9IG5ldyBWZWMzKCk7XHJcbiAgICB2YXIgcG9pbnRzID0gW2EsIGIsIGNdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XHJcbiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7XHJcblxyXG4gICAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xyXG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpM10sIGEpO1xyXG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcclxuICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XHJcblxyXG4gICAgICAgIHRyaWFuZ2xlQUFCQi5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICAgICAgdHJlZS5pbnNlcnQodHJpYW5nbGVBQUJCLCBpKTtcclxuICAgIH1cclxuICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpO1xyXG59O1xyXG5cclxudmFyIHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cclxuICogQG1ldGhvZCBnZXRUcmlhbmdsZXNJbkFBQkJcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRUcmlhbmdsZXNJbkFBQkIgPSBmdW5jdGlvbihhYWJiLCByZXN1bHQpe1xyXG4gICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7XHJcblxyXG4gICAgLy8gU2NhbGUgaXQgdG8gbG9jYWxcclxuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICB2YXIgaXN4ID0gc2NhbGUueDtcclxuICAgIHZhciBpc3kgPSBzY2FsZS55O1xyXG4gICAgdmFyIGlzeiA9IHNjYWxlLno7XHJcbiAgICB2YXIgbCA9IHVuc2NhbGVkQUFCQi5sb3dlckJvdW5kO1xyXG4gICAgdmFyIHUgPSB1bnNjYWxlZEFBQkIudXBwZXJCb3VuZDtcclxuICAgIGwueCAvPSBpc3g7XHJcbiAgICBsLnkgLz0gaXN5O1xyXG4gICAgbC56IC89IGlzejtcclxuICAgIHUueCAvPSBpc3g7XHJcbiAgICB1LnkgLz0gaXN5O1xyXG4gICAgdS56IC89IGlzejtcclxuXHJcbiAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTY2FsZVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKXtcclxuICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcclxuICAgIHZhciBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ID09PSBzY2FsZS56O1xyXG5cclxuICAgIGlmKCEod2FzVW5pZm9ybSAmJiBpc1VuaWZvcm0pKXtcclxuICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLlxyXG4gICAgICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zY2FsZS5jb3B5KHNjYWxlKTtcclxuICAgIHRoaXMudXBkYXRlQUFCQigpO1xyXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIG5vcm1hbHMgb2YgdGhlIGZhY2VzLiBXaWxsIHNhdmUgaW4gdGhlIC5ub3JtYWxzIGFycmF5LlxyXG4gKiBAbWV0aG9kIHVwZGF0ZU5vcm1hbHNcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIG4gPSBjb21wdXRlTm9ybWFsc19uO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIG5vcm1hbHNcclxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xyXG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcclxuICAgICAgICB2YXIgaTMgPSBpICogMztcclxuXHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxyXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXHJcbiAgICAgICAgICAgIGMgPSB0aGlzLmluZGljZXNbaTMgKyAyXTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYSwgdmEpO1xyXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGIsIHZiKTtcclxuICAgICAgICB0aGlzLmdldFZlcnRleChjLCB2Yyk7XHJcblxyXG4gICAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTtcclxuXHJcbiAgICAgICAgbm9ybWFsc1tpM10gPSBuLng7XHJcbiAgICAgICAgbm9ybWFsc1tpMyArIDFdID0gbi55O1xyXG4gICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IG4uejtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIC5lZGdlcyBwcm9wZXJ0eVxyXG4gKiBAbWV0aG9kIHVwZGF0ZUVkZ2VzXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVFZGdlcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZWRnZXMgPSB7fTtcclxuICAgIHZhciBhZGQgPSBmdW5jdGlvbihpbmRleEEsIGluZGV4Qil7XHJcbiAgICAgICAgdmFyIGtleSA9IGEgPCBiID8gYSArICdfJyArIGIgOiBiICsgJ18nICsgYTtcclxuICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspe1xyXG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5pbmRpY2VzW2kzXSxcclxuICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxyXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XHJcbiAgICAgICAgYWRkKGEsYik7XHJcbiAgICAgICAgYWRkKGIsYyk7XHJcbiAgICAgICAgYWRkKGMsYSk7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVkZ2VzKTtcclxuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7XHJcbiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XHJcbiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBlZGdlIHZlcnRleFxyXG4gKiBAbWV0aG9kIGdldEVkZ2VWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBmaXJzdE9yU2Vjb25kIDAgb3IgMSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBvZiB0aGUgdmVydGljZXMgeW91IG5lZWQuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHZlcnRleFN0b3JlIFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZXJ0ZXggPSBmdW5jdGlvbihlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKXtcclxuICAgIHZhciB2ZXJ0ZXhJbmRleCA9IHRoaXMuZWRnZXNbZWRnZUluZGV4ICogMiArIChmaXJzdE9yU2Vjb25kID8gMSA6IDApXTtcclxuICAgIHRoaXMuZ2V0VmVydGV4KHZlcnRleEluZGV4LCB2ZXJ0ZXhTdG9yZSk7XHJcbn07XHJcblxyXG52YXIgZ2V0RWRnZVZlY3Rvcl92YSA9IG5ldyBWZWMzKCk7XHJcbnZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cclxuICogQG1ldGhvZCBnZXRFZGdlVmVjdG9yXHJcbiAqIEBwYXJhbSAge251bWJlcn0gZWRnZUluZGV4XHJcbiAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRFZGdlVmVjdG9yID0gZnVuY3Rpb24oZWRnZUluZGV4LCB2ZWN0b3JTdG9yZSl7XHJcbiAgICB2YXIgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhO1xyXG4gICAgdmFyIHZiID0gZ2V0RWRnZVZlY3Rvcl92YjtcclxuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDAsIHZhKTtcclxuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcclxuICAgIHZiLnZzdWIodmEsIHZlY3RvclN0b3JlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXHJcbiAqIEBwYXJhbSB7VmVjM30gdmJcclxuICogQHBhcmFtIHtWZWMzfSB2Y1xyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxyXG4gKi9cclxudmFyIGNiID0gbmV3IFZlYzMoKTtcclxudmFyIGFiID0gbmV3IFZlYzMoKTtcclxuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKCB2YSwgdmIsIHZjLCB0YXJnZXQgKSB7XHJcbiAgICB2Yi52c3ViKHZhLGFiKTtcclxuICAgIHZjLnZzdWIodmIsY2IpO1xyXG4gICAgY2IuY3Jvc3MoYWIsdGFyZ2V0KTtcclxuICAgIGlmICggIXRhcmdldC5pc1plcm8oKSApIHtcclxuICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdmEgPSBuZXcgVmVjMygpO1xyXG52YXIgdmIgPSBuZXcgVmVjMygpO1xyXG52YXIgdmMgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJ0ZXggaS5cclxuICogQG1ldGhvZCBnZXRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbihpLCBvdXQpe1xyXG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7XHJcbiAgICBvdXQueCAqPSBzY2FsZS54O1xyXG4gICAgb3V0LnkgKj0gc2NhbGUueTtcclxuICAgIG91dC56ICo9IHNjYWxlLno7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCByYXcgdmVydGV4IGlcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBfZ2V0VW5zY2FsZWRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5fZ2V0VW5zY2FsZWRWZXJ0ZXggPSBmdW5jdGlvbihpLCBvdXQpe1xyXG4gICAgdmFyIGkzID0gaSAqIDM7XHJcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgcmV0dXJuIG91dC5zZXQoXHJcbiAgICAgICAgdmVydGljZXNbaTNdLFxyXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMV0sXHJcbiAgICAgICAgdmVydGljZXNbaTMgKyAyXVxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXHJcbiAqIEBtZXRob2QgZ2V0V29ybGRWZXJ0ZXhcclxuICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc1xyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5nZXRXb3JsZFZlcnRleCA9IGZ1bmN0aW9uKGksIHBvcywgcXVhdCwgb3V0KXtcclxuICAgIHRoaXMuZ2V0VmVydGV4KGksIG91dCk7XHJcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuXHJcbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVWZXJ0aWNlc1xyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcclxuICogQHBhcmFtICB7VmVjM30gYVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBiXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGNcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlVmVydGljZXMgPSBmdW5jdGlvbihpLCBhLCBiLCBjKXtcclxuICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XHJcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7XHJcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXHJcbiAqIEBtZXRob2QgZ2V0Tm9ybWFsXHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICogQHJldHVybiB7VmVjM30gVGhlIFwidGFyZ2V0XCIgdmVjdG9yIG9iamVjdFxyXG4gKi9cclxuVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24oaSwgdGFyZ2V0KXtcclxuICAgIHZhciBpMyA9IGkgKiAzO1xyXG4gICAgcmV0dXJuIHRhcmdldC5zZXQoXHJcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzXSxcclxuICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAxXSxcclxuICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAyXVxyXG4gICAgKTtcclxufTtcclxuXHJcbnZhciBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcclxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxyXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XHJcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXHJcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcclxuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihjbGlfYWFiYik7XHJcbiAgICB2YXIgeCA9IGNsaV9hYWJiLnVwcGVyQm91bmQueCAtIGNsaV9hYWJiLmxvd2VyQm91bmQueCxcclxuICAgICAgICB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55LFxyXG4gICAgICAgIHogPSBjbGlfYWFiYi51cHBlckJvdW5kLnogLSBjbGlfYWFiYi5sb3dlckJvdW5kLno7XHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeioyKnogKSxcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKSxcclxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKVxyXG4gICAgKTtcclxufTtcclxuXHJcbnZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2hcclxuICogQG1ldGhvZCBjb21wdXRlTG9jYWxBQUJCXHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmNvbXB1dGVMb2NhbEFBQkIgPSBmdW5jdGlvbihhYWJiKXtcclxuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLFxyXG4gICAgICAgIHUgPSBhYWJiLnVwcGVyQm91bmQsXHJcbiAgICAgICAgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcclxuICAgICAgICB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XHJcblxyXG4gICAgdGhpcy5nZXRWZXJ0ZXgoMCwgdik7XHJcbiAgICBsLmNvcHkodik7XHJcbiAgICB1LmNvcHkodik7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IG47IGkrKyl7XHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XHJcblxyXG4gICAgICAgIGlmKHYueCA8IGwueCl7XHJcbiAgICAgICAgICAgIGwueCA9IHYueDtcclxuICAgICAgICB9IGVsc2UgaWYodi54ID4gdS54KXtcclxuICAgICAgICAgICAgdS54ID0gdi54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodi55IDwgbC55KXtcclxuICAgICAgICAgICAgbC55ID0gdi55O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiB1Lnkpe1xyXG4gICAgICAgICAgICB1LnkgPSB2Lnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih2LnogPCBsLnope1xyXG4gICAgICAgICAgICBsLnogPSB2Lno7XHJcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IHUueil7XHJcbiAgICAgICAgICAgIHUueiA9IHYuejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgLmFhYmIgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVBQUJCXHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgdXBkYXRlIHRoZSAuYm91bmRpbmdTcGhlcmVSYWRpdXMgcHJvcGVydHlcclxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xyXG4gKi9cclxuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxyXG4gICAgdmFyIG1heDIgPSAwO1xyXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciB2ID0gbmV3IFZlYzMoKTtcclxuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xyXG4gICAgICAgIHZhciBub3JtMiA9IHYubm9ybTIoKTtcclxuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xyXG4gICAgICAgICAgICBtYXgyID0gbm9ybTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTtcclxufTtcclxuXHJcbnZhciB0ZW1wV29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xyXG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lID0gbmV3IFRyYW5zZm9ybSgpO1xyXG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2FhYmIgPSBuZXcgQUFCQigpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXHJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIHBvc1xyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XHJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtYXhcclxuICovXHJcblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xyXG4gICAgLypcclxuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzLFxyXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejtcclxuXHJcbiAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcclxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XHJcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XHJcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcclxuICAgICAgICBwb3MudmFkZCh2LCB2KTtcclxuICAgICAgICBpZiAodi54IDwgbWlueCB8fCBtaW54PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWlueCA9IHYueDtcclxuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWF4eCA9IHYueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2LnkgPCBtaW55IHx8IG1pbnk9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtaW55ID0gdi55O1xyXG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiBtYXh5IHx8IG1heHk9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtYXh5ID0gdi55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XHJcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1heHogPSB2Lno7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XHJcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcclxuICAgICovXHJcblxyXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxyXG4gICAgdmFyIGZyYW1lID0gY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiO1xyXG4gICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XHJcbiAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDtcclxuICAgIHRoaXMuYWFiYi50b1dvcmxkRnJhbWUoZnJhbWUsIHJlc3VsdCk7XHJcbiAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XHJcbiAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFwcHJveGltYXRlIHZvbHVtZVxyXG4gKiBAbWV0aG9kIHZvbHVtZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5UcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIFRyaW1lc2ggaW5zdGFuY2UsIHNoYXBlZCBhcyBhIHRvcnVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY3JlYXRlVG9ydXNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaXVzPTFdXHJcbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz04XVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt0dWJ1bGFyU2VnbWVudHM9Nl1cclxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxyXG4gKiBAcmV0dXJuIHtUcmltZXNofSBBIHRvcnVzXHJcbiAqL1xyXG5UcmltZXNoLmNyZWF0ZVRvcnVzID0gZnVuY3Rpb24gKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7XHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuICAgIHR1YmUgPSB0dWJlIHx8IDAuNTtcclxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG4gICAgYXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgdmFyIGluZGljZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSAoIHJhZGl1cyArIHR1YmUgKiBDTWF0aC5jb3MoIHYgKSApICogQ01hdGguY29zKCB1ICk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKCByYWRpdXMgKyB0dWJlICogQ01hdGguY29zKCB2ICkgKSAqIENNYXRoLnNpbiggdSApO1xyXG4gICAgICAgICAgICB2YXIgeiA9IHR1YmUgKiBDTWF0aC5zaW4oIHYgKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goIHgsIHksIHogKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XHJcbiAgICAgICAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcclxuICAgICAgICAgICAgdmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XHJcbiAgICAgICAgICAgIHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcclxuXHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRyaW1lc2godmVydGljZXMsIGluZGljZXMpO1xyXG59O1xyXG5cclxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRoL0NNYXRoXCI6MjcsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MzEsXCIuLi9tYXRoL1ZlYzNcIjozMixcIi4uL3V0aWxzL09jdHJlZVwiOjUyLFwiLi9TaGFwZVwiOjQ1fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xyXG5cclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIFNvbHZlciA9IF9kZXJlcV8oJy4vU29sdmVyJyk7XHJcblxyXG4vKipcclxuICogQ29uc3RyYWludCBlcXVhdGlvbiBHYXVzcy1TZWlkZWwgc29sdmVyLlxyXG4gKiBAY2xhc3MgR1NTb2x2ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEB0b2RvIFRoZSBzcG9vayBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggY29uc3RyYWludCwgbm90IGdsb2JhbGx5LlxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcclxuICogQGV4dGVuZHMgU29sdmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBHU1NvbHZlcigpe1xyXG4gICAgU29sdmVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIGRldGVybWluZXMgcXVhbGl0eSBvZiB0aGUgY29uc3RyYWludHMgaW4gdGhlIHdvcmxkLiBUaGUgbW9yZSBpdGVyYXRpb25zLCB0aGUgbW9yZSBjb3JyZWN0IHNpbXVsYXRpb24uIE1vcmUgaXRlcmF0aW9ucyBuZWVkIG1vcmUgY29tcHV0YXRpb25zIHRob3VnaC4gSWYgeW91IGhhdmUgYSBsYXJnZSBncmF2aXR5IGZvcmNlIGluIHlvdXIgd29ybGQsIHlvdSB3aWxsIG5lZWQgbW9yZSBpdGVyYXRpb25zLlxyXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAdG9kbyB3cml0ZSBtb3JlIGFib3V0IHNvbHZlciBhbmQgaXRlcmF0aW9ucyBpbiB0aGUgd2lraVxyXG4gICAgICovXHJcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdG9sZXJhbmNlIGlzIHJlYWNoZWQsIHRoZSBzeXN0ZW0gaXMgYXNzdW1lZCB0byBiZSBjb252ZXJnZWQuXHJcbiAgICAgKiBAcHJvcGVydHkgdG9sZXJhbmNlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XHJcbn1cclxuR1NTb2x2ZXIucHJvdG90eXBlID0gbmV3IFNvbHZlcigpO1xyXG5cclxudmFyIEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOyAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBzb2x2ZS5cclxudmFyIEdTU29sdmVyX3NvbHZlX2ludkNzID0gW107XHJcbnZhciBHU1NvbHZlcl9zb2x2ZV9CcyA9IFtdO1xyXG5HU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XHJcbiAgICB2YXIgaXRlciA9IDAsXHJcbiAgICAgICAgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9ucyxcclxuICAgICAgICB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2UsXHJcbiAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsXHJcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcclxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXHJcbiAgICAgICAgTmJvZGllcyA9IGJvZGllcy5sZW5ndGgsXHJcbiAgICAgICAgaCA9IGR0LFxyXG4gICAgICAgIHEsIEIsIGludkMsIGRlbHRhbGFtYmRhLCBkZWx0YWxhbWJkYVRvdCwgR1dsYW1iZGEsIGxhbWJkYWo7XHJcblxyXG4gICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcclxuICAgIGlmKE5lcSAhPT0gMCl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xyXG4gICAgICAgICAgICBib2RpZXNbaV0udXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxyXG4gICAgdmFyIGludkNzID0gR1NTb2x2ZXJfc29sdmVfaW52Q3MsXHJcbiAgICAgICAgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CcyxcclxuICAgICAgICBsYW1iZGEgPSBHU1NvbHZlcl9zb2x2ZV9sYW1iZGE7XHJcbiAgICBpbnZDcy5sZW5ndGggPSBOZXE7XHJcbiAgICBCcy5sZW5ndGggPSBOZXE7XHJcbiAgICBsYW1iZGEubGVuZ3RoID0gTmVxO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXE7IGkrKyl7XHJcbiAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XHJcbiAgICAgICAgbGFtYmRhW2ldID0gMC4wO1xyXG4gICAgICAgIEJzW2ldID0gYy5jb21wdXRlQihoKTtcclxuICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihOZXEgIT09IDApe1xyXG5cclxuICAgICAgICAvLyBSZXNldCB2bGFtYmRhXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgYj1ib2RpZXNbaV0sXHJcbiAgICAgICAgICAgICAgICB2bGFtYmRhPWIudmxhbWJkYSxcclxuICAgICAgICAgICAgICAgIHdsYW1iZGE9Yi53bGFtYmRhO1xyXG4gICAgICAgICAgICB2bGFtYmRhLnNldCgwLDAsMCk7XHJcbiAgICAgICAgICAgIHdsYW1iZGEuc2V0KDAsMCwwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlcXVhdGlvbnNcclxuICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4SXRlcjsgaXRlcisrKXtcclxuXHJcbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgaiE9PU5lcTsgaisrKXtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgQiA9IEJzW2pdO1xyXG4gICAgICAgICAgICAgICAgaW52QyA9IGludkNzW2pdO1xyXG4gICAgICAgICAgICAgICAgbGFtYmRhaiA9IGxhbWJkYVtqXTtcclxuICAgICAgICAgICAgICAgIEdXbGFtYmRhID0gYy5jb21wdXRlR1dsYW1iZGEoKTtcclxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gaW52QyAqICggQiAtIEdXbGFtYmRhIC0gYy5lcHMgKiBsYW1iZGFqICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIGlmKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA8IGMubWluRm9yY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5taW5Gb3JjZSAtIGxhbWJkYWo7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYobGFtYmRhaiArIGRlbHRhbGFtYmRhID4gYy5tYXhGb3JjZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1heEZvcmNlIC0gbGFtYmRhajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBkZWx0YWxhbWJkYSA+IDAuMCA/IGRlbHRhbGFtYmRhIDogLWRlbHRhbGFtYmRhOyAvLyBhYnMoZGVsdGFsYW1iZGEpXHJcblxyXG4gICAgICAgICAgICAgICAgYy5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXHJcbiAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDwgdG9sU3F1YXJlZCl7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIHJlc3VsdCB0byB2ZWxvY2l0eVxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgdj1iLnZlbG9jaXR5LFxyXG4gICAgICAgICAgICAgICAgdz1iLmFuZ3VsYXJWZWxvY2l0eTtcclxuXHJcbiAgICAgICAgICAgIGIudmxhbWJkYS52bXVsKGIubGluZWFyRmFjdG9yLCBiLnZsYW1iZGEpO1xyXG4gICAgICAgICAgICB2LnZhZGQoYi52bGFtYmRhLCB2KTtcclxuXHJcbiAgICAgICAgICAgIGIud2xhbWJkYS52bXVsKGIuYW5ndWxhckZhY3RvciwgYi53bGFtYmRhKTtcclxuICAgICAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIC5tdWx0aXBsaWVyIHByb3BlcnR5IG9mIGVhY2ggZXF1YXRpb25cclxuICAgICAgICB2YXIgbCA9IGVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGludkR0ID0gMSAvIGg7XHJcbiAgICAgICAgd2hpbGUobC0tKXtcclxuICAgICAgICAgICAgZXF1YXRpb25zW2xdLm11bHRpcGxpZXIgPSBsYW1iZGFbbF0gKiBpbnZEdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZXI7XHJcbn07XHJcblxyXG59LHtcIi4uL21hdGgvUXVhdGVybmlvblwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL1NvbHZlclwiOjQ5fV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNvbHZlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJhaW50IGVxdWF0aW9uIHNvbHZlciBiYXNlIGNsYXNzLlxyXG4gKiBAY2xhc3MgU29sdmVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXHJcbiAqL1xyXG5mdW5jdGlvbiBTb2x2ZXIoKXtcclxuICAgIC8qKlxyXG4gICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVxdWF0aW9uc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXMhXHJcbiAqIEBtZXRob2Qgc29sdmVcclxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxyXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICovXHJcblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XHJcbiAgICAvLyBTaG91bGQgcmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBkb25lIVxyXG4gICAgcmV0dXJuIDA7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGFuIGVxdWF0aW9uXHJcbiAqIEBtZXRob2QgYWRkRXF1YXRpb25cclxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcclxuICovXHJcblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XHJcbiAgICBpZiAoZXEuZW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBlcXVhdGlvblxyXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXHJcbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAqL1xyXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xyXG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xyXG4gICAgdmFyIGkgPSBlcXMuaW5kZXhPZihlcSk7XHJcbiAgICBpZihpICE9PSAtMSl7XHJcbiAgICAgICAgZXFzLnNwbGljZShpLDEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbGwgZXF1YXRpb25zXHJcbiAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXHJcbiAqL1xyXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuXHJcbn0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBTcGxpdFNvbHZlcjtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuL1NvbHZlcicpO1xyXG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xyXG5cclxuLyoqXHJcbiAqIFNwbGl0cyB0aGUgZXF1YXRpb25zIGludG8gaXNsYW5kcyBhbmQgc29sdmVzIHRoZW0gaW5kZXBlbmRlbnRseS4gQ2FuIGltcHJvdmUgcGVyZm9ybWFuY2UuXHJcbiAqIEBjbGFzcyBTcGxpdFNvbHZlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgU29sdmVyXHJcbiAqIEBwYXJhbSB7U29sdmVyfSBzdWJzb2x2ZXJcclxuICovXHJcbmZ1bmN0aW9uIFNwbGl0U29sdmVyKHN1YnNvbHZlcil7XHJcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMuaXRlcmF0aW9ucyA9IDEwO1xyXG4gICAgdGhpcy50b2xlcmFuY2UgPSAxZS03O1xyXG4gICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7XHJcbiAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB0aGlzLm5vZGVQb29sID0gW107XHJcblxyXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcclxuICAgIHdoaWxlKHRoaXMubm9kZVBvb2wubGVuZ3RoIDwgMTI4KXtcclxuICAgICAgICB0aGlzLm5vZGVQb29sLnB1c2godGhpcy5jcmVhdGVOb2RlKCkpO1xyXG4gICAgfVxyXG59XHJcblNwbGl0U29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcclxuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zXHJcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xyXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfbm9kZVBvb2wgPSBbXTsgLy8gQWxsIGFsbG9jYXRlZCBub2RlIG9iamVjdHNcclxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcclxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2JkcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcclxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQgPSB7Ym9kaWVzOltdfTsgLy8gVGVtcCBvYmplY3RcclxuXHJcbnZhciBTVEFUSUMgPSBCb2R5LlNUQVRJQztcclxuZnVuY3Rpb24gZ2V0VW52aXNpdGVkTm9kZShub2Rlcyl7XHJcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1Obm9kZXM7IGkrKyl7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmICEobm9kZS5ib2R5LnR5cGUgJiBTVEFUSUMpKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG52YXIgcXVldWUgPSBbXTtcclxuZnVuY3Rpb24gYmZzKHJvb3QsdmlzaXRGdW5jLGJkcyxlcXMpe1xyXG4gICAgcXVldWUucHVzaChyb290KTtcclxuICAgIHJvb3QudmlzaXRlZCA9IHRydWU7XHJcbiAgICB2aXNpdEZ1bmMocm9vdCxiZHMsZXFzKTtcclxuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XHJcbiAgICAgICAgLy8gTG9vcCBvdmVyIHVudmlzaXRlZCBjaGlsZCBub2Rlc1xyXG4gICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICB3aGlsZSgoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGUuY2hpbGRyZW4pKSkge1xyXG4gICAgICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmlzaXRGdW5jKGNoaWxkLGJkcyxlcXMpO1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZpc2l0RnVuYyhub2RlLGJkcyxlcXMpe1xyXG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcclxuICAgIHZhciBOZXFzID0gbm9kZS5lcXMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xyXG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXFzW2ldO1xyXG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGVxKSA9PT0gLTEpe1xyXG4gICAgICAgICAgICBlcXMucHVzaChlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5TcGxpdFNvbHZlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4geyBib2R5Om51bGwsIGNoaWxkcmVuOltdLCBlcXM6W10sIHZpc2l0ZWQ6ZmFsc2UgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb2x2ZSB0aGUgc3Vic3lzdGVtc1xyXG4gKiBAbWV0aG9kIHNvbHZlXHJcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcclxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAqL1xyXG5TcGxpdFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XHJcbiAgICB2YXIgbm9kZXM9U3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMsXHJcbiAgICAgICAgbm9kZVBvb2w9dGhpcy5ub2RlUG9vbCxcclxuICAgICAgICBib2RpZXM9d29ybGQuYm9kaWVzLFxyXG4gICAgICAgIGVxdWF0aW9ucz10aGlzLmVxdWF0aW9ucyxcclxuICAgICAgICBOZXE9ZXF1YXRpb25zLmxlbmd0aCxcclxuICAgICAgICBOYm9kaWVzPWJvZGllcy5sZW5ndGgsXHJcbiAgICAgICAgc3Vic29sdmVyPXRoaXMuc3Vic29sdmVyO1xyXG5cclxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXHJcbiAgICB3aGlsZShub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKXtcclxuICAgICAgICBub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcclxuICAgIH1cclxuICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgIG5vZGVzW2ldID0gbm9kZVBvb2xbaV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgbm9kZSB2YWx1ZXNcclxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcclxuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDtcclxuICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaz0wOyBrIT09TmVxOyBrKyspe1xyXG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXHJcbiAgICAgICAgICAgIGk9Ym9kaWVzLmluZGV4T2YoZXEuYmkpLFxyXG4gICAgICAgICAgICBqPWJvZGllcy5pbmRleE9mKGVxLmJqKSxcclxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXHJcbiAgICAgICAgICAgIG5qPW5vZGVzW2pdO1xyXG4gICAgICAgIG5pLmNoaWxkcmVuLnB1c2gobmopO1xyXG4gICAgICAgIG5pLmVxcy5wdXNoKGVxKTtcclxuICAgICAgICBuai5jaGlsZHJlbi5wdXNoKG5pKTtcclxuICAgICAgICBuai5lcXMucHVzaChlcSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoaWxkLCBuPTAsIGVxcz1TcGxpdFNvbHZlcl9zb2x2ZV9lcXM7XHJcblxyXG4gICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlO1xyXG4gICAgc3Vic29sdmVyLml0ZXJhdGlvbnMgPSB0aGlzLml0ZXJhdGlvbnM7XHJcblxyXG4gICAgdmFyIGR1bW15V29ybGQgPSBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkO1xyXG4gICAgd2hpbGUoKGNoaWxkID0gZ2V0VW52aXNpdGVkTm9kZShub2RlcykpKXtcclxuICAgICAgICBlcXMubGVuZ3RoID0gMDtcclxuICAgICAgICBkdW1teVdvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGJmcyhjaGlsZCwgdmlzaXRGdW5jLCBkdW1teVdvcmxkLmJvZGllcywgZXFzKTtcclxuXHJcbiAgICAgICAgdmFyIE5lcXMgPSBlcXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBlcXMgPSBlcXMuc29ydChzb3J0QnlJZCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmVxczsgaSsrKXtcclxuICAgICAgICAgICAgc3Vic29sdmVyLmFkZEVxdWF0aW9uKGVxc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaXRlciA9IHN1YnNvbHZlci5zb2x2ZShkdCxkdW1teVdvcmxkKTtcclxuICAgICAgICBzdWJzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XHJcbiAgICAgICAgbisrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc29ydEJ5SWQoYSwgYil7XHJcbiAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XHJcbn1cclxufSx7XCIuLi9tYXRoL1F1YXRlcm5pb25cIjozMCxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzMsXCIuL1NvbHZlclwiOjQ5fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLlxyXG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBFdmVudFRhcmdldCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHRoaXMuX2xpc3RlbmVycyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxyXG4gICAgICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhbnkgZXZlbnQgbGlzdGVuZXIgb2YgdGhlIGdpdmVuIHR5cGUgaXMgYWRkZWRcclxuICAgICAqIEBtZXRob2QgaGFzQW55RXZlbnRMaXN0ZW5lclxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBoYXNBbnlFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIHJldHVybiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gdGhpczsgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCApeyByZXR1cm4gdGhpczsgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtaXQgYW4gZXZlbnQuXHJcbiAgICAgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQudHlwZVxyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcclxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiB0aGlzOyB9XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xyXG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbn0se31dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xyXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPY3RyZWU7XHJcblxyXG4vKipcclxuICogQGNsYXNzIE9jdHJlZU5vZGVcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge09jdHJlZX0gW29wdGlvbnMucm9vdF1cclxuICogQHBhcmFtIHtBQUJCfSBbb3B0aW9ucy5hYWJiXVxyXG4gKi9cclxuZnVuY3Rpb24gT2N0cmVlTm9kZShvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvb3Qgbm9kZVxyXG4gICAgICogQHByb3BlcnR5IHtPY3RyZWVOb2RlfSByb290XHJcbiAgICAgKi9cclxuICAgIHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQm91bmRhcnkgb2YgdGhpcyBub2RlXHJcbiAgICAgKiBAcHJvcGVydHkge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgdGhpcy5hYWJiID0gb3B0aW9ucy5hYWJiID8gb3B0aW9ucy5hYWJiLmNsb25lKCkgOiBuZXcgQUFCQigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbmVkIGRhdGEgYXQgdGhlIGN1cnJlbnQgbm9kZSBsZXZlbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGRhdGFcclxuICAgICAqL1xyXG4gICAgdGhpcy5kYXRhID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGlsZHJlbiB0byB0aGlzIG5vZGVcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBPY3RyZWVcclxuICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heERlcHRoPThdXHJcbiAqIEBleHRlbmRzIE9jdHJlZU5vZGVcclxuICovXHJcbmZ1bmN0aW9uIE9jdHJlZShhYWJiLCBvcHRpb25zKXtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy5yb290ID0gbnVsbDtcclxuICAgIG9wdGlvbnMuYWFiYiA9IGFhYmI7XHJcbiAgICBPY3RyZWVOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIHN1YmRpdmlzaW9uIGRlcHRoXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4RGVwdGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXhEZXB0aCA9IHR5cGVvZihvcHRpb25zLm1heERlcHRoKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heERlcHRoIDogODtcclxufVxyXG5PY3RyZWUucHJvdG90eXBlID0gbmV3IE9jdHJlZU5vZGUoKTtcclxuXHJcbk9jdHJlZU5vZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oYWFiYiwgb3B0aW9ucyl7XHJcbiAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc2VydCBkYXRhIGludG8gdGhpcyBub2RlXHJcbiAqIEBtZXRob2QgaW5zZXJ0XHJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50RGF0YVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuT2N0cmVlTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYWFiYiwgZWxlbWVudERhdGEsIGxldmVsKXtcclxuICAgIHZhciBub2RlRGF0YSA9IHRoaXMuZGF0YTtcclxuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcclxuXHJcbiAgICAvLyBJZ25vcmUgb2JqZWN0cyB0aGF0IGRvIG5vdCBiZWxvbmcgaW4gdGhpcyBub2RlXHJcbiAgICBpZiAoIXRoaXMuYWFiYi5jb250YWlucyhhYWJiKSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmplY3QgY2Fubm90IGJlIGFkZGVkXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcbiAgICBpZihsZXZlbCA8ICh0aGlzLm1heERlcHRoIHx8IHRoaXMucm9vdC5tYXhEZXB0aCkpe1xyXG4gICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XHJcbiAgICAgICAgdmFyIHN1YmRpdmlkZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7XHJcbiAgICAgICAgICAgIHN1YmRpdmlkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIHdoaWNoZXZlciBub2RlIHdpbGwgYWNjZXB0IGl0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCArIDEpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihzdWJkaXZpZGVkKXtcclxuICAgICAgICAgICAgLy8gTm8gY2hpbGRyZW4gYWNjZXB0ZWQhIE1pZ2h0IGFzIHdlbGwganVzdCByZW1vdmUgZW0gc2luY2UgdGhleSBjb250YWluIG5vbmVcclxuICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGVcclxuICAgIG5vZGVEYXRhLnB1c2goZWxlbWVudERhdGEpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxudmFyIGhhbGZEaWFnb25hbCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIDggZXF1YWxseSBzaXplZCBjaGlsZHJlbiBub2RlcyBhbmQgcHV0IHRoZW0gaW4gdGhlIC5jaGlsZHJlbiBhcnJheS5cclxuICogQG1ldGhvZCBzdWJkaXZpZGVcclxuICovXHJcbk9jdHJlZU5vZGUucHJvdG90eXBlLnN1YmRpdmlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGFhYmIgPSB0aGlzLmFhYmI7XHJcbiAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZDtcclxuICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG4gICAgY2hpbGRyZW4ucHVzaChcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwwLDApIH0pIH0pLFxyXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDAsMCkgfSkgfSksXHJcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwwKSB9KSB9KSxcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwxLDEpIH0pIH0pLFxyXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDEsMSkgfSkgfSksXHJcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwxKSB9KSB9KSxcclxuICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwwLDEpIH0pIH0pLFxyXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDEsMCkgfSkgfSlcclxuICAgICk7XHJcblxyXG4gICAgdS52c3ViKGwsIGhhbGZEaWFnb25hbCk7XHJcbiAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xyXG5cclxuICAgIHZhciByb290ID0gdGhpcy5yb290IHx8IHRoaXM7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgICAvLyBTZXQgY3VycmVudCBub2RlIGFzIHJvb3RcclxuICAgICAgICBjaGlsZC5yb290ID0gcm9vdDtcclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHNcclxuICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IGNoaWxkLmFhYmIubG93ZXJCb3VuZDtcclxuICAgICAgICBsb3dlckJvdW5kLnggKj0gaGFsZkRpYWdvbmFsLng7XHJcbiAgICAgICAgbG93ZXJCb3VuZC55ICo9IGhhbGZEaWFnb25hbC55O1xyXG4gICAgICAgIGxvd2VyQm91bmQueiAqPSBoYWxmRGlhZ29uYWwuejtcclxuXHJcbiAgICAgICAgbG93ZXJCb3VuZC52YWRkKGwsIGxvd2VyQm91bmQpO1xyXG5cclxuICAgICAgICAvLyBVcHBlciBib3VuZCBpcyBhbHdheXMgbG93ZXIgYm91bmQgKyBoYWxmRGlhZ29uYWxcclxuICAgICAgICBsb3dlckJvdW5kLnZhZGQoaGFsZkRpYWdvbmFsLCBjaGlsZC5hYWJiLnVwcGVyQm91bmQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcclxuICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XHJcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgXCJyZXN1bHRcIiBvYmplY3RcclxuICovXHJcbk9jdHJlZU5vZGUucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCkge1xyXG5cclxuICAgIHZhciBub2RlRGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICAvLyBhYm9ydCBpZiB0aGUgcmFuZ2UgZG9lcyBub3QgaW50ZXJzZWN0IHRoaXMgbm9kZVxyXG4gICAgLy8gaWYgKCF0aGlzLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xyXG4gICAgLy8gICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbFxyXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBub2RlRGF0YSk7XHJcblxyXG4gICAgLy8gQWRkIGNoaWxkIGRhdGFcclxuICAgIC8vIEB0b2RvIHVud3JhcCByZWN1cnNpb24gaW50byBhIHF1ZXVlIC8gbG9vcCwgdGhhdCdzIGZhc3RlciBpbiBKU1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblxyXG4gICAgLy8gZm9yICh2YXIgaSA9IDAsIE4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAvLyAgICAgY2hpbGRyZW5baV0uYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xyXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XHJcbiAgICAgICAgaWYgKG5vZGUuYWFiYi5vdmVybGFwcyhhYWJiKSl7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocXVldWUsIG5vZGUuY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XHJcblxyXG4vKipcclxuICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS5cclxuICogQG1ldGhvZCByYXlRdWVyeVxyXG4gKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IHRyZWVUcmFuc2Zvcm1cclxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XHJcbiAqL1xyXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yYXlRdWVyeSA9IGZ1bmN0aW9uKHJheSwgdHJlZVRyYW5zZm9ybSwgcmVzdWx0KSB7XHJcblxyXG4gICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cclxuICAgIC8vIEB0b2RvIGltcGxlbWVudCByZWFsIHJheSBxdWVyeSB3aGljaCBuZWVkcyBsZXNzIGxvb2t1cHNcclxuICAgIHJheS5nZXRBQUJCKHRtcEFBQkIpO1xyXG4gICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7XHJcbiAgICB0aGlzLmFhYmJRdWVyeSh0bXBBQUJCLCByZXN1bHQpO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZW1vdmVFbXB0eU5vZGVzXHJcbiAqL1xyXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVFbXB0eU5vZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVtb3ZlRW1wdHlOb2RlcygpO1xyXG4gICAgICAgIGlmKCF0aGlzLmNoaWxkcmVuW2ldLmNoaWxkcmVuLmxlbmd0aCAmJiAhdGhpcy5jaGlsZHJlbltpXS5kYXRhLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vbWF0aC9WZWMzXCI6MzJ9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcclxuXHJcbi8qKlxyXG4gKiBGb3IgcG9vbGluZyBvYmplY3RzIHRoYXQgY2FuIGJlIHJldXNlZC5cclxuICogQGNsYXNzIFBvb2xcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBQb29sKCl7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb29sZWQgb2JqZWN0c1xyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yIG9mIHRoZSBvYmplY3RzXHJcbiAgICAgKiBAcHJvcGVydHkge21peGVkfSB0eXBlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IE9iamVjdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbGVhc2UgYW4gb2JqZWN0IGFmdGVyIHVzZVxyXG4gKiBAbWV0aG9kIHJlbGVhc2VcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKi9cclxuUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYXJnczsgaSsrKXtcclxuICAgICAgICB0aGlzLm9iamVjdHMucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFuIG9iamVjdFxyXG4gKiBAbWV0aG9kIGdldFxyXG4gKiBAcmV0dXJuIHttaXhlZH1cclxuICovXHJcblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZih0aGlzLm9iamVjdHMubGVuZ3RoPT09MCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0T2JqZWN0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdHMucG9wKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0IGFuIG9iamVjdC4gU2hvdWxkIGJlIGltcGxtZW50ZWQgaW4gZWFjaCBzdWJjbGFzcy5cclxuICogQG1ldGhvZCBjb25zdHJ1Y3RPYmplY3RcclxuICogQHJldHVybiB7bWl4ZWR9XHJcbiAqL1xyXG5Qb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RPYmplY3QgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RydWN0T2JqZWN0KCkgbm90IGltcGxlbWVudGVkIGluIHRoaXMgUG9vbCBzdWJjbGFzcyB5ZXQhXCIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcmVzaXplXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuUG9vbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgIHZhciBvYmplY3RzID0gdGhpcy5vYmplY3RzO1xyXG5cclxuICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA+IHNpemUpIHtcclxuICAgICAgICBvYmplY3RzLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcclxuICAgICAgICBvYmplY3RzLnB1c2godGhpcy5jb25zdHJ1Y3RPYmplY3QoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxyXG4gICAgICogQHByb3BlcnR5IGRhdGFcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IHsga2V5czpbXSB9O1xyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqL1xyXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcclxuICAgIGlmIChpID4gaikge1xyXG4gICAgICAgIC8vIHN3YXBcclxuICAgICAgICB2YXIgdGVtcCA9IGo7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgaSA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhW2krJy0nK2pdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXHJcbiAqL1xyXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XHJcbiAgICBpZiAoaSA+IGopIHtcclxuICAgICAgICB2YXIgdGVtcCA9IGo7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgaSA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5ID0gaSsnLScrajtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcclxuICAgIGlmKCF0aGlzLmdldChpLGopKXtcclxuICAgICAgICB0aGlzLmRhdGEua2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGRlbFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHBhcmFtICB7TnVtYmVyfSBqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpcyByZW1vdmVcclxuICovXHJcblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oaSwgaikge1xyXG4gICAgaWYgKGkgPiBqKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgICAgIGkgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleSA9IGkrJy0nK2o7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmRhdGEua2V5cy5pbmRleE9mKGtleSk7XHJcbiAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIHRoaXMuZGF0YS5rZXlzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcmVzZXRcclxuICovXHJcblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZGF0YSA9IHsga2V5czpbXSB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0TGVuZ3RoXHJcbiAqL1xyXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICB0aGlzLmRhdGEua2V5cy5sZW5ndGg7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBnZXRLZXlCeUluZGV4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gKi9cclxuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRLZXlCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgIHJldHVybiAgdGhpcy5kYXRhLmtleXNbaW5kZXhdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZ2V0RGF0YUJ5S2V5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBLZXlcclxuICovXHJcblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RGF0YUJ5S2V5ID0gZnVuY3Rpb24oS2V5KSB7XHJcbiAgICByZXR1cm4gIHRoaXMuZGF0YVtLZXldO1xyXG59O1xyXG59LHt9XSw1NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbmZ1bmN0aW9uIFV0aWxzKCl7fVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcclxuXHJcbi8qKlxyXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGRlZmF1bHRzXHJcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSAge29iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmYXVsdCB2YWx1ZXMuXHJcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxyXG4gKi9cclxuVXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cyl7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBmb3IodmFyIGtleSBpbiBkZWZhdWx0cyl7XHJcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xyXG4gICAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufTtcclxuXHJcbn0se31dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBWZWMzUG9vbDtcclxuXHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIFZlYzNQb29sXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBQb29sXHJcbiAqL1xyXG5mdW5jdGlvbiBWZWMzUG9vbCgpe1xyXG4gICAgUG9vbC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy50eXBlID0gVmVjMztcclxufVxyXG5WZWMzUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhIHZlY3RvclxyXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxyXG4gKiBAcmV0dXJuIHtWZWMzfVxyXG4gKi9cclxuVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IFZlYzMoKTtcclxufTtcclxuXHJcbn0se1wiLi4vbWF0aC9WZWMzXCI6MzIsXCIuL1Bvb2xcIjo1M31dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcclxuXHJcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcclxudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcclxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XHJcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XHJcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xyXG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcbnZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJyk7XHJcbnZhciBWZWMzUG9vbCA9IF9kZXJlcV8oJy4uL3V0aWxzL1ZlYzNQb29sJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuXHJcbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHNcclxuICogQHRvZG8gQ29udGFjdCByZWR1Y3Rpb25cclxuICogQHRvZG8gIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlXHJcbiAqL1xyXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSh3b3JsZCl7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnRhY3RQb2ludFBvb2xcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XHJcblxyXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdO1xyXG5cclxuICAgIHRoaXMucmVzdWx0ID0gW107XHJcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb29sZWQgdmVjdG9ycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM1Bvb2x9IHYzcG9vbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnYzcG9vbCA9IG5ldyBWZWMzUG9vbCgpO1xyXG5cclxuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBjb250YWN0IG9iamVjdCwgYnkgdXNpbmcgdGhlIGludGVybmFsIHBvb2wgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxyXG4gKiBAcGFyYW0ge0JvZHl9IGJpXHJcbiAqIEBwYXJhbSB7Qm9keX0gYmpcclxuICogQHBhcmFtIHtTaGFwZX0gc2lcclxuICogQHBhcmFtIHtTaGFwZX0gc2pcclxuICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUFcclxuICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUJcclxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpe1xyXG4gICAgdmFyIGM7XHJcbiAgICBpZih0aGlzLmNvbnRhY3RQb2ludFBvb2wubGVuZ3RoKXtcclxuICAgICAgICBjID0gdGhpcy5jb250YWN0UG9pbnRQb29sLnBvcCgpO1xyXG4gICAgICAgIGMuYmkgPSBiaTtcclxuICAgICAgICBjLmJqID0gYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJpLCBiaik7XHJcbiAgICB9XHJcblxyXG4gICAgYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XHJcblxyXG4gICAgdmFyIGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO1xyXG5cclxuICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcclxuXHJcbiAgICBjLnNldFNwb29rUGFyYW1zKFxyXG4gICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcclxuICAgICAgICBjbS5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uLFxyXG4gICAgICAgIHRoaXMud29ybGQuZHRcclxuICAgICk7XHJcblxyXG4gICAgdmFyIG1hdEEgPSBzaS5tYXRlcmlhbCB8fCBiaS5tYXRlcmlhbDtcclxuICAgIHZhciBtYXRCID0gc2oubWF0ZXJpYWwgfHwgYmoubWF0ZXJpYWw7XHJcbiAgICBpZihtYXRBICYmIG1hdEIgJiYgbWF0QS5yZXN0aXR1dGlvbiA+PSAwICYmIG1hdEIucmVzdGl0dXRpb24gPj0gMCl7XHJcbiAgICAgICAgYy5yZXN0aXR1dGlvbiA9IG1hdEEucmVzdGl0dXRpb24gKiBtYXRCLnJlc3RpdHV0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGMuc2kgPSBvdmVycmlkZVNoYXBlQSB8fCBzaTtcclxuICAgIGMuc2ogPSBvdmVycmlkZVNoYXBlQiB8fCBzajtcclxuXHJcbiAgICByZXR1cm4gYztcclxufTtcclxuXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0ID0gZnVuY3Rpb24oY29udGFjdEVxdWF0aW9uLCBvdXRBcnJheSl7XHJcbiAgICB2YXIgYm9keUEgPSBjb250YWN0RXF1YXRpb24uYmk7XHJcbiAgICB2YXIgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7XHJcbiAgICB2YXIgc2hhcGVBID0gY29udGFjdEVxdWF0aW9uLnNpO1xyXG4gICAgdmFyIHNoYXBlQiA9IGNvbnRhY3RFcXVhdGlvbi5zajtcclxuXHJcbiAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG4gICAgdmFyIGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO1xyXG5cclxuICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW1cclxuICAgIHZhciBmcmljdGlvbiA9IGNtLmZyaWN0aW9uO1xyXG4gICAgdmFyIG1hdEEgPSBzaGFwZUEubWF0ZXJpYWwgfHwgYm9keUEubWF0ZXJpYWw7XHJcbiAgICB2YXIgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDtcclxuICAgIGlmKG1hdEEgJiYgbWF0QiAmJiBtYXRBLmZyaWN0aW9uID49IDAgJiYgbWF0Qi5mcmljdGlvbiA+PSAwKXtcclxuICAgICAgICBmcmljdGlvbiA9IG1hdEEuZnJpY3Rpb24gKiBtYXRCLmZyaWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGZyaWN0aW9uID4gMCl7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zXHJcbiAgICAgICAgdmFyIG11ZyA9IGZyaWN0aW9uICogd29ybGQuZ3Jhdml0eS5sZW5ndGgoKTtcclxuICAgICAgICB2YXIgcmVkdWNlZE1hc3MgPSAoYm9keUEuaW52TWFzcyArIGJvZHlCLmludk1hc3MpO1xyXG4gICAgICAgIGlmKHJlZHVjZWRNYXNzID4gMCl7XHJcbiAgICAgICAgICAgIHJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvb2wgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sO1xyXG4gICAgICAgIHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XHJcbiAgICAgICAgdmFyIGMyID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsYm9keUIsbXVnKnJlZHVjZWRNYXNzKTtcclxuXHJcbiAgICAgICAgYzEuYmkgPSBjMi5iaSA9IGJvZHlBO1xyXG4gICAgICAgIGMxLmJqID0gYzIuYmogPSBib2R5QjtcclxuICAgICAgICBjMS5taW5Gb3JjZSA9IGMyLm1pbkZvcmNlID0gLW11ZypyZWR1Y2VkTWFzcztcclxuICAgICAgICBjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xyXG5cclxuICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcclxuICAgICAgICBjMS5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XHJcbiAgICAgICAgYzEucmouY29weShjb250YWN0RXF1YXRpb24ucmopO1xyXG4gICAgICAgIGMyLnJpLmNvcHkoY29udGFjdEVxdWF0aW9uLnJpKTtcclxuICAgICAgICBjMi5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XHJcblxyXG4gICAgICAgIC8vIENvbnN0cnVjdCB0YW5nZW50c1xyXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbi5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xyXG4gICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XHJcbiAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTtcclxuXHJcbiAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcclxuXHJcbiAgICAgICAgb3V0QXJyYXkucHVzaChjMSwgYzIpO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgYXZlcmFnZU5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBhdmVyYWdlQ29udGFjdFBvaW50QSA9IG5ldyBWZWMzKCk7XHJcbnZhciBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uKG51bUNvbnRhY3RzKXtcclxuICAgIC8vIFRoZSBsYXN0IGNvbnRhY3RFcXVhdGlvblxyXG4gICAgdmFyIGMgPSB0aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHJlc3VsdDogdHdvIFwiYXZlcmFnZVwiIGZyaWN0aW9uIGVxdWF0aW9uc1xyXG4gICAgaWYgKCF0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoYywgdGhpcy5mcmljdGlvblJlc3VsdCkgfHwgbnVtQ29udGFjdHMgPT09IDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdO1xyXG4gICAgdmFyIGYyID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGF2ZXJhZ2VOb3JtYWwuc2V0WmVybygpO1xyXG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2V0WmVybygpO1xyXG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2V0WmVybygpO1xyXG5cclxuICAgIHZhciBib2R5QSA9IGMuYmk7XHJcbiAgICB2YXIgYm9keUIgPSBjLmJqO1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcclxuICAgICAgICBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMSAtIGldO1xyXG4gICAgICAgIGlmKGMuYm9keUEgIT09IGJvZHlBKXtcclxuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpO1xyXG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRBKTtcclxuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52c3ViKGMubmksIGF2ZXJhZ2VOb3JtYWwpO1xyXG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRBKTtcclxuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEgLyBudW1Db250YWN0cztcclxuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaSk7XHJcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmopO1xyXG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxyXG4gICAgZjIucmouY29weShmMS5yaik7XHJcbiAgICBhdmVyYWdlTm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTtcclxuICAgIC8vIHJldHVybiBlcTtcclxufTtcclxuXHJcblxyXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XHJcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcclxudmFyIHRtcFF1YXQxID0gbmV3IFF1YXRlcm5pb24oKTtcclxudmFyIHRtcFF1YXQyID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhbGwgY29udGFjdHMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9keSBwYWlyc1xyXG4gKiBAbWV0aG9kIGdldENvbnRhY3RzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHAxIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xyXG4gKiBAcGFyYW0ge2FycmF5fSBwMiBBcnJheSBvZiBib2R5IGluZGljZXNcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFycmF5IHRvIHN0b3JlIGdlbmVyYXRlZCBjb250YWN0c1xyXG4gKiBAcGFyYW0ge2FycmF5fSBvbGRjb250YWN0cyBPcHRpb25hbC4gQXJyYXkgb2YgcmV1c2FibGUgY29udGFjdCBvYmplY3RzXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuZ2V0Q29udGFjdHMgPSBmdW5jdGlvbihwMSwgcDIsIHdvcmxkLCByZXN1bHQsIG9sZGNvbnRhY3RzLCBmcmljdGlvblJlc3VsdCwgZnJpY3Rpb25Qb29sKXtcclxuICAgIC8vIFNhdmUgb2xkIGNvbnRhY3Qgb2JqZWN0c1xyXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gZnJpY3Rpb25Qb29sO1xyXG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XHJcblxyXG4gICAgdmFyIHFpID0gdG1wUXVhdDE7XHJcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcclxuICAgIHZhciB4aSA9IHRtcFZlYzE7XHJcbiAgICB2YXIgeGogPSB0bXBWZWMyO1xyXG5cclxuICAgIGZvcih2YXIgaz0wLCBOPXAxLmxlbmd0aDsgayE9PU47IGsrKyl7XHJcblxyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcclxuICAgICAgICB2YXIgYmkgPSBwMVtrXSxcclxuICAgICAgICAgICAgYmogPSBwMltrXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNvbnRhY3QgbWF0ZXJpYWxcclxuICAgICAgICB2YXIgYm9keUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xyXG4gICAgICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLGJqLm1hdGVyaWFsKSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGp1c3RUZXN0ID0gKCBiaS5jb2xsaXNpb25SZXNwb25zZSA9PSBmYWxzZSB8fCBiai5jb2xsaXNpb25SZXNwb25zZSA9PSBmYWxzZSB8fFxyXG4gICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAoYmkudHlwZSAmIEJvZHkuS0lORU1BVElDKSAmJiAoYmoudHlwZSAmIEJvZHkuU1RBVElDKVxyXG4gICAgICAgICAgICApIHx8IChcclxuICAgICAgICAgICAgICAgIChiaS50eXBlICYgQm9keS5TVEFUSUMpICYmIChiai50eXBlICYgQm9keS5LSU5FTUFUSUMpXHJcbiAgICAgICAgICAgICkgfHwgKFxyXG4gICAgICAgICAgICAgICAgKGJpLnR5cGUgJiBCb2R5LktJTkVNQVRJQykgJiYgKGJqLnR5cGUgJiBCb2R5LktJTkVNQVRJQylcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24ubXVsdChiaS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xyXG4gICAgICAgICAgICBiaS5xdWF0ZXJuaW9uLnZtdWx0KGJpLnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xyXG4gICAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7XHJcbiAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmouc2hhcGVzLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygc2hhcGVzXHJcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcclxuICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7XHJcbiAgICAgICAgICAgICAgICB4ai52YWRkKGJqLnBvc2l0aW9uLCB4aik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoISgoc2kuY29sbGlzaW9uRmlsdGVyTWFzayAmIHNqLmNvbGxpc2lvbkZpbHRlckdyb3VwKSAmJiAoc2ouY29sbGlzaW9uRmlsdGVyTWFzayAmIHNpLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHhpLmRpc3RhbmNlVG8oeGopID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaXMgdHJpZ2dlciA/ICx0cmlnZ2VyIHRlc3RcclxuICAgICAgICAgICAgICAgIGp1c3RUZXN0IHw9IChzaS5jb2xsaXNpb25SZXNwb25zZSA9PSBmYWxzZSkgfHwgKHNqLmNvbGxpc2lvblJlc3BvbnNlID09IGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGlzaW9uIG1hdGVyaWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVDb250YWN0TWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKSB8fCBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29udGFjdHNcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXNbc2kudHlwZSB8IHNqLnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYocmVzb2x2ZXIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcmVzb2x2ZXIuY2FsbCh0aGlzLCBzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHNpLCBzaiwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHJlc29sdmVyLmNhbGwodGhpcywgc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpLCBzaSwgc2osIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJldHZhbCAmJiBqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQuc2hhcGVPdmVybGFwS2VlcGVyLnNldChzaS5pZCwgc2ouaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZC5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoYmkuaWQsIGJqLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7c2k6c2ksIHNqOnNqfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQudHJpZ2dlckRpYy5zZXQoc2kuaWQsIHNqLmlkLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQub2xkVHJpZ2dlckRpYy5zZXQoc2kuaWQsIHNqLmlkLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgbnVtV2FybmluZ3MgPSAwO1xyXG52YXIgbWF4V2FybmluZ3MgPSAxMDtcclxuXHJcbmZ1bmN0aW9uIHdhcm4obXNnKXtcclxuICAgIGlmKG51bVdhcm5pbmdzID4gbWF4V2FybmluZ3Mpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBudW1XYXJuaW5ncysrO1xyXG5cclxuICAgIGNvbnNvbGUud2Fybihtc2cpO1xyXG59XHJcblxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQk9YXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xyXG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4KHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24seGkseGoscWkscWosYmksYmosc2ksc2osanVzdFRlc3QpO1xyXG59O1xyXG5cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveENvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2osanVzdFRlc3QpO1xyXG59O1xyXG5cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hQYXJ0aWNsZSA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzcGhlcmVTcGhlcmVcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVNwaGVyZSA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgIHJldHVybiB4aS5kaXN0YW5jZVNxdWFyZWQoeGopIDwgTWF0aC5wb3coc2kucmFkaXVzICsgc2oucmFkaXVzLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSB3aWxsIGhhdmUgb25seSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2VcclxuICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XHJcblxyXG4gICAgLy8gQ29udGFjdCBub3JtYWxcclxuICAgIHhqLnZzdWIoeGksIHIubmkpO1xyXG4gICAgci5uaS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9uc1xyXG4gICAgci5yaS5jb3B5KHIubmkpO1xyXG4gICAgci5yai5jb3B5KHIubmkpO1xyXG4gICAgci5yaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XHJcbiAgICByLnJqLm11bHQoLXNqLnJhZGl1cywgci5yaik7XHJcblxyXG4gICAgci5yaS52YWRkKHhpLCByLnJpKTtcclxuICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XHJcblxyXG4gICAgci5yai52YWRkKHhqLCByLnJqKTtcclxuICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBwbGFuZVRyaW1lc2hcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbnZhciBwbGFuZVRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lVHJpbWVzaF9yZWxwb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lVHJpbWVzaCA9IGZ1bmN0aW9uKFxyXG4gICAgcGxhbmVTaGFwZSxcclxuICAgIHRyaW1lc2hTaGFwZSxcclxuICAgIHBsYW5lUG9zLFxyXG4gICAgdHJpbWVzaFBvcyxcclxuICAgIHBsYW5lUXVhdCxcclxuICAgIHRyaW1lc2hRdWF0LFxyXG4gICAgcGxhbmVCb2R5LFxyXG4gICAgdHJpbWVzaEJvZHksXHJcbiAgICByc2ksXHJcbiAgICByc2osXHJcbiAgICBqdXN0VGVzdFxyXG4pe1xyXG4gICAgLy8gTWFrZSBjb250YWN0cyFcclxuICAgIHZhciB2ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICB2YXIgbm9ybWFsID0gcGxhbmVUcmltZXNoX25vcm1hbDtcclxuICAgIG5vcm1hbC5zZXQoMCwwLDEpO1xyXG4gICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmVcclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaTx0cmltZXNoU2hhcGUudmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcclxuXHJcbiAgICAgICAgLy8gR2V0IHdvcmxkIHZlcnRleCBmcm9tIHRyaW1lc2hcclxuICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpO1xyXG5cclxuICAgICAgICAvLyBTYWZlIHVwXHJcbiAgICAgICAgdmFyIHYyID0gbmV3IFZlYzMoKTtcclxuICAgICAgICB2Mi5jb3B5KHYpO1xyXG4gICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBwbGFuZSBzaWRlXHJcbiAgICAgICAgdmFyIHJlbHBvcyA9IHBsYW5lVHJpbWVzaF9yZWxwb3M7XHJcbiAgICAgICAgdi52c3ViKHBsYW5lUG9zLCByZWxwb3MpO1xyXG4gICAgICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XHJcblxyXG4gICAgICAgIGlmKGRvdCA8PSAwLjApe1xyXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksdHJpbWVzaEJvZHkscGxhbmVTaGFwZSx0cmltZXNoU2hhcGUscnNpLHJzaik7XHJcblxyXG4gICAgICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcclxuICAgICAgICAgICAgdmFyIHByb2plY3RlZCA9IHBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQ7XHJcbiAgICAgICAgICAgIG5vcm1hbC5zY2FsZShyZWxwb3MuZG90KG5vcm1hbCksIHByb2plY3RlZCk7XHJcbiAgICAgICAgICAgIHYudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cclxuICAgICAgICAgICAgci5yaS5jb3B5KHByb2plY3RlZCk7XHJcbiAgICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgci5yai5jb3B5KHYpO1xyXG4gICAgICAgICAgICByLnJqLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgcmVzdWx0XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzcGhlcmVUcmltZXNoXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNwaGVyZVNoYXBlXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHRyaW1lc2hTaGFwZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICBzcGhlcmVQb3NcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgdHJpbWVzaFBvc1xyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBzcGhlcmVRdWF0XHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHRyaW1lc2hRdWF0XHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHNwaGVyZUJvZHlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgdHJpbWVzaEJvZHlcclxuICovXHJcbnZhciBzcGhlcmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3YgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF92MiA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3RtcCA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3ZhID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZVRyaW1lc2hfdmIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlVHJpbWVzaF92YyA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiA9IG5ldyBBQUJCKCk7XHJcbnZhciBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuVFJJTUVTSF0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlVHJpbWVzaCA9IGZ1bmN0aW9uIChcclxuICAgIHNwaGVyZVNoYXBlLFxyXG4gICAgdHJpbWVzaFNoYXBlLFxyXG4gICAgc3BoZXJlUG9zLFxyXG4gICAgdHJpbWVzaFBvcyxcclxuICAgIHNwaGVyZVF1YXQsXHJcbiAgICB0cmltZXNoUXVhdCxcclxuICAgIHNwaGVyZUJvZHksXHJcbiAgICB0cmltZXNoQm9keSxcclxuICAgIHJzaSxcclxuICAgIHJzaixcclxuICAgIGp1c3RUZXN0XHJcbikge1xyXG5cclxuICAgIHZhciBlZGdlVmVydGV4QSA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEE7XHJcbiAgICB2YXIgZWRnZVZlcnRleEIgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCO1xyXG4gICAgdmFyIGVkZ2VWZWN0b3IgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3I7XHJcbiAgICB2YXIgZWRnZVZlY3RvclVuaXQgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0O1xyXG4gICAgdmFyIGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvcztcclxuICAgIHZhciB0bXAgPSBzcGhlcmVUcmltZXNoX3RtcDtcclxuICAgIHZhciBsb2NhbFNwaGVyZUFBQkIgPSBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQjtcclxuICAgIHZhciB2MiA9IHNwaGVyZVRyaW1lc2hfdjI7XHJcbiAgICB2YXIgcmVscG9zID0gc3BoZXJlVHJpbWVzaF9yZWxwb3M7XHJcbiAgICB2YXIgdHJpYW5nbGVzID0gc3BoZXJlVHJpbWVzaF90cmlhbmdsZXM7XHJcblxyXG4gICAgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2hcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBhYWJiIG9mIHRoZSBzcGhlcmUgbG9jYWxseSBpbiB0aGUgdHJpbWVzaFxyXG4gICAgdmFyIHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1cztcclxuICAgIGxvY2FsU3BoZXJlQUFCQi5sb3dlckJvdW5kLnNldChcclxuICAgICAgICBsb2NhbFNwaGVyZVBvcy54IC0gc3BoZXJlUmFkaXVzLFxyXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsXHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueiAtIHNwaGVyZVJhZGl1c1xyXG4gICAgKTtcclxuICAgIGxvY2FsU3BoZXJlQUFCQi51cHBlckJvdW5kLnNldChcclxuICAgICAgICBsb2NhbFNwaGVyZVBvcy54ICsgc3BoZXJlUmFkaXVzLFxyXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgKyBzcGhlcmVSYWRpdXMsXHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1c1xyXG4gICAgKTtcclxuXHJcbiAgICB0cmltZXNoU2hhcGUuZ2V0VHJpYW5nbGVzSW5BQUJCKGxvY2FsU3BoZXJlQUFCQiwgdHJpYW5nbGVzKTtcclxuICAgIC8vZm9yICh2YXIgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHRyaWFuZ2xlcy5wdXNoKGkpOyAvLyBBbGxcclxuXHJcbiAgICAvLyBWZXJ0aWNlc1xyXG4gICAgdmFyIHYgPSBzcGhlcmVUcmltZXNoX3Y7XHJcbiAgICB2YXIgcmFkaXVzU3F1YXJlZCA9IHNwaGVyZVNoYXBlLnJhZGl1cyAqIHNwaGVyZVNoYXBlLnJhZGl1cztcclxuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCB2KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHZlcnRleCBvdmVybGFwIGluIHNwaGVyZVxyXG4gICAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7XHJcblxyXG4gICAgICAgICAgICBpZihyZWxwb3Mubm9ybTIoKSA8PSByYWRpdXNTcXVhcmVkKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYWZlIHVwXHJcbiAgICAgICAgICAgICAgICB2Mi5jb3B5KHYpO1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB2Miwgdik7XHJcblxyXG4gICAgICAgICAgICAgICAgdi52c3ViKHNwaGVyZVBvcywgcmVscG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LHRyaW1lc2hCb2R5LHNwaGVyZVNoYXBlLHRyaW1lc2hTaGFwZSxyc2kscnNqKTtcclxuICAgICAgICAgICAgICAgIHIubmkuY29weShyZWxwb3MpO1xyXG4gICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByaSBpcyB0aGUgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byB0aGUgc3BoZXJlIHN1cmZhY2VcclxuICAgICAgICAgICAgICAgIHIucmkuY29weShyLm5pKTtcclxuICAgICAgICAgICAgICAgIHIucmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcclxuICAgICAgICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpO1xyXG4gICAgICAgICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHIucmouY29weSh2KTtcclxuICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGFsbCBlZGdlc1xyXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xyXG5cclxuICAgICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIGVkZ2VWZXJ0ZXhBKTtcclxuICAgICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgKChqKzEpJTMpXSwgZWRnZVZlcnRleEIpO1xyXG4gICAgICAgICAgICBlZGdlVmVydGV4Qi52c3ViKGVkZ2VWZXJ0ZXhBLCBlZGdlVmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByb2plY3Qgc3BoZXJlIHBvc2l0aW9uIHRvIHRoZSBlZGdlXHJcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUIgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQWxvbmdFZGdlQSA9IHRtcC5kb3QoZWRnZVZlY3Rvcik7XHJcblxyXG4gICAgICAgICAgICBpZihwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApe1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdyBjaGVjayB0aGUgb3J0aG9nb25hbCBkaXN0YW5jZSBmcm9tIGVkZ2UgdG8gc3BoZXJlIGNlbnRlclxyXG4gICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcclxuXHJcbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5jb3B5KGVkZ2VWZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3JVbml0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5zY2FsZShwb3NpdGlvbkFsb25nRWRnZUEsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAudmFkZChlZGdlVmVydGV4QSwgdG1wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTtcclxuICAgICAgICAgICAgICAgIGlmKGRpc3QgPCBzcGhlcmVTaGFwZS5yYWRpdXMpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSxyc2kscnNqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHRtcCwgdG1wKTtcclxuICAgICAgICAgICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUcmlhbmdsZSBmYWNlc1xyXG4gICAgdmFyIHZhID0gc3BoZXJlVHJpbWVzaF92YTtcclxuICAgIHZhciB2YiA9IHNwaGVyZVRyaW1lc2hfdmI7XHJcbiAgICB2YXIgdmMgPSBzcGhlcmVUcmltZXNoX3ZjO1xyXG4gICAgdmFyIG5vcm1hbCA9IHNwaGVyZVRyaW1lc2hfbm9ybWFsO1xyXG4gICAgZm9yKHZhciBpPTAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyBpICE9PSBOOyBpKyspe1xyXG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7XHJcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldE5vcm1hbCh0cmlhbmdsZXNbaV0sIG5vcm1hbCk7XHJcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTtcclxuICAgICAgICB2YXIgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTtcclxuICAgICAgICBub3JtYWwuc2NhbGUoZGlzdCwgdG1wKTtcclxuICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTtcclxuXHJcbiAgICAgICAgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmVcclxuICAgICAgICBkaXN0ID0gdG1wLmRpc3RhbmNlVG8obG9jYWxTcGhlcmVQb3MpO1xyXG4gICAgICAgIGlmKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKXtcclxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSxyc2kscnNqKTtcclxuXHJcbiAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcclxuICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7XHJcbiAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLnJpLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XHJcbn07XHJcblxyXG52YXIgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lX3RvX3NwaGVyZV9vcnRobyA9IG5ldyBWZWMzKCk7XHJcbnZhciBwX3NfbmkgPSBuZXcgVmVjMygpOyBcclxudmFyIHBfc19yaSA9IG5ldyBWZWMzKCk7XHJcbnZhciBwX3NfcmogPSBuZXcgVmVjMygpOyBcclxuLyoqXHJcbiAqIEBtZXRob2Qgc3BoZXJlUGxhbmVcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5QTEFORV0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGxhbmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIC8vIENvbnRhY3Qgbm9ybWFsXHJcbiAgICBwX3Nfbmkuc2V0KDAsMCwxKTtcclxuICAgIHFqLnZtdWx0KHBfc19uaSwgcF9zX25pKTtcclxuICAgIHBfc19uaS5uZWdhdGUocF9zX25pKTsgLy8gYm9keSBpIGlzIHRoZSBzcGhlcmUsIGZsaXAgbm9ybWFsXHJcbiAgICBwX3Nfbmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD9cclxuXHJcbiAgICAvLyBWZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3QgcG9pbnRcclxuICAgIHBfc19uaS5tdWx0KHNpLnJhZGl1cywgcF9zX3JpKTtcclxuXHJcbiAgICAvLyBQcm9qZWN0IGRvd24gc3BoZXJlIG9uIHBsYW5lXHJcbiAgICB4aS52c3ViKHhqLCBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUpO1xyXG4gICAgcF9zX25pLm11bHQocF9zX25pLmRvdChwb2ludF9vbl9wbGFuZV90b19zcGhlcmUpLCBwbGFuZV90b19zcGhlcmVfb3J0aG8pO1xyXG4gICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLCBwX3NfcmopOyAvLyBUaGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byBwbGFuZVxyXG5cclxuICAgIGlmKC1wb2ludF9vbl9wbGFuZV90b19zcGhlcmUuZG90KHBfc19uaSkgPD0gc2kucmFkaXVzKXtcclxuXHJcbiAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2VcclxuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcclxuICAgICAgICByLm5pLmNvcHkocF9zX25pKTtyLnJpLmNvcHkocF9zX3JpKTtyLnJqLmNvcHkocF9zX3JqKTtcclxuICAgICAgICB2YXIgcmkgPSByLnJpO1xyXG4gICAgICAgIHZhciByaiA9IHIucmo7XHJcbiAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xyXG4gICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuICAgICAgICByai52YWRkKHhqLCByaik7XHJcbiAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xyXG5cclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8vIFNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5jb20vQnVsbGV0L0J1bGxldEZ1bGwvU3BoZXJlVHJpYW5nbGVEZXRlY3Rvcl84Y3BwX3NvdXJjZS5odG1sXHJcbnZhciBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTtcclxudmFyIHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgcG9pbnRJblBvbHlnb25fdnRwID0gbmV3IFZlYzMoKTtcclxuZnVuY3Rpb24gcG9pbnRJblBvbHlnb24odmVydHMsIG5vcm1hbCwgcCl7XHJcbiAgICB2YXIgcG9zaXRpdmVSZXN1bHQgPSBudWxsO1xyXG4gICAgdmFyIE4gPSB2ZXJ0cy5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4XHJcbiAgICAgICAgdmFyIGVkZ2UgPSBwb2ludEluUG9seWdvbl9lZGdlO1xyXG4gICAgICAgIHZlcnRzWyhpKzEpICUgKE4pXS52c3ViKHYsZWRnZSk7XHJcblxyXG4gICAgICAgIC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlXHJcbiAgICAgICAgdmFyIGVkZ2VfeF9ub3JtYWwgPSBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsO1xyXG4gICAgICAgIC8vdmFyIGVkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLGVkZ2VfeF9ub3JtYWwpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdmVjdG9yIGJldHdlZW4gcG9pbnQgYW5kIGN1cnJlbnQgdmVydGV4XHJcbiAgICAgICAgdmFyIHZlcnRleF90b19wID0gcG9pbnRJblBvbHlnb25fdnRwO1xyXG4gICAgICAgIHAudnN1Yih2LHZlcnRleF90b19wKTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXHJcbiAgICAgICAgdmFyIHIgPSBlZGdlX3hfbm9ybWFsLmRvdCh2ZXJ0ZXhfdG9fcCk7XHJcblxyXG4gICAgICAgIC8vIElmIGFsbCBzdWNoIGRvdCBwcm9kdWN0cyBoYXZlIHNhbWUgc2lnbiwgd2UgYXJlIGluc2lkZSB0aGUgcG9seWdvbi5cclxuICAgICAgICBpZihwb3NpdGl2ZVJlc3VsdD09PW51bGwgfHwgKHI+MCAmJiBwb3NpdGl2ZVJlc3VsdD09PXRydWUpIHx8IChyPD0wICYmIHBvc2l0aXZlUmVzdWx0PT09ZmFsc2UpKXtcclxuICAgICAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gcj4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxudmFyIGJveF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQm94X25zID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9uczEgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQm94X25zMiA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVCb3hfc2lkZXMgPSBbbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCldO1xyXG52YXIgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQm94X3NpZGVfbnMgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQm94X3NpZGVfbnMxID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzcGhlcmVCb3hcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5CT1hdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUJveCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgdmFyIHYzcG9vbCA9IHRoaXMudjNwb29sO1xyXG5cclxuICAgIC8vIHdlIHJlZmVyIHRvIHRoZSBib3ggYXMgYm9keSBqXHJcbiAgICB2YXIgc2lkZXMgPSBzcGhlcmVCb3hfc2lkZXM7XHJcbiAgICB4aS52c3ViKHhqLGJveF90b19zcGhlcmUpO1xyXG4gICAgc2ouZ2V0U2lkZU5vcm1hbHMoc2lkZXMscWopO1xyXG4gICAgdmFyIFIgPSAgICAgc2kucmFkaXVzO1xyXG4gICAgdmFyIHBlbmV0cmF0aW5nX3NpZGVzID0gW107XHJcblxyXG4gICAgLy8gQ2hlY2sgc2lkZSAocGxhbmUpIGludGVyc2VjdGlvbnNcclxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIFN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBwZW5ldHJhdGlvbiBpbmZvXHJcbiAgICB2YXIgc2lkZV9ucyA9IHNwaGVyZUJveF9zaWRlX25zO1xyXG4gICAgdmFyIHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxO1xyXG4gICAgdmFyIHNpZGVfbnMyID0gc3BoZXJlQm94X3NpZGVfbnMyO1xyXG4gICAgdmFyIHNpZGVfaCA9IG51bGw7XHJcbiAgICB2YXIgc2lkZV9wZW5ldHJhdGlvbnMgPSAwO1xyXG4gICAgdmFyIHNpZGVfZG90MSA9IDA7XHJcbiAgICB2YXIgc2lkZV9kb3QyID0gMDtcclxuICAgIHZhciBzaWRlX2Rpc3RhbmNlID0gbnVsbDtcclxuICAgIGZvcih2YXIgaWR4PTAsbnNpZGVzPXNpZGVzLmxlbmd0aDsgaWR4IT09bnNpZGVzICYmIGZvdW5kPT09ZmFsc2U7IGlkeCsrKXtcclxuICAgICAgICAvLyBHZXQgdGhlIHBsYW5lIHNpZGUgbm9ybWFsIChucylcclxuICAgICAgICB2YXIgbnMgPSBzcGhlcmVCb3hfbnM7XHJcbiAgICAgICAgbnMuY29weShzaWRlc1tpZHhdKTtcclxuXHJcbiAgICAgICAgdmFyIGggPSBucy5ub3JtKCk7XHJcbiAgICAgICAgbnMubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlXHJcbiAgICAgICAgdmFyIGRvdCA9IGJveF90b19zcGhlcmUuZG90KG5zKTtcclxuXHJcbiAgICAgICAgaWYoZG90PGgrUiAmJiBkb3Q+MCl7XHJcbiAgICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayB0aGUgb3RoZXIgdHdvIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdmFyIG5zMSA9IHNwaGVyZUJveF9uczE7XHJcbiAgICAgICAgICAgIHZhciBuczIgPSBzcGhlcmVCb3hfbnMyO1xyXG4gICAgICAgICAgICBuczEuY29weShzaWRlc1soaWR4KzEpJTNdKTtcclxuICAgICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCsyKSUzXSk7XHJcbiAgICAgICAgICAgIHZhciBoMSA9IG5zMS5ub3JtKCk7XHJcbiAgICAgICAgICAgIHZhciBoMiA9IG5zMi5ub3JtKCk7XHJcbiAgICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgbnMyLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgZG90MSA9IGJveF90b19zcGhlcmUuZG90KG5zMSk7XHJcbiAgICAgICAgICAgIHZhciBkb3QyID0gYm94X3RvX3NwaGVyZS5kb3QobnMyKTtcclxuICAgICAgICAgICAgaWYoZG90MTxoMSAmJiBkb3QxPi1oMSAmJiBkb3QyPGgyICYmIGRvdDI+LWgyKXtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZG90LWgtUik7XHJcbiAgICAgICAgICAgICAgICBpZihzaWRlX2Rpc3RhbmNlPT09bnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9kaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9kb3QxID0gZG90MTtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlX2RvdDIgPSBkb3QyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfaCA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9ucy5jb3B5KG5zKTtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlX25zMS5jb3B5KG5zMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9uczIuY29weShuczIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVfcGVuZXRyYXRpb25zKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYoc2lkZV9wZW5ldHJhdGlvbnMpe1xyXG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgIHNpZGVfbnMubXVsdCgtUixyLnJpKTsgLy8gU3BoZXJlIHJcclxuICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7XHJcbiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBzaG91bGQgYmUgb3V0IG9mIHNwaGVyZVxyXG4gICAgICAgIHNpZGVfbnMubXVsdChzaWRlX2gsc2lkZV9ucyk7XHJcbiAgICAgICAgc2lkZV9uczEubXVsdChzaWRlX2RvdDEsc2lkZV9uczEpO1xyXG4gICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMSxzaWRlX25zKTtcclxuICAgICAgICBzaWRlX25zMi5tdWx0KHNpZGVfZG90MixzaWRlX25zMik7XHJcbiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMyLHIucmopO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcclxuICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xyXG4gICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGNvcm5lcnNcclxuICAgIHZhciByaiA9IHYzcG9vbC5nZXQoKTtcclxuICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XHJcbiAgICBmb3IodmFyIGo9MDsgaiE9PTIgJiYgIWZvdW5kOyBqKyspe1xyXG4gICAgICAgIGZvcih2YXIgaz0wOyBrIT09MiAmJiAhZm91bmQ7IGsrKyl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsIT09MiAmJiAhZm91bmQ7IGwrKyl7XHJcbiAgICAgICAgICAgICAgICByai5zZXQoMCwwLDApO1xyXG4gICAgICAgICAgICAgICAgaWYoail7XHJcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSxyaik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMF0scmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoayl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1sxXSxyaik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMV0scmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYobCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1syXSxyaik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMl0scmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxyXG4gICAgICAgICAgICAgICAgeGoudmFkZChyaixzcGhlcmVfdG9fY29ybmVyKTtcclxuICAgICAgICAgICAgICAgIHNwaGVyZV90b19jb3JuZXIudnN1Yih4aSxzcGhlcmVfdG9fY29ybmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSKlIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgICAgICAgICAgICAgIHIucmkuY29weShzcGhlcmVfdG9fY29ybmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIubmkuY29weShyLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJpLm11bHQoUixyLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJqLmNvcHkocmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdjNwb29sLnJlbGVhc2UocmopO1xyXG4gICAgcmogPSBudWxsO1xyXG5cclxuICAgIC8vIENoZWNrIGVkZ2VzXHJcbiAgICB2YXIgZWRnZVRhbmdlbnQgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICB2YXIgZWRnZUNlbnRlciA9IHYzcG9vbC5nZXQoKTtcclxuICAgIHZhciByID0gdjNwb29sLmdldCgpOyAvLyByID0gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlclxyXG4gICAgdmFyIG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICB2YXIgZGlzdCA9IHYzcG9vbC5nZXQoKTtcclxuICAgIHZhciBOc2lkZXMgPSBzaWRlcy5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGo9MDsgaiE9PU5zaWRlcyAmJiAhZm91bmQ7IGorKyl7XHJcbiAgICAgICAgZm9yKHZhciBrPTA7IGshPT1Oc2lkZXMgJiYgIWZvdW5kOyBrKyspe1xyXG4gICAgICAgICAgICBpZihqJTMgIT09IGslMyl7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZWRnZSB0YW5nZW50XHJcbiAgICAgICAgICAgICAgICBzaWRlc1trXS5jcm9zcyhzaWRlc1tqXSxlZGdlVGFuZ2VudCk7XHJcbiAgICAgICAgICAgICAgICBlZGdlVGFuZ2VudC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgci5jb3B5KHhpKTtcclxuICAgICAgICAgICAgICAgIHIudnN1YihlZGdlQ2VudGVyLHIpO1xyXG4gICAgICAgICAgICAgICAgci52c3ViKHhqLHIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9ydGhvbm9ybSA9IHIuZG90KGVkZ2VUYW5nZW50KTsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgZWRnZVRhbmdlbnQubXVsdChvcnRob25vcm0sb3J0aG9nb25hbCk7IC8vIFZlY3RvciBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIgaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lXHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShsPT09aiUzIHx8IGw9PT1rJTMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGwrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB2ZWMgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgcHJvamVjdGVkIHRvIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIHRoZSBlZGdlIHRhbmdlbnRcclxuICAgICAgICAgICAgICAgIGRpc3QuY29weSh4aSk7XHJcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIob3J0aG9nb25hbCxkaXN0KTtcclxuICAgICAgICAgICAgICAgIGRpc3QudnN1YihlZGdlQ2VudGVyLGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgZGlzdC52c3ViKHhqLGRpc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERpc3RhbmNlcyBpbiB0YW5nZW50IGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgaW4gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gaXRcclxuICAgICAgICAgICAgICAgIHZhciB0ZGlzdCA9IE1hdGguYWJzKG9ydGhvbm9ybSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmRpc3QgPSBkaXN0Lm5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0ZGlzdCA8IHNpZGVzW2xdLm5vcm0oKSAmJiBuZGlzdDxSKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLHJlcy5yaik7IC8vIGJveCByalxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yai5jb3B5KHJlcy5yaik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdC5uZWdhdGUocmVzLm5pKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMubmkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS5jb3B5KHJlcy5yaik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGoscmVzLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucmkudnN1Yih4aSxyZXMucmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucmkubXVsdChSLHJlcy5yaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoYmkucG9zaXRpb24sIHJlcy5yaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZhZGQoeGosIHJlcy5yaik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QocmVzLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHYzcG9vbC5yZWxlYXNlKGVkZ2VUYW5nZW50LGVkZ2VDZW50ZXIscixvcnRob2dvbmFsLGRpc3QpO1xyXG59O1xyXG5cclxudmFyIGNvbnZleF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQ29udmV4X2VkZ2VVbml0ID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF9zcGhlcmVUb0Nvcm5lciA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQ29udmV4X3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF93b3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpO1xyXG52YXIgc3BoZXJlQ29udmV4X3BlbmV0cmF0aW9uVmVjID0gbmV3IFZlYzMoKTtcclxudmFyIHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3BoZXJlQ29udmV4XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlQ29udmV4ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XHJcbiAgICB4aS52c3ViKHhqLGNvbnZleF90b19zcGhlcmUpO1xyXG4gICAgdmFyIG5vcm1hbHMgPSBzai5mYWNlTm9ybWFscztcclxuICAgIHZhciBmYWNlcyA9IHNqLmZhY2VzO1xyXG4gICAgdmFyIHZlcnRzID0gc2oudmVydGljZXM7XHJcbiAgICB2YXIgUiA9ICAgICBzaS5yYWRpdXM7XHJcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcclxuXHJcbiAgICAvLyBpZihjb252ZXhfdG9fc3BoZXJlLm5vcm0yKCkgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcclxuICAgIC8vICAgICByZXR1cm47XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gQ2hlY2sgY29ybmVyc1xyXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuXHJcbiAgICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyXHJcbiAgICAgICAgdmFyIHdvcmxkQ29ybmVyID0gc3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyO1xyXG4gICAgICAgIHFqLnZtdWx0KHYsd29ybGRDb3JuZXIpO1xyXG4gICAgICAgIHhqLnZhZGQod29ybGRDb3JuZXIsd29ybGRDb3JuZXIpO1xyXG4gICAgICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyO1xyXG4gICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGksIHNwaGVyZV90b19jb3JuZXIpO1xyXG4gICAgICAgIGlmKHNwaGVyZV90b19jb3JuZXIubm9ybTIoKSA8IFIgKiBSKXtcclxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XHJcbiAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHIubmkuY29weShyLnJpKTtcclxuICAgICAgICAgICAgci5yaS5tdWx0KFIsci5yaSk7XHJcbiAgICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosci5yaik7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXHJcbiAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XHJcbiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgc2lkZSAocGxhbmUpIGludGVyc2VjdGlvbnNcclxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgZm9yKHZhciBpPTAsIG5mYWNlcz1mYWNlcy5sZW5ndGg7IGkhPT1uZmFjZXMgJiYgZm91bmQ9PT1mYWxzZTsgaSsrKXtcclxuICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsc1tpXTtcclxuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ldO1xyXG5cclxuICAgICAgICAvLyBHZXQgd29ybGQtdHJhbnNmb3JtZWQgbm9ybWFsIG9mIHRoZSBmYWNlXHJcbiAgICAgICAgdmFyIHdvcmxkTm9ybWFsID0gc3BoZXJlQ29udmV4X3dvcmxkTm9ybWFsO1xyXG4gICAgICAgIHFqLnZtdWx0KG5vcm1hbCx3b3JsZE5vcm1hbCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlXHJcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDtcclxuICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWzBdXSx3b3JsZFBvaW50KTtcclxuICAgICAgICB3b3JsZFBvaW50LnZhZGQoeGosd29ybGRQb2ludCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBhIHBvaW50IG9uIHRoZSBzcGhlcmUsIGNsb3Nlc3QgdG8gdGhlIGZhY2Ugbm9ybWFsXHJcbiAgICAgICAgdmFyIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSA9IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmU7XHJcbiAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcclxuICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcclxuXHJcbiAgICAgICAgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmVcclxuICAgICAgICB2YXIgcGVuZXRyYXRpb25WZWMgPSBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWM7XHJcbiAgICAgICAgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLnZzdWIod29ybGRQb2ludCxwZW5ldHJhdGlvblZlYyk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBwZW5ldHJhdGlvbi4gTmVnYXRpdmUgdmFsdWUgbWVhbnMgb3ZlcmxhcC5cclxuICAgICAgICB2YXIgcGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvblZlYy5kb3Qod29ybGROb3JtYWwpO1xyXG5cclxuICAgICAgICB2YXIgd29ybGRQb2ludFRvU3BoZXJlID0gc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludDtcclxuICAgICAgICB4aS52c3ViKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnRUb1NwaGVyZSk7XHJcblxyXG4gICAgICAgIGlmKHBlbmV0cmF0aW9uIDwgMCAmJiB3b3JsZFBvaW50VG9TcGhlcmUuZG90KHdvcmxkTm9ybWFsKT4wKXtcclxuICAgICAgICAgICAgLy8gSW50ZXJzZWN0cyBwbGFuZS4gTm93IGNoZWNrIGlmIHRoZSBzcGhlcmUgaXMgaW5zaWRlIHRoZSBmYWNlIHBvbHlnb25cclxuICAgICAgICAgICAgdmFyIGZhY2VWZXJ0cyA9IFtdOyAvLyBGYWNlIHZlcnRpY2VzLCBpbiB3b3JsZCBjb29yZHNcclxuICAgICAgICAgICAgZm9yKHZhciBqPTAsIE52ZXJ0cz1mYWNlLmxlbmd0aDsgaiE9PU52ZXJ0czsgaisrKXtcclxuICAgICAgICAgICAgICAgIHZhciB3b3JsZFZlcnRleCA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2Vbal1dLCB3b3JsZFZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICB4ai52YWRkKHdvcmxkVmVydGV4LHdvcmxkVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIGZhY2VWZXJ0cy5wdXNoKHdvcmxkVmVydGV4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocG9pbnRJblBvbHlnb24oZmFjZVZlcnRzLHdvcmxkTm9ybWFsLHhpKSl7IC8vIElzIHRoZSBzcGhlcmUgY2VudGVyIGluIHRoZSBmYWNlIHBvbHlnb24/XHJcbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLVIsIHIucmkpOyAvLyBDb250YWN0IG9mZnNldCwgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHBvaW50aW5nIG91dCBvZiBzcGhlcmVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb25WZWMyID0gdjNwb29sLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtcGVuZXRyYXRpb24sIHBlbmV0cmF0aW9uVmVjMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb25TcGhlcmVQb2ludCA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLVIsIHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xyXG4gICAgICAgICAgICAgICAgeGkudnN1Yih4aixyLnJqKTtcclxuICAgICAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LHIucmopO1xyXG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XHJcbiAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XHJcbiAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uVmVjMik7XHJcbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3RcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEVkZ2U/XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWZhY2UubGVuZ3RoOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdHdvIHdvcmxkIHRyYW5zZm9ybWVkIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gdjNwb29sLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2MiA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzEpJWZhY2UubGVuZ3RoXV0sIHYxKTtcclxuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzIpJWZhY2UubGVuZ3RoXV0sIHYyKTtcclxuICAgICAgICAgICAgICAgICAgICB4ai52YWRkKHYxLCB2MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MiwgdjIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZWRnZSB2ZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHNwaGVyZUNvbnZleF9lZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHYyLnZzdWIodjEsZWRnZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgc2FtZSB2ZWN0b3IsIGJ1dCBub3JtYWxpemVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VVbml0ID0gc3BoZXJlQ29udmV4X2VkZ2VVbml0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UudW5pdChlZGdlVW5pdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHAgaXMgeGkgcHJvamVjdGVkIG9udG8gdGhlIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdjFfdG9feGkgPSB2M3Bvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih2MSwgdjFfdG9feGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3QgPSB2MV90b194aS5kb3QoZWRnZVVuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VVbml0Lm11bHQoZG90LCBwKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnZhZGQodjEsIHApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgdmVjdG9yIGZyb20gcCB0byB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeGlfdG9fcCA9IHYzcG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGksIHhpX3RvX3ApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQU5EIGlmIHAgaXMgaW4gYmV0d2VlbiB2MSBhbmQgdjJcclxuICAgICAgICAgICAgICAgICAgICBpZihkb3QgPiAwICYmIGRvdCpkb3Q8ZWRnZS5ub3JtMigpICYmIHhpX3RvX3Aubm9ybTIoKSA8IFIqUil7IC8vIENvbGxpc2lvbiBpZiB0aGUgZWRnZS1zcGhlcmUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSBjb250YWN0IVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGosci5yaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGksci5uaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByLm5pLm11bHQoUixyLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShmYWNlVmVydHNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHhpX3RvX3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHhpX3RvX3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICBmb3IodmFyIGo9MCwgTmZhY2V2ZXJ0cz1mYWNlVmVydHMubGVuZ3RoOyBqIT09TmZhY2V2ZXJ0czsgaisrKXtcclxuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgcGxhbmVCb3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBwbGFuZUJveFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWF0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xyXG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7XHJcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDtcclxuICAgIHJldHVybiB0aGlzLnBsYW5lQ29udmV4KHNpLHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XHJcbn07XHJcblxyXG52YXIgcGxhbmVDb252ZXhfdiA9IG5ldyBWZWMzKCk7XHJcbnZhciBwbGFuZUNvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgcGxhbmVDb252ZXhfcmVscG9zID0gbmV3IFZlYzMoKTtcclxudmFyIHBsYW5lQ29udmV4X3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBwbGFuZUNvbnZleFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbihcclxuICAgIHBsYW5lU2hhcGUsXHJcbiAgICBjb252ZXhTaGFwZSxcclxuICAgIHBsYW5lUG9zaXRpb24sXHJcbiAgICBjb252ZXhQb3NpdGlvbixcclxuICAgIHBsYW5lUXVhdCxcclxuICAgIGNvbnZleFF1YXQsXHJcbiAgICBwbGFuZUJvZHksXHJcbiAgICBjb252ZXhCb2R5LFxyXG4gICAgc2ksXHJcbiAgICBzaixcclxuICAgIGp1c3RUZXN0XHJcbil7XHJcbiAgICAvLyBTaW1wbHkgcmV0dXJuIHRoZSBwb2ludHMgYmVoaW5kIHRoZSBwbGFuZS5cclxuICAgIHZhciB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3YsXHJcbiAgICAgICAgd29ybGROb3JtYWwgPSBwbGFuZUNvbnZleF9ub3JtYWw7XHJcbiAgICB3b3JsZE5vcm1hbC5zZXQoMCwwLDEpO1xyXG4gICAgcGxhbmVRdWF0LnZtdWx0KHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXHJcblxyXG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcclxuICAgIHZhciByZWxwb3MgPSBwbGFuZUNvbnZleF9yZWxwb3M7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XHJcblxyXG4gICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4XHJcbiAgICAgICAgd29ybGRWZXJ0ZXguY29weShjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgY29udmV4UXVhdC52bXVsdCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpO1xyXG4gICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcclxuICAgICAgICB3b3JsZFZlcnRleC52c3ViKHBsYW5lUG9zaXRpb24sIHJlbHBvcyk7XHJcblxyXG4gICAgICAgIHZhciBkb3QgPSB3b3JsZE5vcm1hbC5kb3QocmVscG9zKTtcclxuICAgICAgICBpZihkb3QgPD0gMC4wKXtcclxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjb252ZXhCb2R5LCBwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSwgc2ksIHNqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXHJcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwbGFuZUNvbnZleF9wcm9qZWN0ZWQ7XHJcbiAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQod29ybGROb3JtYWwuZG90KHJlbHBvcykscHJvamVjdGVkKTtcclxuICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7XHJcbiAgICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmVcclxuXHJcbiAgICAgICAgICAgIHIubmkuY29weSh3b3JsZE5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWwgb3V0IGZyb20gcGxhbmVcclxuXHJcbiAgICAgICAgICAgIC8vIHJqIGlzIG5vdyBqdXN0IHRoZSB2ZWN0b3IgZnJvbSB0aGUgY29udmV4IGNlbnRlciB0byB0aGUgdmVydGV4XHJcbiAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keVxyXG4gICAgICAgICAgICByLnJpLnZhZGQocGxhbmVQb3NpdGlvbiwgci5yaSk7XHJcbiAgICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xyXG4gICAgICAgICAgICByLnJqLnZhZGQoY29udmV4UG9zaXRpb24sIHIucmopO1xyXG4gICAgICAgICAgICByLnJqLnZzdWIoY29udmV4Qm9keS5wb3NpdGlvbiwgci5yaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xyXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cyl7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjb252ZXhDb252ZXhfc2VwQXhpcyA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjb252ZXhDb252ZXhcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0LGZhY2VMaXN0QSxmYWNlTGlzdEIpe1xyXG4gICAgdmFyIHNlcEF4aXMgPSBjb252ZXhDb252ZXhfc2VwQXhpcztcclxuXHJcbiAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZihzaS5maW5kU2VwYXJhdGluZ0F4aXMoc2oseGkscWkseGoscWosc2VwQXhpcyxmYWNlTGlzdEEsZmFjZUxpc3RCKSl7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XHJcbiAgICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLHNqLHhqLHFqLHNlcEF4aXMsLTEwMCwxMDAscmVzKTtcclxuICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXHJcbiAgICAgICAgICAgICAgICByaSA9IHIucmksXHJcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XHJcbiAgICAgICAgICAgIHNlcEF4aXMubmVnYXRlKHIubmkpO1xyXG4gICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcclxuICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XHJcbiAgICAgICAgICAgIHJlc1tqXS5wb2ludC52YWRkKHEsIHJpKTtcclxuICAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxyXG4gICAgICAgICAgICByaS52c3ViKHhpLHJpKTtcclxuICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XHJcbiAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xyXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cyl7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNvbnZleFRyaW1lc2hcclxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG4vLyBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cclxuLy8gTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleFRyaW1lc2ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0LGZhY2VMaXN0QSxmYWNlTGlzdEIpe1xyXG4vLyAgICAgdmFyIHNlcEF4aXMgPSBjb252ZXhDb252ZXhfc2VwQXhpcztcclxuXHJcbi8vICAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xyXG4vLyAgICAgICAgIHJldHVybjtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICAvLyBDb25zdHJ1Y3QgYSB0ZW1wIGh1bGwgZm9yIGVhY2ggdHJpYW5nbGVcclxuLy8gICAgIHZhciBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XHJcblxyXG4vLyAgICAgaHVsbEIuZmFjZXMgPSBbWzAsMSwyXV07XHJcbi8vICAgICB2YXIgdmEgPSBuZXcgVmVjMygpO1xyXG4vLyAgICAgdmFyIHZiID0gbmV3IFZlYzMoKTtcclxuLy8gICAgIHZhciB2YyA9IG5ldyBWZWMzKCk7XHJcbi8vICAgICBodWxsQi52ZXJ0aWNlcyA9IFtcclxuLy8gICAgICAgICB2YSxcclxuLy8gICAgICAgICB2YixcclxuLy8gICAgICAgICB2Y1xyXG4vLyAgICAgXTtcclxuXHJcbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XHJcblxyXG4vLyAgICAgICAgIHZhciB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7XHJcbi8vICAgICAgICAgc2ouZ2V0Tm9ybWFsKGksIHRyaWFuZ2xlTm9ybWFsKTtcclxuLy8gICAgICAgICBodWxsQi5mYWNlTm9ybWFscyA9IFt0cmlhbmdsZU5vcm1hbF07XHJcblxyXG4vLyAgICAgICAgIHNqLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgdmEsIHZiLCB2Yyk7XHJcblxyXG4vLyAgICAgICAgIHZhciBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7XHJcbi8vICAgICAgICAgaWYoIWQpe1xyXG4vLyAgICAgICAgICAgICB0cmlhbmdsZU5vcm1hbC5zY2FsZSgtMSwgdHJpYW5nbGVOb3JtYWwpO1xyXG4vLyAgICAgICAgICAgICBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7XHJcblxyXG4vLyAgICAgICAgICAgICBpZighZCl7XHJcbi8vICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4vLyAgICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XHJcbi8vICAgICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLGh1bGxCLHhqLHFqLHRyaWFuZ2xlTm9ybWFsLC0xMDAsMTAwLHJlcyk7XHJcbi8vICAgICAgICAgaWYocmVzLmxlbmd0aCA9PSAwKSByZXR1cm4gZmFsc2U7XHJcbi8vICAgICAgICAgaWYoanVzdFRlc3QpIHJldHVybiB0cnVlO1xyXG4vLyAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XHJcbi8vICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXHJcbi8vICAgICAgICAgICAgICAgICByaSA9IHIucmksXHJcbi8vICAgICAgICAgICAgICAgICByaiA9IHIucmo7XHJcbi8vICAgICAgICAgICAgIHIubmkuY29weSh0cmlhbmdsZU5vcm1hbCk7XHJcbi8vICAgICAgICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4vLyAgICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcclxuLy8gICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XHJcbi8vICAgICAgICAgICAgIHJlc1tqXS5wb2ludC52YWRkKHEsIHJpKTtcclxuLy8gICAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xyXG5cclxuLy8gICAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxyXG4vLyAgICAgICAgICAgICByaS52c3ViKHhpLHJpKTtcclxuLy8gICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XHJcblxyXG4vLyAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4vLyAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XHJcbi8vICAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuLy8gICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4vLyAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XHJcblxyXG4vLyAgICAgICAgICAgICByZXN1bHQucHVzaChyKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH07XHJcblxyXG52YXIgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgcGFydGljbGVQbGFuZV9yZWxwb3MgPSBuZXcgVmVjMygpO1xyXG52YXIgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcclxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcclxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICB2YXIgbm9ybWFsID0gcGFydGljbGVQbGFuZV9ub3JtYWw7XHJcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcclxuICAgIGJqLnF1YXRlcm5pb24udm11bHQobm9ybWFsLG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvblxyXG4gICAgdmFyIHJlbHBvcyA9IHBhcnRpY2xlUGxhbmVfcmVscG9zO1xyXG4gICAgeGkudnN1Yihiai5wb3NpdGlvbixyZWxwb3MpO1xyXG4gICAgdmFyIGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTtcclxuICAgIGlmKGRvdCA8PSAwLjApe1xyXG5cclxuICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcclxuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXHJcblxyXG4gICAgICAgIC8vIEdldCBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcclxuICAgICAgICB2YXIgcHJvamVjdGVkID0gcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQ7XHJcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcclxuICAgICAgICB4aS52c3ViKHByb2plY3RlZCxwcm9qZWN0ZWQpO1xyXG4gICAgICAgIC8vcHJvamVjdGVkLnZhZGQoYmoucG9zaXRpb24scHJvamVjdGVkKTtcclxuXHJcbiAgICAgICAgLy8gcmogaXMgbm93IHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cclxuICAgICAgICByLnJqLmNvcHkocHJvamVjdGVkKTtcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBwYXJ0aWNsZVNwaGVyZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcGFydGljbGVTcGhlcmVcclxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXHJcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXHJcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXHJcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUEFSVElDTEUgfCBTaGFwZS50eXBlcy5TUEhFUkVdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzaixqdXN0VGVzdCl7XHJcbiAgICAvLyBUaGUgbm9ybWFsIGlzIHRoZSB1bml0IHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGFydGljbGUgY2VudGVyXHJcbiAgICB2YXIgbm9ybWFsID0gcGFydGljbGVTcGhlcmVfbm9ybWFsO1xyXG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XHJcbiAgICB4aS52c3ViKHhqLG5vcm1hbCk7XHJcbiAgICB2YXIgbGVuZ3RoU3F1YXJlZCA9IG5vcm1hbC5ub3JtMigpO1xyXG5cclxuICAgIGlmKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKXtcclxuICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xyXG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICByLnJqLmNvcHkobm9ybWFsKTtcclxuICAgICAgICByLnJqLm11bHQoc2oucmFkaXVzLHIucmopO1xyXG4gICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbFxyXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xyXG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXHJcbiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBXSVBcclxudmFyIGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV9sb2NhbCA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpO1xyXG52YXIgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhQYXJ0aWNsZV93b3JsZFBlbmV0cmF0aW9uVmVjID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNvbnZleFBhcnRpY2xlXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxyXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxyXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxyXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gKi9cclxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4UGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSxyc2kscnNqLGp1c3RUZXN0KXtcclxuICAgIHZhciBwZW5ldHJhdGVkRmFjZUluZGV4ID0gLTE7XHJcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcclxuICAgIHZhciB3b3JsZFBlbmV0cmF0aW9uVmVjID0gY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYztcclxuICAgIHZhciBtaW5QZW5ldHJhdGlvbiA9IG51bGw7XHJcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XHJcblxyXG4gICAgLy8gQ29udmVydCBwYXJ0aWNsZSBwb3NpdGlvbiB4aSB0byBsb2NhbCBjb29yZHMgaW4gdGhlIGNvbnZleFxyXG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XHJcbiAgICBsb2NhbC5jb3B5KHhpKTtcclxuICAgIGxvY2FsLnZzdWIoeGosbG9jYWwpOyAvLyBDb252ZXJ0IHBvc2l0aW9uIHRvIHJlbGF0aXZlIHRoZSBjb252ZXggb3JpZ2luXHJcbiAgICBxai5jb25qdWdhdGUoY3FqKTtcclxuICAgIGNxai52bXVsdChsb2NhbCxsb2NhbCk7XHJcblxyXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xyXG5cclxuICAgICAgICBpZihzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpe1xyXG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNqLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxyXG4gICAgICAgIGZvcih2YXIgaT0wLG5mYWNlcz1zai5mYWNlcy5sZW5ndGg7IGkhPT1uZmFjZXM7IGkrKyl7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICB2YXIgdmVydHMgPSBbIHNqLndvcmxkVmVydGljZXNbIHNqLmZhY2VzW2ldWzBdIF0gXTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHNqLndvcmxkRmFjZU5vcm1hbHNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBob3cgbXVjaCB0aGUgcGFydGljbGUgcGVuZXRyYXRlcyB0aGUgcG9seWdvbiBwbGFuZS5cclxuICAgICAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSxjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlKTtcclxuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XHJcbiAgICAgICAgICAgIGlmKG1pblBlbmV0cmF0aW9uPT09bnVsbCB8fCBNYXRoLmFicyhwZW5ldHJhdGlvbik8TWF0aC5hYnMobWluUGVuZXRyYXRpb24pKXtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuY29weShub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgbnVtRGV0ZWN0ZWRGYWNlcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihwZW5ldHJhdGVkRmFjZUluZGV4IT09LTEpe1xyXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWN0XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XHJcbiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlTm9ybWFsLm11bHQobWluUGVuZXRyYXRpb24sIHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmogaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZmFjZVxyXG4gICAgICAgICAgICB3b3JsZFBlbmV0cmF0aW9uVmVjLnZhZGQoeGksd29ybGRQZW5ldHJhdGlvblZlYyk7XHJcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aix3b3JsZFBlbmV0cmF0aW9uVmVjKTtcclxuICAgICAgICAgICAgci5yai5jb3B5KHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG4gICAgICAgICAgICAvL3ZhciBwcm9qZWN0ZWRUb0ZhY2UgPSB4aS52c3ViKHhqKS52YWRkKHdvcmxkUGVuZXRyYXRpb25WZWMpO1xyXG4gICAgICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xyXG5cclxuICAgICAgICAgICAgLy9xai52bXVsdChyLnJqLHIucmopO1xyXG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoIHIubmkgKTsgLy8gQ29udGFjdCBub3JtYWxcclxuICAgICAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcclxuXHJcbiAgICAgICAgICAgIHZhciByaSA9IHIucmksXHJcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xyXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XHJcbiAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcclxuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xyXG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xyXG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XHJcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XHJcbn07XHJcblxyXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcclxudmFyIGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY29udmV4SGVpZ2h0ZmllbGRcclxuICovXHJcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKFxyXG4gICAgY29udmV4U2hhcGUsXHJcbiAgICBoZlNoYXBlLFxyXG4gICAgY29udmV4UG9zLFxyXG4gICAgaGZQb3MsXHJcbiAgICBjb252ZXhRdWF0LFxyXG4gICAgaGZRdWF0LFxyXG4gICAgY29udmV4Qm9keSxcclxuICAgIGhmQm9keSxcclxuICAgIHJzaSxcclxuICAgIHJzaixcclxuICAgIGp1c3RUZXN0XHJcbil7XHJcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcclxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZSxcclxuICAgICAgICByYWRpdXMgPSBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyxcclxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDIsXHJcbiAgICAgICAgZmFjZUxpc3QgPSBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdDtcclxuXHJcbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxyXG4gICAgdmFyIGxvY2FsQ29udmV4UG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMTtcclxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcclxuICAgICAgICBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnkgLSByYWRpdXMpIC8gdykgLSAxLFxyXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXHJcbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXHJcbiAgICBpZihpTWluWCA8IDApeyBpTWluWCA9IDA7IH1cclxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxyXG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XHJcbiAgICBpZihpTWF4WSA8IDApeyBpTWF4WSA9IDA7IH1cclxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cclxuXHJcbiAgICB2YXIgbWluTWF4ID0gW107XHJcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XHJcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xyXG4gICAgdmFyIG1heCA9IG1pbk1heFsxXTtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XHJcbiAgICBpZihsb2NhbENvbnZleFBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsQ29udmV4UG9zLnogKyByYWRpdXMgPCBtaW4pe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xyXG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxyXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChjb252ZXhQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCByc2ksIHJzaiwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxyXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleFNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgY29udmV4UG9zLCB3b3JsZFBpbGxhck9mZnNldCwgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCwgZmFjZUxpc3QsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiBpbnRlcnNlY3Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XHJcbnZhciBzcGhlcmVIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNwaGVyZUhlaWdodGZpZWxkXHJcbiAqL1xyXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cclxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUhlaWdodGZpZWxkID0gZnVuY3Rpb24gKFxyXG4gICAgc3BoZXJlU2hhcGUsXHJcbiAgICBoZlNoYXBlLFxyXG4gICAgc3BoZXJlUG9zLFxyXG4gICAgaGZQb3MsXHJcbiAgICBzcGhlcmVRdWF0LFxyXG4gICAgaGZRdWF0LFxyXG4gICAgc3BoZXJlQm9keSxcclxuICAgIGhmQm9keSxcclxuICAgIHJzaSxcclxuICAgIHJzaixcclxuICAgIGp1c3RUZXN0XHJcbil7XHJcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcclxuICAgICAgICByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXMsXHJcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFNpemUsXHJcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAyO1xyXG5cclxuICAgIC8vIEdldCBzcGhlcmUgcG9zaXRpb24gdG8gaGVpZ2h0ZmllbGQgbG9jYWwhXHJcbiAgICB2YXIgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAxO1xyXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxyXG4gICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXHJcbiAgICAgICAgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnggKyByYWRpdXMpIC8gdykgKyAxLFxyXG4gICAgICAgIGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDEsXHJcbiAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xyXG5cclxuICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cclxuICAgIGlmKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcclxuICAgIGlmKGlNaW5YIDwgMCl7IGlNaW5YID0gMDsgfVxyXG4gICAgaWYoaU1heFggPCAwKXsgaU1heFggPSAwOyB9XHJcbiAgICBpZihpTWluWSA8IDApeyBpTWluWSA9IDA7IH1cclxuICAgIGlmKGlNYXhZIDwgMCl7IGlNYXhZID0gMDsgfVxyXG4gICAgaWYoaU1pblggPj0gZGF0YS5sZW5ndGgpeyBpTWluWCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxyXG4gICAgaWYoaU1heFggPj0gZGF0YS5sZW5ndGgpeyBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxyXG4gICAgaWYoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxyXG4gICAgaWYoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWluWSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxyXG5cclxuICAgIHZhciBtaW5NYXggPSBbXTtcclxuICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcclxuICAgIHZhciBtaW4gPSBtaW5NYXhbMF07XHJcbiAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xyXG5cclxuICAgIC8vIEJhaWwgb3V0IGlmIHdlJ3JlIGNhbnQgdG91Y2ggdGhlIGJvdW5kaW5nIGhlaWdodCBib3hcclxuICAgIGlmKGxvY2FsU3BoZXJlUG9zLnogLSByYWRpdXMgPiBtYXggfHwgbG9jYWxTcGhlcmVQb3MueiArIHJhZGl1cyA8IG1pbil7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XHJcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBudW1Db250YWN0c0JlZm9yZSA9IHJlc3VsdC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxyXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5LCBzcGhlcmVTaGFwZSwgaGZTaGFwZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiBpbnRlcnNlY3Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5zcGhlcmVDb252ZXgoc3BoZXJlU2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBzcGhlcmVQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBzcGhlcmVRdWF0LCBoZlF1YXQsIHNwaGVyZUJvZHksIGhmQm9keSwgc3BoZXJlU2hhcGUsIGhmU2hhcGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSByZXN1bHQubGVuZ3RoIC0gbnVtQ29udGFjdHNCZWZvcmU7XHJcblxyXG4gICAgICAgICAgICBpZihudW1Db250YWN0cyA+IDIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxXHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbnVtQ29udGFjdHMgLSAxOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vY29sbGlzaW9uL1JheVwiOjEwLFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMixcIi4uL21hdGgvUXVhdGVybmlvblwiOjMwLFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjozMSxcIi4uL21hdGgvVmVjM1wiOjMyLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzMsXCIuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvblwiOjQwLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuLi9zb2x2ZXIvU29sdmVyXCI6NDksXCIuLi91dGlscy9WZWMzUG9vbFwiOjU2fV0sNTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XHJcblxyXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcclxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcclxudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcclxudmFyIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJyk7XHJcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcclxudmFyIE5hcnJvd3BoYXNlID0gX2RlcmVxXygnLi9OYXJyb3dwaGFzZScpO1xyXG52YXIgRXZlbnRUYXJnZXQgPSBfZGVyZXFfKCcuLi91dGlscy9FdmVudFRhcmdldCcpO1xyXG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcclxudmFyIE9iamVjdENvbGxpc2lvbk1hdHJpeCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKTtcclxudmFyIE92ZXJsYXBLZWVwZXIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vT3ZlcmxhcEtlZXBlcicpO1xyXG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xyXG52YXIgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XHJcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XHJcbnZhciBUdXBsZURpY3Rpb25hcnkgPSBfZGVyZXFfKCcuLi91dGlscy9UdXBsZURpY3Rpb25hcnknKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xyXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XHJcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XHJcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XHJcblxyXG4vKipcclxuICogVGhlIHBoeXNpY3Mgd29ybGRcclxuICogQGNsYXNzIFdvcmxkXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZ3Jhdml0eV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwXVxyXG4gKiBAcGFyYW0ge0Jyb2FkcGhhc2V9IFtvcHRpb25zLmJyb2FkcGhhc2VdXHJcbiAqIEBwYXJhbSB7U29sdmVyfSBbb3B0aW9ucy5zb2x2ZXJdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZUZhc3RdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5xdWF0Tm9ybWFsaXplU2tpcF1cclxuICovXHJcbmZ1bmN0aW9uIFdvcmxkKG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnRseSAvIGxhc3QgdXNlZCB0aW1lc3RlcC4gSXMgc2V0IHRvIC0xIGlmIG5vdCBhdmFpbGFibGUuIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCBiZWZvcmUgZWFjaCBpbnRlcm5hbCBzdGVwLCB3aGljaCBtZWFucyB0aGF0IGl0IGlzIFwiZnJlc2hcIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR0XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHQgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGJvZGllcyBnbyB0byBzbGVlcCB3aGVuIHRoZXkndmUgYmVlbiBpbmFjdGl2ZVxyXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gISFvcHRpb25zLmFsbG93U2xlZXA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdGhlIGN1cnJlbnQgY29udGFjdHMgKGluc3RhbmNlcyBvZiBDb250YWN0RXF1YXRpb24pIGluIHRoZSB3b3JsZC5cclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0c1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRhY3RzID0gW107XHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb3cgb2Z0ZW4gdG8gbm9ybWFsaXplIHF1YXRlcm5pb25zLiBTZXQgdG8gMCBmb3IgZXZlcnkgc3RlcCwgMSBmb3IgZXZlcnkgc2Vjb25kIGV0Yy4uIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyBwZXJmb3JtYW5jZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGEgc21hbGxlciB2YWx1ZSAoemVybyB0byBiZSBzdXJlIG5vdGhpbmcgY2FuIGdvIHdyb25nKS5cclxuICAgICAqIEBwcm9wZXJ0eSBxdWF0Tm9ybWFsaXplU2tpcFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy5xdWF0Tm9ybWFsaXplU2tpcCA9IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgOiAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIHRydWUgdG8gdXNlIGZhc3QgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBJdCBpcyBvZnRlbiBlbm91Z2ggYWNjdXJhdGUgdG8gdXNlLiBJZiBib2RpZXMgdGVuZCB0byBleHBsb2RlLCBzZXQgdG8gZmFsc2UuXHJcbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZUZhc3RcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQHNlZSBRdWF0ZXJuaW9uLm5vcm1hbGl6ZUZhc3RcclxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVcclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucXVhdE5vcm1hbGl6ZUZhc3QgPSBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0IDogZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2FsbC1jbG9jayB0aW1lIHNpbmNlIHNpbXVsYXRpb24gc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRpbWUgPSAwLjA7XHJcbiAgICB0aGlzLnRpbWVGaXhlZCA9IDAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiB0aW1lc3RlcHMgdGFrZW4gc2luY2Ugc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSBzdGVwbnVtYmVyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0ZXBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vLyBEZWZhdWx0IGFuZCBsYXN0IHRpbWVzdGVwIHNpemVzXHJcbiAgICB0aGlzLmRlZmF1bHRfZHQgPSAxLzYwO1xyXG5cclxuICAgIHRoaXMubmV4dElkID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHlcclxuICAgICAqIEB0eXBlIHtWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpO1xyXG4gICAgaWYob3B0aW9ucy5ncmF2aXR5KXtcclxuICAgICAgICB0aGlzLmdyYXZpdHkuY29weShvcHRpb25zLmdyYXZpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdCBpcyBOYWl2ZUJyb2FkcGhhc2VcclxuICAgICAqIEBwcm9wZXJ0eSBicm9hZHBoYXNlXHJcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9kaWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc29sdmVyIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQgaXMgR1NTb2x2ZXJcclxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZXJcclxuICAgICAqIEB0eXBlIHtTb2x2ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAdHlwZSB7TmFycm93cGhhc2V9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhcclxuXHQgKiBAdHlwZSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9XHJcblx0ICovXHJcblx0dGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxpc2lvbk1hdHJpeCBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheUNvbGxpc2lvbk1hdHJpeH0gY29sbGlzaW9uTWF0cml4UHJldmlvdXNcclxuXHQgKiBAdHlwZSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9XHJcblx0ICovXHJcblx0dGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IG5ldyBBcnJheUNvbGxpc2lvbk1hdHJpeCgpO1xyXG5cclxuICAgIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpO1xyXG4gICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGFkZGVkIG1hdGVyaWFsc1xyXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hdGVyaWFscyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RtYXRlcmlhbHNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGxvb2sgdXAgYSBDb250YWN0TWF0ZXJpYWwgZ2l2ZW4gdHdvIGluc3RhbmNlcyBvZiBNYXRlcmlhbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7VHVwbGVEaWN0aW9uYXJ5fSBjb250YWN0TWF0ZXJpYWxUYWJsZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKFwiZGVmYXVsdFwiKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29udGFjdCBtYXRlcmlhbCBpcyB1c2VkIGlmIG5vIHN1aXRhYmxlIGNvbnRhY3RtYXRlcmlhbCBpcyBmb3VuZCBmb3IgYSBjb250YWN0LlxyXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEB0eXBlIHtDb250YWN0TWF0ZXJpYWx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB7IGZyaWN0aW9uOiAwLjMsIHJlc3RpdHV0aW9uOiAwLjAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgZG9Qcm9maWxpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgcHJvZmlsZVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9maWxlID0ge1xyXG4gICAgICAgIHNvbHZlOjAsXHJcbiAgICAgICAgbWFrZUNvbnRhY3RDb25zdHJhaW50czowLFxyXG4gICAgICAgIGJyb2FkcGhhc2U6MCxcclxuICAgICAgICBpbnRlZ3JhdGU6MCxcclxuICAgICAgICBuYXJyb3dwaGFzZTowLFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWUgYWNjdW11bGF0b3IgZm9yIGludGVycG9sYXRpb24uIFNlZSBodHRwOi8vZ2FmZmVyb25nYW1lcy5jb20vZ2FtZS1waHlzaWNzL2ZpeC15b3VyLXRpbWVzdGVwL1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFjY3VtdWxhdG9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHN1YnN5c3RlbXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdWJzeXN0ZW1zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgd29ybGQuXHJcbiAgICAgKiBAZXZlbnQgYWRkQm9keVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcclxuICAgICAgICB0eXBlOlwiYWRkQm9keVwiLFxyXG4gICAgICAgIGJvZHkgOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC5cclxuICAgICAqIEBldmVudCByZW1vdmVCb2R5XHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHkgVGhlIGJvZHkgdGhhdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcclxuICAgICAgICB0eXBlOlwicmVtb3ZlQm9keVwiLFxyXG4gICAgICAgIGJvZHkgOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaWRUb0JvZHlNYXAgPSB7fTtcclxuXHJcbiAgICB0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyk7XHJcbiAgICB0aGlzLnN1YnN0ZXBzID0gMDtcclxuICAgIHRoaXMuY20gPSBuZXcgT2JqZWN0Q29sbGlzaW9uTWF0cml4KCk7XHJcbiAgICB0aGlzLnRtID0gbmV3IE9iamVjdENvbGxpc2lvbk1hdHJpeCgpO1xyXG4gICAgdGhpcy50cmlnZ2VyRGljID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xyXG4gICAgdGhpcy5vbGRUcmlnZ2VyRGljID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xyXG4gICAgdGhpcy5jb250YWN0c0RpYyA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcclxuICAgIHRoaXMub2xkQ29udGFjdHNEaWMgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XHJcbn1cclxuV29ybGQuaWRUb0JvZHlNYXAgPSB7fTtcclxuV29ybGQuaWRUb1NoYXBlTWFwID0ge307XHJcbldvcmxkLnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xyXG5cclxuLy8gVGVtcCBzdHVmZlxyXG52YXIgdG1wQUFCQjEgPSBuZXcgQUFCQigpO1xyXG52YXIgdG1wQXJyYXkxID0gW107XHJcbnZhciB0bXBSYXkgPSBuZXcgUmF5KCk7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb250YWN0IG1hdGVyaWFsIGJldHdlZW4gbWF0ZXJpYWxzIG0xIGFuZCBtMlxyXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxyXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMVxyXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMlxyXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBjb250YWN0IG1hdGVyaWFsIGlmIGl0IHdhcyBmb3VuZC5cclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5nZXRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihtMSxtMil7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG51bWJlciBvZiBvYmplY3RzIGluIHRoZSB3b3JsZC5cclxuICogQG1ldGhvZCBudW1PYmplY3RzXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmJvZGllcy5sZW5ndGg7XHJcbn07XHJcblxyXG4vKipcclxuICogU3RvcmUgb2xkIGNvbGxpc2lvbiBzdGF0ZSBpbmZvXHJcbiAqIEBtZXRob2QgY29sbGlzaW9uTWF0cml4VGlja1xyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmNvbGxpc2lvbk1hdHJpeFRpY2sgPSBmdW5jdGlvbigpe1xyXG5cdHZhciB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcclxuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gdGhpcy5jb2xsaXNpb25NYXRyaXg7XHJcblx0dGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wO1xyXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XHJcblxyXG4gICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci50aWNrKCk7XHJcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci50aWNrKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGEgcmlnaWQgYm9keSB0byB0aGUgc2ltdWxhdGlvbi5cclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqIEB0b2RvIElmIHRoZSBzaW11bGF0aW9uIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHdoeSByZWNyZXRlIGFuZCBjb3B5IGFycmF5cyBmb3IgZWFjaCBib2R5PyBBY2N1bXVsYXRlIGluIGR5bmFtaWMgYXJyYXlzIGluIHRoaXMgY2FzZS5cclxuICogQHRvZG8gQWRkaW5nIGFuIGFycmF5IG9mIGJvZGllcyBzaG91bGQgYmUgcG9zc2libGUuIFRoaXMgd291bGQgc2F2ZSBzb21lIGxvb3BzIHRvb1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZCA9IFdvcmxkLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24oYm9keSl7XHJcbiAgICBXb3JsZC5TTEVFUElORyA9IGZhbHNlO1xyXG4gICAgaWYodGhpcy5ib2RpZXMuaW5kZXhPZihib2R5KSAhPT0gLTEpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7XHJcbiAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xyXG4gICAgYm9keS53b3JsZCA9IHRoaXM7XHJcbiAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pO1xyXG4gICAgYm9keS5pbml0VmVsb2NpdHkuY29weShib2R5LnZlbG9jaXR5KTtcclxuICAgIGJvZHkudGltZUxhc3RTbGVlcHkgPSB0aGlzLnRpbWU7XHJcbiAgICBpZihib2R5IGluc3RhbmNlb2YgQm9keSl7XHJcbiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pO1xyXG4gICAgfVxyXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHModGhpcy5ib2RpZXMubGVuZ3RoKTtcclxuICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xyXG4gICAgdGhpcy5jbS5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCk7XHJcbiAgICBXb3JsZC5pZFRvQm9keU1hcFtib2R5LmlkXSA9IGJvZHk7XHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXHJcbiAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxyXG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XHJcbiAgICBXb3JsZC5TTEVFUElORyA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxyXG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XHJcbiAgICBXb3JsZC5TTEVFUElORyA9IGZhbHNlO1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcclxuICAgIGlmKGlkeCE9PS0xKXtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpZHgsMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmF5Y2FzdCB0ZXN0XHJcbiAqIEBtZXRob2QgcmF5VGVzdFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGZyb21cclxuICogQHBhcmFtIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnJheWNhc3RBbGwsIC5yYXljYXN0Q2xvc2VzdCBvciAucmF5Y2FzdEFueSBpbnN0ZWFkLlxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLnJheVRlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgcmVzdWx0KXtcclxuICAgIGlmKHJlc3VsdCBpbnN0YW5jZW9mIFJheWNhc3RSZXN1bHQpe1xyXG4gICAgICAgIC8vIERvIHJheWNhc3RjbG9zZXN0XHJcbiAgICAgICAgdGhpcy5yYXljYXN0Q2xvc2VzdChmcm9tLCB0bywge1xyXG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXHJcbiAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRG8gcmF5Y2FzdEFsbFxyXG4gICAgICAgIHRoaXMucmF5Y2FzdEFsbChmcm9tLCB0bywge1xyXG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXHJcbiAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAqIEBtZXRob2QgcmF5Y2FzdEFsbFxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXHJcbiAqIEBwYXJhbSAge1ZlYzN9IHRvXHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXHJcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXHJcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cclxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrKXtcclxuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XHJcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xyXG4gICAgb3B0aW9ucy50byA9IHRvO1xyXG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxyXG4gKiBAbWV0aG9kIHJheWNhc3RBbnlcclxuICogQHBhcmFtICB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xyXG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFOWTtcclxuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XHJcbiAgICBvcHRpb25zLnRvID0gdG87XHJcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcclxuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxyXG4gKiBAbWV0aG9kIHJheWNhc3RDbG9zZXN0XHJcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cclxuICogQHBhcmFtICB7VmVjM30gdG9cclxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cclxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cclxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cclxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxyXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLnJheWNhc3RDbG9zZXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XHJcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQ0xPU0VTVDtcclxuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XHJcbiAgICBvcHRpb25zLnRvID0gdG87XHJcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcclxuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxyXG4gKiBAbWV0aG9kIHJlbW92ZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICogQGRlcHJlY2F0ZWQgVXNlIC5yZW1vdmVCb2R5IGluc3RlYWRcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihib2R5KXtcclxuICAgIFdvcmxkLlNMRUVQSU5HID0gZmFsc2U7XHJcbiAgICBib2R5LndvcmxkID0gbnVsbDtcclxuICAgIHZhciBuID0gdGhpcy5ib2RpZXMubGVuZ3RoIC0gMSxcclxuICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcclxuICAgICAgICBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTtcclxuICAgIGlmKGlkeCAhPT0gLTEpe1xyXG4gICAgICAgIGJvZGllcy5zcGxpY2UoaWR4LCAxKTsgLy8gVG9kbzogc2hvdWxkIHVzZSBhIGdhcmJhZ2UgZnJlZSBtZXRob2RcclxuXHJcbiAgICAgICAgLy8gUmVjb21wdXRlIGluZGV4XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1ib2RpZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcclxuICAgICAgICBkZWxldGUgV29ybGQuaWRUb0JvZHlNYXBbYm9keS5pZF07XHJcbiAgICAgICAgdGhpcy5jbS5zZXROdW1PYmplY3RzKG4pO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcclxuICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAqL1xyXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiBXb3JsZC5pZFRvQm9keU1hcFtpZF07XHJcbn07XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZ2V0U2hhcGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByZXR1cm4gV29ybGQuaWRUb1NoYXBlTWFwW2lkXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkLlxyXG4gKiBAbWV0aG9kIGFkZE1hdGVyaWFsXHJcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1cclxuICogQHRvZG8gTmVjZXNzYXJ5P1xyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24obSl7XHJcbiAgICB0aGlzLm1hdGVyaWFscy5wdXNoKG0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZFxyXG4gKiBAbWV0aG9kIGFkZENvbnRhY3RNYXRlcmlhbFxyXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY21hdFxyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNtYXQpIHtcclxuXHJcbiAgICAvLyBBZGQgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2goY21hdCk7XHJcblxyXG4gICAgLy8gQWRkIGN1cnJlbnQgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgbWF0ZXJpYWwgdGFibGVcclxuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLGNtYXQubWF0ZXJpYWxzWzFdLmlkLGNtYXQpO1xyXG59O1xyXG5cclxuLy8gcGVyZm9ybWFuY2Uubm93KClcclxuaWYodHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyl7XHJcbiAgICBwZXJmb3JtYW5jZSA9IHt9O1xyXG59XHJcbmlmKCFwZXJmb3JtYW5jZS5ub3cpe1xyXG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xyXG4gICAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIHN0ZXBfdG1wMSA9IG5ldyBWZWMzKCk7XHJcblxyXG4vKipcclxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHN0ZXBcclxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWRdICAgIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxyXG4gKiAgICAgd29ybGQuc3RlcCgxLzYwKTtcclxuICpcclxuICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcclxuICovXHJcbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsIHRpbWVTaW5jZUxhc3RDYWxsZWQsIG1heFN1YlN0ZXBzKXtcclxuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XHJcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xyXG5cclxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXHJcblxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcclxuICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XHJcbiAgICAgICAgdGhpcy5zdWJzdGVwcyA9IDE7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRvciArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xyXG4gICAgICAgIHRoaXMuc3Vic3RlcHMgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHRoaXMuc3Vic3RlcHMgPCBtYXhTdWJTdGVwcykge1xyXG4gICAgICAgICAgICAvLyBEbyBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0b3IgLT0gZHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic3RlcHMrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcclxuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gdGhpcy5ib2RpZXMubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xyXG4gICAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgYi5wcmV2aW91c1F1YXRlcm5pb24uc2xlcnAoYi5xdWF0ZXJuaW9uLCB0LCBiLmludGVycG9sYXRlZFF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgICBiLnByZXZpb3VzUXVhdGVybmlvbi5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXJcclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlZCBhZnRlciB0aGUgd29ybGQgaGFzIHN0ZXBwZWQgZm9yd2FyZCBpbiB0aW1lLlxyXG4gICAgICogQGV2ZW50IHBvc3RTdGVwXHJcbiAgICAgKi9cclxuICAgIFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCA9IHt0eXBlOlwicG9zdFN0ZXBcIn0sIC8vIFJldXNhYmxlIGV2ZW50IG9iamVjdHMgdG8gc2F2ZSBtZW1vcnlcclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlZCBiZWZvcmUgdGhlIHdvcmxkIHN0ZXBzIGZvcndhcmQgaW4gdGltZS5cclxuICAgICAqIEBldmVudCBwcmVTdGVwXHJcbiAgICAgKi9cclxuICAgIFdvcmxkX3N0ZXBfcHJlU3RlcEV2ZW50ID0ge3R5cGU6XCJwcmVTdGVwXCJ9LFxyXG4gICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQgPSB7dHlwZTpcImNvbGxpZGVcIiwgYm9keTpudWxsLCBjb250YWN0Om51bGwgfSxcclxuICAgIFdvcmxkX3N0ZXBfb2xkQ29udGFjdHMgPSBbXSwgLy8gUG9vbHMgZm9yIHVudXNlZCBvYmplY3RzXHJcbiAgICBXb3JsZF9zdGVwX2ZyaWN0aW9uRXF1YXRpb25Qb29sID0gW10sXHJcbiAgICBXb3JsZF9zdGVwX3AxID0gW10sIC8vIFJldXNhYmxlIGFycmF5cyBmb3IgY29sbGlzaW9uIHBhaXJzXHJcbiAgICBXb3JsZF9zdGVwX3AyID0gW10sXHJcbiAgICBXb3JsZF9zdGVwX2d2ZWMgPSBuZXcgVmVjMygpLCAvLyBUZW1wb3JhcnkgdmVjdG9ycyBhbmQgcXVhdHNcclxuICAgIFdvcmxkX3N0ZXBfdmkgPSBuZXcgVmVjMygpLFxyXG4gICAgV29ybGRfc3RlcF92aiA9IG5ldyBWZWMzKCksXHJcbiAgICBXb3JsZF9zdGVwX3dpID0gbmV3IFZlYzMoKSxcclxuICAgIFdvcmxkX3N0ZXBfd2ogPSBuZXcgVmVjMygpLFxyXG4gICAgV29ybGRfc3RlcF90MSA9IG5ldyBWZWMzKCksXHJcbiAgICBXb3JsZF9zdGVwX3QyID0gbmV3IFZlYzMoKSxcclxuICAgIFdvcmxkX3N0ZXBfcml4biA9IG5ldyBWZWMzKCksXHJcbiAgICBXb3JsZF9zdGVwX3JqeG4gPSBuZXcgVmVjMygpLFxyXG4gICAgV29ybGRfc3RlcF9zdGVwX3EgPSBuZXcgUXVhdGVybmlvbigpLFxyXG4gICAgV29ybGRfc3RlcF9zdGVwX3cgPSBuZXcgUXVhdGVybmlvbigpLFxyXG4gICAgV29ybGRfc3RlcF9zdGVwX3dxID0gbmV3IFF1YXRlcm5pb24oKSxcclxuICAgIGludklfdGF1X2R0ID0gbmV3IFZlYzMoKTtcclxuV29ybGQucHJvdG90eXBlLmludGVybmFsU3RlcCA9IGZ1bmN0aW9uKGR0KXtcclxuICAgIHRoaXMuZHQgPSBkdDtcclxuXHJcbiAgICB2YXIgd29ybGQgPSB0aGlzLFxyXG4gICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgIGNvbnRhY3RzID0gdGhpcy5jb250YWN0cyxcclxuICAgICAgICBwMSA9IFdvcmxkX3N0ZXBfcDEsXHJcbiAgICAgICAgcDIgPSBXb3JsZF9zdGVwX3AyLFxyXG4gICAgICAgIE4gPSB0aGlzLm51bU9iamVjdHMoKSxcclxuICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcclxuICAgICAgICBzb2x2ZXIgPSB0aGlzLnNvbHZlcixcclxuICAgICAgICBncmF2aXR5ID0gdGhpcy5ncmF2aXR5LFxyXG4gICAgICAgIGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZyxcclxuICAgICAgICBwcm9maWxlID0gdGhpcy5wcm9maWxlLFxyXG4gICAgICAgIERZTkFNSUMgPSBCb2R5LkRZTkFNSUMsXHJcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQsXHJcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxyXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCxcclxuICAgICAgICBnbm9ybSA9IGdyYXZpdHkubm9ybSgpLFxyXG4gICAgICAgIGd4ID0gZ3Jhdml0eS54LFxyXG4gICAgICAgIGd5ID0gZ3Jhdml0eS55LFxyXG4gICAgICAgIGd6ID0gZ3Jhdml0eS56LFxyXG4gICAgICAgIGk9MDtcclxuXHJcbiAgICBpZihkb1Byb2ZpbGluZyl7XHJcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0c1xyXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgIGlmIChiaS51c2VHcmF2aXR5ICYmIGJpLnR5cGUgPT09IERZTkFNSUMpIHsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcclxuICAgICAgICAgICAgdmFyIGYgPSBiaS5mb3JjZSwgbSA9IGJpLm1hc3M7XHJcbiAgICAgICAgICAgIGYueCArPSBtKmd4O1xyXG4gICAgICAgICAgICBmLnkgKz0gbSpneTtcclxuICAgICAgICAgICAgZi56ICs9IG0qZ3o7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBzdWJzeXN0ZW1zXHJcbiAgICBmb3IodmFyIGk9MCwgTnN1YnN5c3RlbXM9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDsgaSE9PU5zdWJzeXN0ZW1zOyBpKyspe1xyXG4gICAgICAgIHRoaXMuc3Vic3lzdGVtc1tpXS51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAgICBpZihkb1Byb2ZpbGluZyl7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cclxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXHJcbiAgICBwMi5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMscDEscDIpO1xyXG4gICAgaWYoZG9Qcm9maWxpbmcpeyBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OyB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxyXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcclxuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gcDEubGVuZ3RoLTE7IGo+PTA7IGotPTEpe1xyXG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSBwMVtqXSAmJiBjLmJvZHlCID09PSBwMltqXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pKXtcclxuICAgICAgICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4VGljaygpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIGNvbnRhY3RzXHJcbiAgICBpZihkb1Byb2ZpbGluZyl7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cclxuICAgIHZhciBvbGRjb250YWN0cyA9IFdvcmxkX3N0ZXBfb2xkQ29udGFjdHM7XHJcbiAgICB2YXIgTm9sZENvbnRhY3RzID0gY29udGFjdHMubGVuZ3RoO1xyXG5cclxuICAgIGZvcihpPTA7IGkhPT1Ob2xkQ29udGFjdHM7IGkrKyl7XHJcbiAgICAgICAgb2xkY29udGFjdHMucHVzaChjb250YWN0c1tpXSk7XHJcbiAgICB9XHJcbiAgICBjb250YWN0cy5sZW5ndGggPSAwO1xyXG5cclxuICAgIC8vIFRyYW5zZmVyIEZyaWN0aW9uRXF1YXRpb24gZnJvbSBjdXJyZW50IGxpc3QgdG8gdGhlIHBvb2wgZm9yIHJldXNlXHJcbiAgICB2YXIgTm9sZEZyaWN0aW9uRXF1YXRpb25zID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wOyBpIT09Tm9sZEZyaWN0aW9uRXF1YXRpb25zOyBpKyspe1xyXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sLnB1c2godGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhcclxuICAgICAgICBwMSxcclxuICAgICAgICBwMixcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIGNvbnRhY3RzLFxyXG4gICAgICAgIG9sZGNvbnRhY3RzLCAvLyBUbyBiZSByZXVzZWRcclxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxyXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sXHJcbiAgICApO1xyXG5cclxuICAgIGlmKGNvbnRhY3RzLmxlbmd0aCA9PSAwICYmIFdvcmxkLlNMRUVQSU5HKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZihkb1Byb2ZpbGluZyl7XHJcbiAgICAgICAgcHJvZmlsZS5uYXJyb3dwaGFzZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vcCBvdmVyIGFsbCBjb2xsaXNpb25zXHJcbiAgICBpZihkb1Byb2ZpbGluZyl7XHJcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuY29udGFjdHMgPSBjb250YWN0cy5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGs9MDsgayE9PW5jb250YWN0czsgaysrKXtcclxuXHJcbiAgICAgICAgLy8gQ3VycmVudCBjb250YWN0XHJcbiAgICAgICAgdmFyIGMgPSBjb250YWN0c1trXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXNcclxuICAgICAgICB2YXIgYmkgPSBjLmJpLFxyXG4gICAgICAgICAgICBiaiA9IGMuYmosXHJcbiAgICAgICAgICAgIHNpID0gYy5zaSxcclxuICAgICAgICAgICAgc2ogPSBjLnNqO1xyXG5cclxuICAgICAgICAvLyAvLyBHZXQgY29sbGlzaW9uIHByb3BlcnRpZXNcclxuICAgICAgICAvLyB2YXIgY207XHJcbiAgICAgICAgLy8gaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xyXG4gICAgICAgIC8vICAgICBjbSA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgY20gPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyAvLyBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcclxuXHJcbiAgICAgICAgLy8gdmFyIG11ID0gY20uZnJpY3Rpb247XHJcbiAgICAgICAgLy8gLy8gYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xyXG5cclxuICAgICAgICAvLyAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXHJcbiAgICAgICAgLy8gaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xyXG4gICAgICAgIC8vICAgICBpZihiaS5tYXRlcmlhbC5mcmljdGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLmZyaWN0aW9uID49IDApe1xyXG4gICAgICAgIC8vICAgICAgICAgbXUgPSBiaS5tYXRlcmlhbC5mcmljdGlvbiAqIGJqLm1hdGVyaWFsLmZyaWN0aW9uO1xyXG4gICAgICAgIC8vICAgICB9XHJcblxyXG4gICAgICAgIC8vICAgICBpZihiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDApe1xyXG4gICAgICAgIC8vICAgICAgICAgYy5yZXN0aXR1dGlvbiA9IGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uICogYmoubWF0ZXJpYWwucmVzdGl0dXRpb247XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vIEVYVEVORFxyXG4gICAgICAgIGlmIChzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCkgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihzaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIHNqLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDApe1xyXG4gICAgICAgICAgICAgICAgYy5yZXN0aXR1dGlvbiA9IHNpLm1hdGVyaWFsLnJlc3RpdHV0aW9uICogc2oubWF0ZXJpYWwucmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpeyAgIFxyXG4gICAgICAgICAgICAgICAgaWYoYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICBjLnJlc3RpdHV0aW9uID0gYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblx0XHQvLyBjLnNldFNwb29rUGFyYW1zKFxyXG4gIC8vICAgICAgICAgICBjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsXHJcbiAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sXHJcbiAgLy8gICAgICAgICAgIGR0XHJcbiAgLy8gICAgICAgKTtcclxuXHJcblx0XHRzb2x2ZXIuYWRkRXF1YXRpb24oYyk7XHJcblxyXG5cdFx0Ly8gLy8gQWRkIGZyaWN0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cclxuXHRcdC8vIGlmKG11ID4gMCl7XHJcblxyXG5cdFx0Ly8gXHQvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xyXG5cdFx0Ly8gXHR2YXIgbXVnID0gbXUgKiBnbm9ybTtcclxuXHRcdC8vIFx0dmFyIHJlZHVjZWRNYXNzID0gKGJpLmludk1hc3MgKyBiai5pbnZNYXNzKTtcclxuXHRcdC8vIFx0aWYocmVkdWNlZE1hc3MgPiAwKXtcclxuXHRcdC8vIFx0XHRyZWR1Y2VkTWFzcyA9IDEvcmVkdWNlZE1hc3M7XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIFx0dmFyIHBvb2wgPSBmcmljdGlvbkVxdWF0aW9uUG9vbDtcclxuXHRcdC8vIFx0dmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTtcclxuXHRcdC8vIFx0dmFyIGMyID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTtcclxuXHRcdC8vIFx0dGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKGMxLCBjMik7XHJcblxyXG5cdFx0Ly8gXHRjMS5iaSA9IGMyLmJpID0gYmk7XHJcblx0XHQvLyBcdGMxLmJqID0gYzIuYmogPSBiajtcclxuXHRcdC8vIFx0YzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XHJcblx0XHQvLyBcdGMxLm1heEZvcmNlID0gYzIubWF4Rm9yY2UgPSBtdWcqcmVkdWNlZE1hc3M7XHJcblxyXG5cdFx0Ly8gXHQvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcclxuXHRcdC8vIFx0YzEucmkuY29weShjLnJpKTtcclxuXHRcdC8vIFx0YzEucmouY29weShjLnJqKTtcclxuXHRcdC8vIFx0YzIucmkuY29weShjLnJpKTtcclxuXHRcdC8vIFx0YzIucmouY29weShjLnJqKTtcclxuXHJcblx0XHQvLyBcdC8vIENvbnN0cnVjdCB0YW5nZW50c1xyXG5cdFx0Ly8gXHRjLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpO1xyXG5cclxuICAvLyAgICAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xyXG4gIC8vICAgICAgICAgICBjMS5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgZHQpO1xyXG4gIC8vICAgICAgICAgICBjMi5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgZHQpO1xyXG5cclxuICAvLyAgICAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjLmVuYWJsZWQ7XHJcblxyXG5cdFx0Ly8gXHQvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxyXG5cdFx0Ly8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzEpO1xyXG5cdFx0Ly8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzIpO1xyXG5cdFx0Ly8gfVxyXG5cclxuICAgICAgICBpZiggYmkuYWxsb3dTbGVlcCAmJlxyXG4gICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcclxuICAgICAgICApe1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQiA9IGJqLnZlbG9jaXR5Lm5vcm0yKCkgKyBiai5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcclxuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwyKTtcclxuICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIqMil7XHJcbiAgICAgICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJqLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxyXG4gICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxyXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxyXG4gICAgICAgICAgICBiaS50eXBlICE9PSBCb2R5LlNUQVRJQ1xyXG4gICAgICAgICl7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubm9ybTIoKSArIGJpLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LDIpO1xyXG4gICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSoyKXtcclxuICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm93IHdlIGtub3cgdGhhdCBpIGFuZCBqIGFyZSBpbiBjb250YWN0LiBTZXQgY29sbGlzaW9uIG1hdHJpeCBzdGF0ZVxyXG5cdFx0dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0KGJpLCBiaiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cy5nZXQoYmksIGJqKSkge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IVxyXG4gICAgICAgICAgICAvLyBXZSByZXVzZSB0aGUgY29sbGlkZUV2ZW50IG9iamVjdCwgb3RoZXJ3aXNlIHdlIHdpbGwgZW5kIHVwIGNyZWF0aW5nIG5ldyBvYmplY3RzIGZvciBlYWNoIG5ldyBjb250YWN0LCBldmVuIGlmIHRoZXJlJ3Mgbm8gZXZlbnQgbGlzdGVuZXIgYXR0YWNoZWQuXHJcbiAgICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBiajtcclxuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7XHJcbiAgICAgICAgICAgIGJpLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJpO1xyXG4gICAgICAgICAgICBiai5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7XHJcbiAgICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIuc2V0KHNpLmlkLCBzai5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbWl0Q29udGFjdEV2ZW50cygpO1xyXG5cclxuICAgIGlmKGRvUHJvZmlsaW5nKXtcclxuICAgICAgICBwcm9maWxlLm1ha2VDb250YWN0Q29uc3RyYWludHMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xyXG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcclxuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xyXG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuICAgICAgICBpZihiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XHJcbiAgICAgICAgICAgIGJpLndha2VVcCgpO1xyXG4gICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdXNlci1hZGRlZCBjb25zdHJhaW50c1xyXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcclxuICAgICAgICBjLnVwZGF0ZSgpO1xyXG4gICAgICAgIGZvcih2YXIgaj0wLCBOZXE9Yy5lcXVhdGlvbnMubGVuZ3RoOyBqIT09TmVxOyBqKyspe1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcclxuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGVxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29sdmUgdGhlIGNvbnN0cmFpbmVkIHN5c3RlbVxyXG4gICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xyXG5cclxuICAgIGlmKGRvUHJvZmlsaW5nKXtcclxuICAgICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3RzIGZyb20gc29sdmVyXHJcbiAgICBzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XHJcblxyXG4gICAgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlsc1xyXG4gICAgdmFyIHBvdyA9IE1hdGgucG93O1xyXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgIGlmKGJpLnR5cGUgJiBEWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcclxuICAgICAgICAgICAgdmFyIGxkID0gcG93KDEuMCAtIGJpLmxpbmVhckRhbXBpbmcsZHQpO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGJpLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICB2Lm11bHQobGQsdik7XHJcbiAgICAgICAgICAgIHZhciBhdiA9IGJpLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgaWYoYXYpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkID0gcG93KDEuMCAtIGJpLmFuZ3VsYXJEYW1waW5nLGR0KTtcclxuICAgICAgICAgICAgICAgIGF2Lm11bHQoYWQsYXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7XHJcblxyXG4gICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xyXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgIGlmKGJpLnByZVN0ZXApe1xyXG4gICAgICAgICAgICBiaS5wcmVTdGVwLmNhbGwoYmkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBMZWFwIGZyb2dcclxuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cclxuICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3XHJcbiAgICBpZihkb1Byb2ZpbGluZyl7XHJcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuICAgIHZhciBzdGVwbnVtYmVyID0gdGhpcy5zdGVwbnVtYmVyO1xyXG4gICAgdmFyIHF1YXROb3JtYWxpemUgPSBzdGVwbnVtYmVyICUgKHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgKyAxKSA9PT0gMDtcclxuICAgIHZhciBxdWF0Tm9ybWFsaXplRmFzdCA9IHRoaXMucXVhdE5vcm1hbGl6ZUZhc3Q7XHJcblxyXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgYm9kaWVzW2ldLmludGVncmF0ZShkdCwgcXVhdE5vcm1hbGl6ZSwgcXVhdE5vcm1hbGl6ZUZhc3QpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jbGVhckZvcmNlcygpO1xyXG5cclxuICAgIHRoaXMuYnJvYWRwaGFzZS5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xyXG4gICAgICAgIHByb2ZpbGUuaW50ZWdyYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgd29ybGQgdGltZVxyXG4gICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgdGhpcy50aW1lRml4ZWQgKz0gZHQ7XHJcbiAgICB0aGlzLnN0ZXBudW1iZXIgKz0gMTtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTtcclxuXHJcbiAgICAvLyBJbnZva2UgcG9zdC1zdGVwIGNhbGxiYWNrc1xyXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgIHZhciBwb3N0U3RlcCA9IGJpLnBvc3RTdGVwO1xyXG4gICAgICAgIGlmKHBvc3RTdGVwKXtcclxuICAgICAgICAgICAgcG9zdFN0ZXAuY2FsbChiaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNsZWVwaW5nIHVwZGF0ZVxyXG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcclxuICAgICAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgV29ybGQuU0xFRVBJTkcgPSB0cnVlO1xyXG4gICAgICAgIGZvcihpPTA7IGkhPT1OOyBpKyspeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiaS50eXBlICE9IEJvZHkuU1RBVElDICYmICFiaS5pc1NsZWVwaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIFdvcmxkLlNMRUVQSU5HID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIFdvcmxkLlNMRUVQSU5HID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZW1pdENvbnRhY3RFdmVudHMgPSAoZnVuY3Rpb24oKXtcclxuICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcclxuICAgIHZhciByZW1vdmFscyA9IFtdO1xyXG4gICAgdmFyIGJlZ2luQ29udGFjdEV2ZW50ID0ge1xyXG4gICAgICAgIHR5cGU6ICdiZWdpbkNvbnRhY3QnLFxyXG4gICAgICAgIGJvZHlBOiBudWxsLFxyXG4gICAgICAgIGJvZHlCOiBudWxsXHJcbiAgICB9O1xyXG4gICAgdmFyIGVuZENvbnRhY3RFdmVudCA9IHtcclxuICAgICAgICB0eXBlOiAnZW5kQ29udGFjdCcsXHJcbiAgICAgICAgYm9keUE6IG51bGwsXHJcbiAgICAgICAgYm9keUI6IG51bGxcclxuICAgIH07XHJcbiAgICB2YXIgYmVnaW5TaGFwZUNvbnRhY3RFdmVudCA9IHtcclxuICAgICAgICB0eXBlOiAnYmVnaW5TaGFwZUNvbnRhY3QnLFxyXG4gICAgICAgIGJvZHlBOiBudWxsLFxyXG4gICAgICAgIGJvZHlCOiBudWxsLFxyXG4gICAgICAgIHNoYXBlQTogbnVsbCxcclxuICAgICAgICBzaGFwZUI6IG51bGxcclxuICAgIH07XHJcbiAgICB2YXIgZW5kU2hhcGVDb250YWN0RXZlbnQgPSB7XHJcbiAgICAgICAgdHlwZTogJ2VuZFNoYXBlQ29udGFjdCcsXHJcbiAgICAgICAgYm9keUE6IG51bGwsXHJcbiAgICAgICAgYm9keUI6IG51bGwsXHJcbiAgICAgICAgc2hhcGVBOiBudWxsLFxyXG4gICAgICAgIHNoYXBlQjogbnVsbFxyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBoYXNCZWdpbkNvbnRhY3QgPSB0aGlzLmhhc0FueUV2ZW50TGlzdGVuZXIoJ2JlZ2luQ29udGFjdCcpO1xyXG4gICAgICAgIHZhciBoYXNFbmRDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRDb250YWN0Jyk7XHJcblxyXG4gICAgICAgIGlmKGhhc0JlZ2luQ29udGFjdCB8fCBoYXNFbmRDb250YWN0KXtcclxuICAgICAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoaGFzQmVnaW5Db250YWN0KXtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQoYWRkaXRpb25zW2ldKTtcclxuICAgICAgICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5Db250YWN0RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5Db250YWN0RXZlbnQuYm9keUIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoaGFzRW5kQ29udGFjdCl7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZhbHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUEgPSB0aGlzLmdldEJvZHlCeUlkKHJlbW92YWxzW2ldKTtcclxuICAgICAgICAgICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QiA9IHRoaXMuZ2V0Qm9keUJ5SWQocmVtb3ZhbHNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kQ29udGFjdEV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUEgPSBlbmRDb250YWN0RXZlbnQuYm9keUIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWRkaXRpb25zLmxlbmd0aCA9IHJlbW92YWxzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHZhciBoYXNCZWdpblNoYXBlQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignYmVnaW5TaGFwZUNvbnRhY3QnKTtcclxuICAgICAgICB2YXIgaGFzRW5kU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRTaGFwZUNvbnRhY3QnKTtcclxuXHJcbiAgICAgICAgaWYoaGFzQmVnaW5TaGFwZUNvbnRhY3QgfHwgaGFzRW5kU2hhcGVDb250YWN0KXtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIuZ2V0RGlmZihhZGRpdGlvbnMsIHJlbW92YWxzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGhhc0JlZ2luU2hhcGVDb250YWN0KXtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVBID0gdGhpcy5nZXRTaGFwZUJ5SWQoYWRkaXRpb25zW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVCID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5O1xyXG4gICAgICAgICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGJlZ2luU2hhcGVDb250YWN0RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuYm9keUEgPSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihoYXNFbmRTaGFwZUNvbnRhY3Qpe1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChyZW1vdmFsc1tpKzFdKTtcclxuICAgICAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gc2hhcGVBLmJvZHk7XHJcbiAgICAgICAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVuZFNoYXBlQ29udGFjdEV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby5cclxuICogQG1ldGhvZCBjbGVhckZvcmNlc1xyXG4gKi9cclxuV29ybGQucHJvdG90eXBlLmNsZWFyRm9yY2VzID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgIHZhciBOID0gYm9kaWVzLmxlbmd0aDtcclxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBOOyBpKyspe1xyXG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICBmb3JjZSA9IGIuZm9yY2UsXHJcbiAgICAgICAgICAgIHRhdSA9IGIudG9ycXVlO1xyXG5cclxuICAgICAgICBiLmZvcmNlLnNldCgwLDAsMCk7XHJcbiAgICAgICAgYi50b3JxdWUuc2V0KDAsMCwwKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjY190cmlnZ2VyID0ge3R5cGU6ICdjYy10cmlnZ2VyJyxldmVudDogJycsc2VsZkJvZHk6IG51bGwsb3RoZXJCb2R5OiBudWxsLHNlbGZTaGFwZTogbnVsbCxvdGhlclNoYXBlOiBudWxsfTtcclxudmFyIGNjX2NvbGxpZGUgPSB7dHlwZTogXCJjYy1jb2xsaWRlXCIsZXZlbnQ6ICcnLGJvZHk6IG51bGwsc2VsZlNoYXBlOiBudWxsLG90aGVyU2hhcGU6IG51bGwsY29udGFjdHM6IG51bGx9O1xyXG52YXIgY2Nfb2xkQ29udGFjdHMgPSBbXTtcclxuV29ybGQucHJvdG90eXBlLmVtaXRUcmlnZ2VyZWRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5zdWJzdGVwcyA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgdmFyIGtleTtcclxuICAgIHZhciBkYXRhO1xyXG4gICAgdmFyIGkgPSB0aGlzLnRyaWdnZXJEaWMuZ2V0TGVuZ3RoKCk7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAga2V5ID0gdGhpcy50cmlnZ2VyRGljLmdldEtleUJ5SW5kZXgoaSk7XHJcbiAgICAgICAgZGF0YSA9IHRoaXMudHJpZ2dlckRpYy5nZXREYXRhQnlLZXkoa2V5KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2hhcGVBID0gZGF0YS5zaTtcclxuICAgICAgICB2YXIgc2hhcGVCID0gZGF0YS5zajtcclxuICAgICAgICBpZiAodGhpcy50bS5nZXQoc2hhcGVBLCBzaGFwZUIpKSB7XHJcbiAgICAgICAgICAgIGNjX3RyaWdnZXIuZXZlbnQgPSAnb25UcmlnZ2VyU3RheSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50bS5zZXQoc2hhcGVBLCBzaGFwZUIsIHRydWUpO1xyXG4gICAgICAgICAgICBjY190cmlnZ2VyLmV2ZW50ID0gJ29uVHJpZ2dlckVudGVyJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2NfdHJpZ2dlci5zZWxmU2hhcGUgPSBzaGFwZUE7XHJcbiAgICAgICAgY2NfdHJpZ2dlci5vdGhlclNoYXBlID0gc2hhcGVCO1xyXG4gICAgICAgIGNjX3RyaWdnZXIuc2VsZkJvZHkgPSBzaGFwZUEuYm9keTtcclxuICAgICAgICBjY190cmlnZ2VyLm90aGVyQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIHNoYXBlQS5kaXNwYXRjaEV2ZW50KGNjX3RyaWdnZXIpO1xyXG5cclxuICAgICAgICBjY190cmlnZ2VyLnNlbGZTaGFwZSA9IHNoYXBlQjtcclxuICAgICAgICBjY190cmlnZ2VyLm90aGVyU2hhcGUgPSBzaGFwZUE7XHJcbiAgICAgICAgY2NfdHJpZ2dlci5zZWxmQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIGNjX3RyaWdnZXIub3RoZXJCb2R5ID0gc2hhcGVBLmJvZHk7XHJcbiAgICAgICAgc2hhcGVCLmRpc3BhdGNoRXZlbnQoY2NfdHJpZ2dlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaSA9IHRoaXMub2xkVHJpZ2dlckRpYy5nZXRMZW5ndGgoKTtcclxuICAgIHdoaWxlIChpID4gMCkge1xyXG4gICAgICAgIGktLTtcclxuICAgICAgICBrZXkgPSB0aGlzLm9sZFRyaWdnZXJEaWMuZ2V0S2V5QnlJbmRleChpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlckRpYy5nZXREYXRhQnlLZXkoa2V5KSAhPSBudWxsKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgZGF0YSA9IHRoaXMub2xkVHJpZ2dlckRpYy5nZXREYXRhQnlLZXkoa2V5KTsgICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB2YXIgc2hhcGVBID0gZGF0YS5zaTtcclxuICAgICAgICB2YXIgc2hhcGVCID0gZGF0YS5zajtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMudG0uc2V0KHNoYXBlQSwgc2hhcGVCLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHRoaXMub2xkVHJpZ2dlckRpYy5kZWwoc2hhcGVBLmlkLCBzaGFwZUIuaWQpKSBpLS07XHJcblxyXG4gICAgICAgIGNjX3RyaWdnZXIuZXZlbnQgPSAnb25UcmlnZ2VyRXhpdCc7XHJcbiAgICAgICAgY2NfdHJpZ2dlci5zZWxmU2hhcGUgPSBzaGFwZUE7XHJcbiAgICAgICAgY2NfdHJpZ2dlci5vdGhlclNoYXBlID0gc2hhcGVCO1xyXG4gICAgICAgIGNjX3RyaWdnZXIuc2VsZkJvZHkgPSBzaGFwZUEuYm9keTtcclxuICAgICAgICBjY190cmlnZ2VyLm90aGVyQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIHNoYXBlQS5kaXNwYXRjaEV2ZW50KGNjX3RyaWdnZXIpO1xyXG5cclxuICAgICAgICBjY190cmlnZ2VyLnNlbGZTaGFwZSA9IHNoYXBlQjtcclxuICAgICAgICBjY190cmlnZ2VyLm90aGVyU2hhcGUgPSBzaGFwZUE7XHJcbiAgICAgICAgY2NfdHJpZ2dlci5zZWxmQm9keSA9IHNoYXBlQi5ib2R5O1xyXG4gICAgICAgIGNjX3RyaWdnZXIub3RoZXJCb2R5ID0gc2hhcGVBLmJvZHk7XHJcbiAgICAgICAgc2hhcGVCLmRpc3BhdGNoRXZlbnQoY2NfdHJpZ2dlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyRGljLnJlc2V0KCk7XHJcbn07XHJcblxyXG5Xb3JsZC5wcm90b3R5cGUuZW1pdENvbGxpc2lvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLnN1YnN0ZXBzID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHZhciBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7XHJcbiAgICB2YXIgaSA9IHRoaXMuY29udGFjdHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIC8vIEN1cnJlbnQgY29udGFjdFxyXG4gICAgICAgIHZhciBjID0gY29udGFjdHNbaV07XHJcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXNcclxuICAgICAgICB2YXIgc2kgPSBjLnNpO1xyXG4gICAgICAgIHZhciBzaiA9IGMuc2o7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmNvbnRhY3RzRGljLmdldChzaS5pZCwgc2ouaWQpO1xyXG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXRlbSA9IHRoaXMuY29udGFjdHNEaWMuc2V0KHNpLmlkLCBzai5pZCwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpdGVtLnB1c2goYyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleTtcclxuICAgIHZhciBkYXRhO1xyXG4gICAgLy8gaXMgY29sbGlzaW9uIGVudGVyIG9yIHN0YXlcclxuICAgIHZhciBpID0gdGhpcy5jb250YWN0c0RpYy5nZXRMZW5ndGgoKTtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBrZXkgPSB0aGlzLmNvbnRhY3RzRGljLmdldEtleUJ5SW5kZXgoaSk7XHJcbiAgICAgICAgZGF0YSA9IHRoaXMuY29udGFjdHNEaWMuZ2V0RGF0YUJ5S2V5KGtleSk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB2YXIgc2kgPSBkYXRhWzBdLnNpO1xyXG4gICAgICAgIHZhciBzaiA9IGRhdGFbMF0uc2o7XHJcbiAgICAgICAgdmFyIGJpID0gc2kuYm9keTtcclxuICAgICAgICB2YXIgYmogPSBzai5ib2R5O1xyXG5cclxuICAgICAgICAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlXHRcdFxyXG4gICAgICAgIGlmICh0aGlzLmNtLmdldChiaSwgYmopKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbGxpc2lvbiBzdGF5XHJcbiAgICAgICAgICAgIGNjX2NvbGxpZGUuZXZlbnQgPSAnb25Db2xsaXNpb25TdGF5JztcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbS5zZXQoYmksIGJqLCB0cnVlKTtcclxuICAgICAgICAgICAgLy8gY29sbGlzaW9uIGVudGVyXHJcbiAgICAgICAgICAgIGNjX2NvbGxpZGUuZXZlbnQgPSAnb25Db2xsaXNpb25FbnRlcic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjY19jb2xsaWRlLmJpID0gYmk7XHJcbiAgICAgICAgY2NfY29sbGlkZS5jb250YWN0ID0gZGF0YVswXTtcclxuXHJcbiAgICAgICAgY2NfY29sbGlkZS5jb250YWN0cyA9IGRhdGE7XHJcblxyXG4gICAgICAgIGNjX2NvbGxpZGUuYm9keSA9IGJqO1xyXG4gICAgICAgIGNjX2NvbGxpZGUuc2VsZlNoYXBlID0gc2k7XHJcbiAgICAgICAgY2NfY29sbGlkZS5vdGhlclNoYXBlID0gc2o7XHJcbiAgICAgICAgYmkuZGlzcGF0Y2hFdmVudChjY19jb2xsaWRlKTtcclxuXHJcbiAgICAgICAgY2NfY29sbGlkZS5ib2R5ID0gYmk7XHJcbiAgICAgICAgY2NfY29sbGlkZS5zZWxmU2hhcGUgPSBzajtcclxuICAgICAgICBjY19jb2xsaWRlLm90aGVyU2hhcGUgPSBzaTtcclxuICAgICAgICBiai5kaXNwYXRjaEV2ZW50KGNjX2NvbGxpZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIG9sZGNvbnRhY3RzID0gY2Nfb2xkQ29udGFjdHM7XHJcbiAgICBmb3IgKGkgPSBvbGRjb250YWN0cy5sZW5ndGg7IGktLTspIHtcclxuICAgICAgICAvLyBDdXJyZW50IGNvbnRhY3RcclxuICAgICAgICB2YXIgYyA9IG9sZGNvbnRhY3RzW2ldO1xyXG5cclxuICAgICAgICAvLyBHZXQgY3VycmVudCBjb2xsaXNpb24gaW5kZWNlc1xyXG4gICAgICAgIHZhciBzaSA9IGMuc2k7XHJcbiAgICAgICAgdmFyIHNqID0gYy5zajtcclxuICAgICAgICBpZiAodGhpcy5vbGRDb250YWN0c0RpYy5nZXQoc2kuaWQsIHNqLmlkKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkQ29udGFjdHNEaWMuc2V0KHNpLmlkLCBzai5pZCwgYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlzIGNvbGxpc2lvbiBleGl0XHJcbiAgICBpID0gdGhpcy5vbGRDb250YWN0c0RpYy5nZXRMZW5ndGgoKTtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBrZXkgPSB0aGlzLm9sZENvbnRhY3RzRGljLmdldEtleUJ5SW5kZXgoaSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFjdHNEaWMuZ2V0RGF0YUJ5S2V5KGtleSkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5vbGRDb250YWN0c0RpYy5nZXREYXRhQnlLZXkoa2V5KTtcclxuICAgICAgICAgICAgdmFyIHNpID0gZGF0YS5zaTtcclxuICAgICAgICAgICAgdmFyIHNqID0gZGF0YS5zajtcclxuICAgICAgICAgICAgdmFyIGJpID0gc2kuYm9keTtcclxuICAgICAgICAgICAgdmFyIGJqID0gc2ouYm9keTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY20uZ2V0KGJpLCBiaikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYmkuaXNTbGVlcGluZygpIHx8ICFiai5pc1NsZWVwaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNtLnNldChiaSwgYmosIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2NfY29sbGlkZS5iaSA9IGJpOyAgICBcclxuICAgICAgICAgICAgICAgICAgICBjY19jb2xsaWRlLmNvbnRhY3QgPSBkYXRhO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsaXNpb24gZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNjX2NvbGxpZGUuZXZlbnQgPSAnb25Db2xsaXNpb25FeGl0JztcclxuICAgICAgICAgICAgICAgICAgICBjY19jb2xsaWRlLmJvZHkgPSBiajtcclxuICAgICAgICAgICAgICAgICAgICBjY19jb2xsaWRlLnNlbGZTaGFwZSA9IHNpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjX2NvbGxpZGUub3RoZXJTaGFwZSA9IHNqO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjX2NvbGxpZGUuY29udGFjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjY19jb2xsaWRlLmNvbnRhY3RzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmkuZGlzcGF0Y2hFdmVudChjY19jb2xsaWRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2NfY29sbGlkZS5ib2R5ID0gYmk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2NfY29sbGlkZS5zZWxmU2hhcGUgPSBzajtcclxuICAgICAgICAgICAgICAgICAgICBjY19jb2xsaWRlLm90aGVyU2hhcGUgPSBzaTtcclxuICAgICAgICAgICAgICAgICAgICBiai5kaXNwYXRjaEV2ZW50KGNjX2NvbGxpZGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXhpdCwgZHVlIHRvIHNsZWVwaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb250YWN0c0RpYy5yZXNldCgpO1xyXG4gICAgdGhpcy5vbGRDb250YWN0c0RpYy5yZXNldCgpO1xyXG4gICAgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IGNjX29sZENvbnRhY3RzOyAgXHJcbiAgICBjY19vbGRDb250YWN0cyA9IHRoaXMuY29udGFjdHMuc2xpY2UoKTtcclxuICAgIHRoaXMuY29udGFjdHMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vY29sbGlzaW9uL0FycmF5Q29sbGlzaW9uTWF0cml4XCI6NCxcIi4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi4vY29sbGlzaW9uL09iamVjdENvbGxpc2lvbk1hdHJpeFwiOjgsXCIuLi9jb2xsaXNpb24vT3ZlcmxhcEtlZXBlclwiOjksXCIuLi9jb2xsaXNpb24vUmF5XCI6MTAsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjExLFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIwLFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMixcIi4uL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI1LFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNixcIi4uL21hdGgvUXVhdGVybmlvblwiOjMwLFwiLi4vbWF0aC9WZWMzXCI6MzIsXCIuLi9vYmplY3RzL0JvZHlcIjozMyxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDgsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjUxLFwiLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5XCI6NTQsXCIuL05hcnJvd3BoYXNlXCI6NTd9XX0se30sWzJdKVxyXG4oMilcclxufSk7Il0sInNvdXJjZVJvb3QiOiIvIn0=